---
jupyter:
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
  language_info:
    codemirror_mode:
      name: ipython
      version: 3
    file_extension: .py
    mimetype: text/x-python
    name: python
    nbconvert_exporter: python
    pygments_lexer: ipython3
    version: 3.10.13
  nbformat: 4
  nbformat_minor: 5
---

<div id="1025dedb-9729-4133-ba44-27e16b3f6d58" class="cell markdown">

# 75ML30D

![17%](https://progress-bar.dev/17?title=progress&width=100)

#### Description:

- Solving 75 Medium Leetcode problems in 30 days.<br>
- Languange of choice: `Python`<br>

#### Timelines:

- Start Date: 9th Jan 2024
- Challenge End Date: 8th Feb 2024

</div>

<div id="ac0f706d-4efe-48c5-9a18-673f17b03559" class="cell code"
execution_count="1">

``` python
from typing import List
import pandas as pd
import numpy as np
import sqlite3
import re
import io
import math
import collections
import itertools
import functools
import random
import string
import tqdm
import bisect

conn = sqlite3.connect(":memory:")

def regexp(expr, item):
    reg = re.compile(expr)
    return reg.search(item) is not None

def read_lc_df(s: str) -> pd.DataFrame:
    temp = pd.read_csv(io.StringIO(s), sep="|", skiprows=2)
    temp = temp.iloc[1:-1, 1:-1]
    temp.columns = temp.columns.map(str.strip)
    temp = temp.map(lambda x: x if type(x) != str else None if x.strip() == 'null' else x.strip())
    return temp
    
conn.create_function("REGEXP", 2, regexp)
```

</div>

<div id="ee524147-766d-4db7-9aff-da65d1a125f5" class="cell markdown">

#### Helper for Binary tree problems

</div>

<div id="bc81f97b-9163-4aa7-bf70-4030e78541a9" class="cell code"
execution_count="2">

``` python
class BinaryTreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

    def to_list(self):
        to_visit = [self]
        visited = []
        while len(to_visit) > 0:
            curr = to_visit.pop(0)
            if curr:
                to_visit.append(curr.left)
                to_visit.append(curr.right)
                visited.append(curr.val)
            else:
                visited.append(curr)
        return visited

    def __str__(self):
        return str(self.val)

    def from_array(nums: List[int]):
        '''Create a Tree from a list of nums. Returns the root node.'''
        if len(nums) == 0:
            return None
        elif len(nums) == 1:
            return BinaryTreeNode(nums[0])
        else:
            forest = [BinaryTreeNode(nums[0])]
            parent_idx = -1
            for i in range(1, len(nums)):

                curr = None
                if nums[i] is not None:
                    curr = BinaryTreeNode(nums[i])
                    forest.append(curr)
                
                if i % 2 == 1:
                    parent_idx += 1
                    forest[parent_idx].left = curr
                else:
                    forest[parent_idx].right = curr

        return forest[0]

temp = BinaryTreeNode.from_array([1,2,3,4,5,6,None,None,None,7,8])
temp.to_list()
```

<div class="output execute_result" execution_count="2">

    [1, 2, 3, 4, 5, 6, None, None, None, 7, 8, None, None, None, None, None, None]

</div>

</div>

<div id="050dce4a-e724-4787-b5d3-96b0057e0680" class="cell markdown">

#### Helper for Singly Linked lists

</div>

<div id="dd983b16-b389-4aca-abbd-321b4bda6a80" class="cell code"
execution_count="3">

``` python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

    def __str__(self):
        return str(self.val)

    def to_singly_linked_list(nums: list[int]):
        root = prev = None
        for n in nums:
            curr = ListNode(n)
            # Init once
            if not root:
                root = curr
            if prev:
                prev.next = curr
            prev = curr
            
        return root

    def to_list(self) -> list[int]:
        result = []
        curr = self
        while curr:
            result.append(curr.val)
            curr = curr.next
        return result
```

</div>

<div id="dfdb20f8-cb04-4ced-8ba0-ba5415ca1afa" class="cell markdown">

# 1.

Date: 09th Jan 2024<br> Medium Leetcode: minimum-path-sum<br> Solution:
<https://leetcode.com/problems/minimum-path-sum/submissions/1141069624>

</div>

<div id="dd43014e-8a00-4630-a67f-4f8e4567de77" class="cell code"
execution_count="4">

``` python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        # Compute once
        height = len(grid)
        width = len(grid[0])

        # Start at the bottom right
        x, y = height - 1, width - 1

        while x >= 0:
            while y >= 0:
                
                add = min(
                    grid[x][y + 1] if y + 1 < width else math.inf,
                    grid[x + 1][y] if x + 1 < height else math.inf
                )
                
                if add != math.inf:
                    grid[x][y] += add
                    
                # Decrement y (go left)
                y -= 1

            # Decrement x (go up)
            x -= 1

            # Reset y
            y = width - 1

        return grid[0][0]

# Test the solution
assert Solution().minPathSum([[1,3,1],[1,5,1],[4,2,1]]) == 7
assert Solution().minPathSum([[1,2,3],[4,5,6]]) == 12
```

</div>

<div id="85611f92-d7ce-41f8-a108-6ff99acfb477" class="cell markdown">

# 2.

Date: 10th Jan 2024<br> Medium Leetcode:
amount-of-time-for-binary-tree-to-be-infected<br> Solution:
<https://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/submissions/1141991104>

</div>

<div id="14d348ef-b781-4e1d-9fd3-ad7f1ae44ca9" class="cell code"
execution_count="5">

``` python
class Solution:
    def amountOfTime(self, root: BinaryTreeNode, start: int) -> int:
        matrix = dict()
        def getAdjacencyMatrix(curr, parent=None):
            if curr:
                vertices = matrix.get(curr, [])

                if parent:
                    vertices.append(parent.val)
                if curr.right:
                    vertices.append(curr.right.val)
                if curr.left:
                    vertices.append(curr.left.val)

                matrix[curr.val] = vertices
    
                # Recurse
                getAdjacencyMatrix(curr.left, curr)
                getAdjacencyMatrix(curr.right, curr)
            

        getAdjacencyMatrix(root)

        # Do a BFS until all nodes are exhausted
        minute = 0
        infected = set({start})
        neighbours = matrix[start]

        while neighbours:
            next_neighbours = []
            for node in neighbours:
                if node not in infected:
                    infected.add(node)
                    next_neighbours.extend(list(filter(lambda x: x not in infected, matrix[node])))

            neighbours = next_neighbours
            minute += 1
                
        return minute
        
# Test the solution
assert Solution().amountOfTime(BinaryTreeNode.from_array([1,5,3,None,4,10,6,9,2]), 3) == 4
assert Solution().amountOfTime(BinaryTreeNode.from_array([1]), 1) == 0
```

</div>

<div id="b91b68be-6fc9-4ff5-b318-09ffc16fecbf" class="cell markdown">

# 3.

Date: 10th Jan 2024<br> Medium Leetcode: dota2-senate<br> Solution:
<https://leetcode.com/problems/dota2-senate/submissions/1142503920/>

</div>

<div id="e8d8396b-ab57-40b1-96cd-a3a28fb4405b" class="cell code"
execution_count="6">

``` python
class Solution:
    def predictPartyVictory(self, senate: str) -> str:

        while senate:

            result = []
            count = 0
            for ch in senate:
                if count == 0:
                    result.append(ch)
                    count = 1
                elif ch != result[-1]:
                    count -= 1
                else:
                    result.append(ch)
                    count += 1
            
            new_result = []
            for ch in result:
                if count > 0 and ch != result[-1]:
                    count -= 1
                else:
                    new_result.append(ch)
    
            senate = "".join(new_result)

            if count == len(senate):
                return "Radiant" if senate[0] == "R" else "Dire"

# Test the solution
assert Solution().predictPartyVictory("RDRDDDRDDRDRDDRRRRRD") == "Dire"
assert Solution().predictPartyVictory("RDRDDRD") == "Dire"
assert Solution().predictPartyVictory("RRDDD") == "Radiant"
```

</div>

<div id="cc04e1bf-561f-4d1b-bf60-d56c1609037a" class="cell markdown">

# 4.

Date: 11th Jan 2024<br> Medium Leetcode:
populating-next-right-pointers-in-each-node<br> Solution:
<https://leetcode.com/problems/populating-next-right-pointers-in-each-node/submissions/1142856094/>

</div>

<div id="5e623cc8-b625-4c41-8b81-df766c40de79" class="cell code"
execution_count="7">

``` python
class Solution:
    def connect(self, root):
        'This takes O(log(n)) space and O(1) complexity, q asked for O(1) space' 

        def backtrack(curr: Node, level: int = 0, right_most: dict = {}):
            if not curr:
                return 

            if level in right_most:
                right_most[level].next = curr

            right_most[level] = curr
            backtrack(curr.left, level + 1, right_most)
            backtrack(curr.right, level + 1, right_most)

        backtrack(root)
        return root
```

</div>

<div id="16f48c33-0f4d-42f7-914b-82e471d40d27" class="cell markdown">

# 5.

Date: 11th Jan 2024<br> Medium Leetcode:
maximum-difference-between-node-and-ancestor<br> Solution:
<https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/submissions/1142882452>

</div>

<div id="d8253cf2-2f02-4552-b1f5-28e02446466f" class="cell code"
execution_count="8">

``` python
class Solution:
    def maxAncestorDiff(self, root: BinaryTreeNode) -> int:
        
        def backtrack(curr):
            
            if not curr:
                return None, None, None

            lmin, lmax, ldiff = backtrack(curr.left) 
            rmin, rmax, rdiff = backtrack(curr.right)
            currMin = currMax = curr.val
            maxDiff = -math.inf

            if curr.left:
                currMin = min(currMin, lmin)
                currMax = max(currMax, lmax)
                maxDiff = max(
                    maxDiff,
                    abs(curr.val - lmin),
                    abs(curr.val - lmax),
                    ldiff
                )

            if curr.right:
                currMin = min(currMin, rmin)
                currMax = max(currMax, rmax)
                maxDiff = max(
                    maxDiff,
                    abs(curr.val - rmin),
                    abs(curr.val - rmax),
                    rdiff
                )

            return currMin, currMax, maxDiff

        return backtrack(root)[2]

# Test ths solution
assert Solution().maxAncestorDiff(BinaryTreeNode.from_array([8,3,10,1,6,None,14,None,None,4,7,13])) == 7
assert Solution().maxAncestorDiff(BinaryTreeNode.from_array([8,3,10,1,6,None,14,None,None,50,7,13])) == 47
assert Solution().maxAncestorDiff(BinaryTreeNode.from_array([1,None,2,None,0,3])) == 3
```

</div>

<div id="110efe35-0982-4f0e-8af5-8512b0352d68" class="cell markdown">

# 6.

Date: 11th Jan 2024<br> Medium Leetcode:
delete-the-middle-node-of-a-linked-list<br> Solution:
<https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/submissions/1142953098>

</div>

<div id="c942014a-1091-436b-b5df-1bcc894052ed" class="cell code"
execution_count="9">

``` python
class Solution:
    def deleteMiddle(self, head: ListNode) -> ListNode:
        'Better approach after seeing the solution is to use the fast pointer / slow pointer approach'
        n, curr = 0, head  
        while curr:
            curr = curr.next
            n += 1

        mid = n // 2

        if mid == 0:
            return None

        prev, curr = None, head
        while mid > 0:
            prev, curr = curr, curr.next
            mid -= 1

        prev.next = curr.next
        curr.next = None
        return head

# Test the solution
assert Solution().deleteMiddle(ListNode.to_singly_linked_list([1])) is None
assert Solution().deleteMiddle(ListNode.to_singly_linked_list([1, 2])).to_list() == [1]
assert Solution().deleteMiddle(ListNode.to_singly_linked_list([1, 2, 3])).to_list() == [1, 3]
assert Solution().deleteMiddle(ListNode.to_singly_linked_list([1, 2, 3, 4])).to_list() == [1, 2, 4]
```

</div>

<div id="d4a21654-0a35-4e54-bd4e-501c8ebb23aa" class="cell markdown">

# 7.

Date: 12th Jan 2024<br> Medium Leetcode:
find-minimum-in-rotated-sorted-array<br> Solution:
<https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/submissions/1144294358/>

</div>

<div id="a14acbbf-f095-4da8-8826-6c01f052715d" class="cell code"
execution_count="10">

``` python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        """
        Objective is to find i such that nums[i] < nums[i - 1]
        """

        # O(1) time complexity
        n = len(nums)

        # Edge case - 1
        if n == 1:
            return nums[0]

        # Edge case - 2
        elif nums[0] < nums[-1]:
            return nums[0]
        
        else:
            start, end = 1, n - 1
            while start <= end:
                mid = (start + end) // 2

                if nums[mid] < nums[mid - 1]:
                    return nums[mid]
                
                elif nums[mid] > nums[0]:
                    start = mid + 1
                
                else:
                    end = mid - 1
            return -1

# Test the solution
assert Solution().findMin([4,5,6,7,0,1,2]) == 0
assert Solution().findMin([11,13,15,17]) == 11
assert Solution().findMin([2,3,5,6,7,1]) == 1
assert Solution().findMin([2,3,5,6,7,8,1]) == 1
assert Solution().findMin([6,7,8,1,2,3,4,5]) == 1
```

</div>

<div id="df1a8479-2991-41c3-8d65-5a5533523e26" class="cell markdown">

# 8.

Date: 12th Jan 2024<br> Medium Leetcode: count-and-say<br> Solution:
<https://leetcode.com/problems/count-and-say/submissions/1144310034/>

</div>

<div id="a005090c-c055-4f86-9958-5b18b6ebd019" class="cell code"
execution_count="11">

``` python
class Solution:
    def countAndSay(self, n: int) -> str:
        def say(s: str):
            prev = None
            count = 0
            result = []
            for ch in s + " ":
                if prev != ch:
                    if prev:
                        result.append(f"{count}{prev}")
                    prev, count = ch, 1
                else:
                    count += 1
                    
            return "".join(result)

        curr = "1" 
        while n > 1:
            curr = say(curr)
            n -= 1

        return curr

# Test the solution
assert Solution().countAndSay(10) == "13211311123113112211"
assert Solution().countAndSay(4) == "1211"
```

</div>

<div id="0ba2d5a4-1fff-476b-be53-038e1d827d7e" class="cell markdown">

# 9.

Date: 13th Jan 2024<br> Medium Leetcode:
minimum-number-of-steps-to-make-two-strings-anagram<br> Solution:
<https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/submissions/1144703174>

</div>

<div id="78ab7ab2-8fb1-4bb2-ba1d-cbee9f35a439" class="cell code"
execution_count="12">

``` python
class Solution:
    def minSteps(self, s: str, t: str) -> int:
        currentCounter = collections.Counter(s)
        targetCounter = collections.Counter(t)
        
        count = 0
        for k, v in currentCounter.items():
            count += max(v - targetCounter.get(k, 0), 0)
        
        return count
    
# Test the solution
assert Solution().minSteps("leetcode", "practice") == 5
assert Solution().minSteps("anagram", "mangaar") == 0
assert Solution().minSteps("bab", "aba") == 1
```

</div>

<div id="41847160-0cd4-4965-917a-4cb49e2702b3" class="cell markdown">

# 10.

Date: 13th Jan 2024<br> Medium Leetcode: longest-common-subsequence<br>
Solution:
<https://leetcode.com/problems/longest-common-subsequence/submissions/1144816986>

</div>

<div id="e04bc9c4-47ca-4c86-9c1e-21cb914e78f6" class="cell code"
execution_count="13">

``` python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        
        n1, n2 = len(text1), len(text2)

        def iterate() -> int:
            prev = [0 for _ in range(n1 + 1)]
            for i in range(n2 - 1, -1, -1):
                curr = [0 for _ in range(n1 + 1)]
                for j in range(n1 - 1, -1, -1):
                    if text1[j] == text2[i]:
                        curr[j] = 1 + prev[j + 1]
                    else:
                        curr[j] = max(prev[j], curr[j + 1])
                prev = curr
                        
            return curr[0]

        @functools.cache
        def backtrack(i: int, j: int) -> int:
            if i == n1 or j == n2:
                return 0
            elif text1[i] == text2[j]:
                return 1 + backtrack(i + 1, j + 1)
            else:
                return max(backtrack(i, j + 1), backtrack(i + 1, j))
        
        return iterate()

# Testing the solution
assert Solution().longestCommonSubsequence("abcded", "acede") == 4
assert Solution().longestCommonSubsequence("", "acede") == 0
```

</div>

<div id="d14e8431-df72-467b-ad3e-16dea850bf65" class="cell markdown">

# 11.

Date: 13th Jan 2024<br> Medium Leetcode: edit-distance<br> Solution:
<https://leetcode.com/problems/edit-distance/submissions/1145197901/>

</div>

<div id="1874e826-c82f-4507-8651-a6008fb1a856" class="cell code"
execution_count="14">

``` python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        """
        Remove / insert characters towards the end to match length
        Replace all characters with characters from word2
        Upper bound = max(n1, n2) - min(n1, n2) + n2

        # Optimized approach after watching 2 min of neetcode - watch tutorial
        """

        # Find the length of both the words
        n1, n2 = len(word1), len(word2) 

        @functools.cache
        def backtrack(i: int, j: int) -> int:
            if i >= n1 or j >= n2:
                return max(n1 - i, n2 - j)
            elif word1[i] == word2[j]:
                return backtrack(i + 1, j + 1)
            else:
                return 1 + min(
                    # Replace current char
                    backtrack(i + 1, j + 1),

                    # Remove current char
                    backtrack(i + 1, j),

                    # Insert char from target string
                    backtrack(i, j + 1)
                )
        
        answer = backtrack(0, 0)
        return answer

# Testing the solution
assert Solution().minDistance("horse", "ros") == 3
assert Solution().minDistance("intention", "execution") == 5
assert Solution().minDistance("mississippi", "missouri") == 6
assert Solution().minDistance("", "abcd") == 4
assert Solution().minDistance("abcd", "") == 4
assert Solution().minDistance("", "") == 0
```

</div>

<div id="b70d5893-6482-4547-95b7-105f9cde2902" class="cell markdown">

# 12.

Date: 14th Jan 2024<br> Medium Leetcode:
determine-if-two-strings-are-close<br> Solution:
<https://leetcode.com/problems/determine-if-two-strings-are-close/submissions/1145505023>

</div>

<div id="9d10fcea-4658-43a7-9b52-17d4f2935484" class="cell code"
execution_count="15">

``` python
class Solution:
    def closeStrings(self, word1: str, word2: str) -> bool:
        n1 = len(word1)
        n2 = len(word2) 

        if n1 != n2:
            return False
        
        else:
            counter1 = collections.Counter(word1)
            counter2 = collections.Counter(word2)
            freq_match = sorted(counter1.values()) == sorted(counter2.values())
            key_match = sorted(counter1.keys()) == sorted(counter2.keys())
            return freq_match and key_match

# Test the solution
assert Solution().closeStrings("abc", "bca") == True
assert Solution().closeStrings("a", "aa") == False
assert Solution().closeStrings("cabbba", "abbccc") == True
assert Solution().closeStrings("faddda", "dccaaa") == False
assert Solution().closeStrings("faddda", "dffaaa") == True
assert Solution().closeStrings("faddda", "dffdaa") == False
assert Solution().closeStrings("aaabbbbccddeeeeefffff", "aaaaabbcccdddeeeeffff") == False
```

</div>

<div id="bf1c9229-0df7-4ef7-8b7f-10b603ef784d" class="cell markdown">

# 13.

Date: 14th Jan 2024<br> Medium Leetcode:
find-beautiful-indices-in-the-given-array-i<br> Solution:
<https://leetcode.com/problems/find-beautiful-indices-in-the-given-array-i/submissions/1145567672/>

</div>

<div id="b2b4b9aa-622d-4e79-8620-511588e6c7a3" class="cell code"
execution_count="16">

``` python
class Solution:
    def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:
        result = []
        for i, ch in enumerate(s):
            if ch == a[0] and a == s[i: i + len(a)]:
                if b in s[max(i - k, 0): i + k + len(b)]:
                    result.append(i)
        
        return result

# Test the solution
assert Solution().beautifulIndices("abcd", "a", "b", 1) == [0]
assert Solution().beautifulIndices("abcd", "a", "cd", 1) == []
assert Solution().beautifulIndices("a", "a", "a", 1) == [0]
assert Solution().beautifulIndices("a", "a", "aa", 1) == []
assert Solution().beautifulIndices("vatevavakz", "va", "lbda", 1) == []
```

</div>

<div id="e3dc32da-5efe-48fe-b3e3-f37de99addd1" class="cell code">

``` python
```

</div>

<div id="c9e5bd6a-269e-4288-ad2c-3bb20a929706" class="cell code">

``` python
```

</div>

<div id="074bd7de-d765-4186-bf5b-51792f902568" class="cell code">

``` python
```

</div>

<div id="37d04fc7-1698-4a77-81c6-457040421ded" class="cell code">

``` python
```

</div>
