---
jupyter:
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
  language_info:
    codemirror_mode:
      name: ipython
      version: 3
    file_extension: .py
    mimetype: text/x-python
    name: python
    nbconvert_exporter: python
    pygments_lexer: ipython3
    version: 3.12.3
  nbformat: 4
  nbformat_minor: 5
  papermill:
    default_parameters: {}
    duration: 1.83509
    end_time: "2024-08-17T06:57:42.649848"
    environment_variables: {}
    input_path: practice/008.ipynb
    output_path: practice/008.ipynb
    parameters: {}
    start_time: "2024-08-17T06:57:40.814758"
    version: 2.6.0
---

<div id="8ff7cec0" class="cell code" execution_count="1"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-08-17T06:57:41.977258Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-08-17T06:57:41.976685Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-08-17T06:57:42.334461Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-08-17T06:57:42.333916Z&quot;}"
papermill="{&quot;duration&quot;:0.36303,&quot;end_time&quot;:&quot;2024-08-17T06:57:42.335926&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-08-17T06:57:41.972896&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
from typing import List, Optional, Generator
import typing
import pandas as pd
import numpy as np
import sqlite3
import re
import io
import math
import collections
import itertools
import functools
import random
import string
import tqdm
import bisect
import heapq
import operator

conn = sqlite3.connect(":memory:")

def regexp(expr, item):
    reg = re.compile(expr)
    return reg.search(item) is not None

def read_lc_df(s: str, dtypes: dict[str, str]=dict()) -> pd.DataFrame:
    temp = pd.read_csv(io.StringIO(s), sep="|", skiprows=2)
    temp = temp.iloc[1:-1, 1:-1]
    temp.columns = temp.columns.map(str.strip)
    temp = temp.map(lambda x: x if type(x) != str else None if x.strip() == 'null' else x.strip())
    temp = temp.astype(dtypes)
    return temp

conn.create_function("REGEXP", 2, regexp)
```

</div>

<div id="9b75edac" class="cell markdown"
papermill="{&quot;duration&quot;:1.988e-3,&quot;end_time&quot;:&quot;2024-08-17T06:57:42.340206&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-08-17T06:57:42.338218&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

#### Helper for Binary tree problems

</div>

<div id="d3f9effb" class="cell code" execution_count="2"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-08-17T06:57:42.345246Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-08-17T06:57:42.344715Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-08-17T06:57:42.350849Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-08-17T06:57:42.350383Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:9.934e-3,&quot;end_time&quot;:&quot;2024-08-17T06:57:42.351997&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-08-17T06:57:42.342063&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
class BinaryTreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

    def to_list(self):
        to_visit = [self]
        visited = []
        while len(to_visit) > 0:
            curr = to_visit.pop(0)
            if curr:
                to_visit.append(curr.left)
                to_visit.append(curr.right)
                visited.append(curr.val)
            else:
                visited.append(curr)

        while visited and not visited[-1]:
            visited.pop()

        return visited

    def __str__(self):
        return str(self.val)

    @staticmethod
    def from_array(nums: list[int|None]):
        '''Create a Tree from a list of nums. Returns the root node.'''
        if len(nums) == 0:
            return None
        elif len(nums) == 1:
            return BinaryTreeNode(nums[0])
        else:
            forest = [BinaryTreeNode(nums[0])]
            parent_idx = -1
            for i in range(1, len(nums)):

                curr = None
                if nums[i] is not None:
                    curr = BinaryTreeNode(nums[i])
                    forest.append(curr)

                if i % 2 == 1:
                    parent_idx += 1
                    forest[parent_idx].left = curr
                else:
                    forest[parent_idx].right = curr

        return forest[0]
```

</div>

<div id="0dc0f63e" class="cell markdown"
papermill="{&quot;duration&quot;:1.875e-3,&quot;end_time&quot;:&quot;2024-08-17T06:57:42.355766&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-08-17T06:57:42.353891&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

#### Helper for Singly Linked lists

</div>

<div id="c43bc790" class="cell code" execution_count="3"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-08-17T06:57:42.360801Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-08-17T06:57:42.360366Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-08-17T06:57:42.364648Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-08-17T06:57:42.364161Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:8.114e-3,&quot;end_time&quot;:&quot;2024-08-17T06:57:42.365800&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-08-17T06:57:42.357686&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

    def __str__(self):
        return str(self.val)

    @staticmethod
    def to_singly_linked_list(nums: list[int]):
        root = prev = None
        for n in nums:
            curr = ListNode(n)
            # Init once
            if not root:
                root = curr
            if prev:
                prev.next = curr
            prev = curr

        return root

    def to_list(self) -> list[int]:
        result = []
        curr = self
        while curr:
            result.append(curr.val)
            curr = curr.next
        return result
```

</div>

<div id="e514eda2" class="cell markdown"
papermill="{&quot;duration&quot;:1.917e-3,&quot;end_time&quot;:&quot;2024-08-17T06:57:42.369678&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-08-17T06:57:42.367761&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

CF Div 2 - 15th Aug 2024

</div>

<div id="ce489edd" class="cell code" execution_count="4"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-08-17T06:57:42.374463Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-08-17T06:57:42.374051Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-08-17T06:57:42.377586Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-08-17T06:57:42.377095Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:7.279e-3,&quot;end_time&quot;:&quot;2024-08-17T06:57:42.378810&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-08-17T06:57:42.371531&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def closest_point(N: int, points: list[int]) -> bool:
    return N == 2 and abs(points[0] - points[1]) > 1

# Testing the solution
assert closest_point(2, [3,8]) == True
assert closest_point(2, [5,6]) == False
assert closest_point(6, [1,2,3,4,5,10]) == False
```

</div>

<div id="8673e525" class="cell markdown"
papermill="{&quot;duration&quot;:1.938e-3,&quot;end_time&quot;:&quot;2024-08-17T06:57:42.382697&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-08-17T06:57:42.380759&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Upsolvng CF Contest - Div 2

</div>

<div id="7b5a343d" class="cell code" execution_count="5"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-08-17T06:57:42.387492Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-08-17T06:57:42.387131Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-08-17T06:57:42.391263Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-08-17T06:57:42.390811Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:7.748e-3,&quot;end_time&quot;:&quot;2024-08-17T06:57:42.392372&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-08-17T06:57:42.384624&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def game_with_doors(AL: int, AR: int, BL: int, BR: int) -> int:
    """
    For the overlapping portion, all doors must be closed
    For non overlapping portion, suffices to close just one door at each side
    """
    # Check for overlap
    oL, oR = max(AL, BL), min(AR, BR)
    if oL <= oR:
        locks = oR - oL
        if abs(AL - BL) > 0:
            locks += 1
        if abs(AR  - BR) > 0:
            locks += 1
        return locks
    else:
        return 1

# Testing the solution
assert game_with_doors(1, 2, 3, 4) == 1
assert game_with_doors(2, 5, 2, 5) == 3
assert game_with_doors(3, 7, 6, 7) == 2
assert game_with_doors(4, 5, 2, 8) == 3
```

</div>

<div id="0f33a487" class="cell code" execution_count="6"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-08-17T06:57:42.397312Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-08-17T06:57:42.396883Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-08-17T06:57:42.401290Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-08-17T06:57:42.400828Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:8.059e-3,&quot;end_time&quot;:&quot;2024-08-17T06:57:42.402405&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-08-17T06:57:42.394346&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def splitting_items(N: int, K: int, costs: list[int]) -> int:
    """
    * Playing optimally implies that
        - Alice tries to pick up the largest costing item available
        - Bob picks up the largest costing item available
        - Alice picks up items at odd indices, Bob at even indices (post sorting)
    * To minimize `A - B`, Bob should increase cost of items at even indices
    * We can update delta on the fly until K > 0
    """
    costs.sort()
    result = 0
    while costs:
        if len(costs) >= 2:
            delta = costs.pop() - costs.pop()
            if K < delta:
                result += delta - K
            K = max(0, K - delta)
        else:
            result += costs.pop()

    return result

# Testing the solution
assert splitting_items(3, 0, [10, 15, 12]) == 13
assert splitting_items(2, 5, [1, 10]) == 4
assert splitting_items(4, 6, [3, 1, 2, 4]) == 0
assert splitting_items(2, 4, [6, 9]) == 0
assert splitting_items(3, 1, [1, 1, 1]) == 1
```

</div>

<div id="a2923864" class="cell code" execution_count="7"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-08-17T06:57:42.407564Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-08-17T06:57:42.407148Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-08-17T06:57:42.415725Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-08-17T06:57:42.415237Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.318e-2,&quot;end_time&quot;:&quot;2024-08-17T06:57:42.417575&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-08-17T06:57:42.404395&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def colored_portals(N: int, Q: int, cities: list[str], queries: list[tuple[int, int]]) -> list[int]:
    """
    If cities of i, j share a common color, shortest path to reach would abs(i - j)
    Otherwise, we check for common colors between target:
        - If no common colors return -1
        - Elif if there exists a common point between i, j return abs(i - j)
        - Else search for points to left of i and right i with common portal and check both distances, return least of two (use binary search)
    """

    # Store to hashmap for quick lookup times
    portal_groups: collections.defaultdict[str, list] = collections.defaultdict(list)
    for i, portal_type in enumerate(cities):
        portal_groups[portal_type].append(i)

    # Process the queries
    results: list[int] = []
    for i, j in queries:
        i, j = i - 1, j - 1
        a, b, c, d = cities[i][0], cities[i][1], cities[j][0], cities[j][1]

        # All 4 distinct portals
        if len(set([a, b, c, d])) == 4:
            distance = math.inf
            for comb in [(a, c), (a, d), (b, c), (b, d)]:
                common = "".join(sorted(comb))
                idx = bisect.bisect(portal_groups[common], i)
                left, right = idx - 1, idx
                if 0 <= left < len(portal_groups[common]):
                    distance = min(distance, abs(portal_groups[common][left] - i) + abs(portal_groups[common][left] - j))

                if 0 <= right < len(portal_groups[common]):
                    distance = min(distance, abs(portal_groups[common][right] - i) + abs(portal_groups[common][right] - j))

            results.append(int(distance) if not math.isinf(distance) else -1)

        # Atleast one color in common
        else:
           results.append(abs(j - i))

    return results

# Testing the solution
assert colored_portals(6, 6, ["RY", "RY", "GY", "RY", "GB", "RY"], [(2,5), (4,5), (1,4), (4,1), (5,4), (5,2)]) == [3,3,3,3,3,3]
assert colored_portals(9, 3, ["RY", "RY", "BR", "BR", "BR", "BR", "GY", "GY", "RY"], [(3,7), (2,5), (6,7)]) == [6,3,5]
assert colored_portals(4, 5, ["BR","BR","GY","GR"], [(1,2), (3,1), (4,4), (1,4), (4,2)]) == [1,4,0,3,2]
```

</div>

<div id="cb4a0d4d" class="cell markdown"
papermill="{&quot;duration&quot;:1.926e-3,&quot;end_time&quot;:&quot;2024-08-17T06:57:42.422518&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-08-17T06:57:42.420592&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Find MEX of a set

</div>

<div id="3def0aea" class="cell code" execution_count="8"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-08-17T06:57:42.427829Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-08-17T06:57:42.427297Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-08-17T06:57:42.431095Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-08-17T06:57:42.430640Z&quot;}"
papermill="{&quot;duration&quot;:7.698e-3,&quot;end_time&quot;:&quot;2024-08-17T06:57:42.432209&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-08-17T06:57:42.424511&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def MEX(N: int, nums: list[int]) -> int:
    """
    There is a more optimized version for cases where nums are frequently updated.
    """
    xor = functools.reduce(operator.xor, nums, 0)
    missing = functools.reduce(operator.xor, range(N), xor)
    return missing

# Testing the solution
assert MEX(5, [0,2,3,4]) == 1
assert MEX(3, [1,2]) == 0
assert MEX(3, [2,0]) == 1
assert MEX(4, [2,0,1]) == 3
```

</div>
