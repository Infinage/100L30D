---
jupyter:
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
  language_info:
    codemirror_mode:
      name: ipython
      version: 3
    file_extension: .py
    mimetype: text/x-python
    name: python
    nbconvert_exporter: python
    pygments_lexer: ipython3
    version: 3.12.6
  nbformat: 4
  nbformat_minor: 5
  papermill:
    default_parameters: {}
    duration: 1.694516
    end_time: "2024-09-21T17:27:37.438629"
    environment_variables: {}
    input_path: practice/009.ipynb
    output_path: practice/009.ipynb
    parameters: {}
    start_time: "2024-09-21T17:27:35.744113"
    version: 2.6.0
---

<div id="8816b2e8" class="cell markdown"
papermill="{&quot;duration&quot;:4.854e-3,&quot;end_time&quot;:&quot;2024-09-21T17:27:36.911904&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-21T17:27:36.907050&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

#### Basic imports

</div>

<div id="b4a2ab2d" class="cell code" execution_count="1"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-21T17:27:36.921647Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-21T17:27:36.921104Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-21T17:27:36.925177Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-21T17:27:36.924618Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:9.829e-3,&quot;end_time&quot;:&quot;2024-09-21T17:27:36.926049&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-21T17:27:36.916220&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
import math
import heapq
import bisect
import collections
import itertools
import functools
import random
import typing
```

</div>

<div id="03c6208d" class="cell code" execution_count="2"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-21T17:27:36.935681Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-21T17:27:36.935131Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-21T17:27:36.939519Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-21T17:27:36.938945Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.0204e-2,&quot;end_time&quot;:&quot;2024-09-21T17:27:36.940402&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-21T17:27:36.930198&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def ssort(nums: list[int]) -> list[int]:
    "Select the smallest / largest from the list and push it to the end."
    N = len(nums)
    for i in range(N):
        min_ = i
        for j in range(i + 1, N):
            if nums[min_] > nums[j]:
                min_ = j
        nums[min_], nums[i] = nums[i], nums[min_]
    return nums

# Testing the solution
assert ssort([7,4,1,5,3]) == [1,3,4,5,7]
```

</div>

<div id="5666a6a3" class="cell code" execution_count="3"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-21T17:27:36.950015Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-21T17:27:36.949474Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-21T17:27:36.953826Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-21T17:27:36.953288Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.0145e-2,&quot;end_time&quot;:&quot;2024-09-21T17:27:36.954784&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-21T17:27:36.944639&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def bsort(nums: list[int]) -> list[int]:
    "Compare consecutive elements and bubble the larger number towards the end."
    N = len(nums)
    for j in range(N - 1, -1, -1):
        swapped = False
        for i in range(j):
            if nums[i] > nums[i + 1]:
                nums[i], nums[i + 1] = nums[i + 1], nums[i]
                swapped = True
        if not swapped:
            break
    return nums

# Testing the solution
assert bsort([7,4,1,5,3]) == [1,3,4,5,7]
```

</div>

<div id="db64fcf9" class="cell code" execution_count="4"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-21T17:27:36.964124Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-21T17:27:36.963602Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-21T17:27:36.967505Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-21T17:27:36.966988Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:9.426e-3,&quot;end_time&quot;:&quot;2024-09-21T17:27:36.968342&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-21T17:27:36.958916&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def isort(nums: list[int]) -> list[int]:
    "Take an element and place it at the correct order"
    N = len(nums)
    for i in range(1, N):
        curr, j = nums[i], i - 1
        while j >= 0 and nums[j] > curr:
            nums[j + 1] = nums[j]
            j -= 1
        nums[j + 1] = curr
    return nums

# Testing the solution
assert isort([5,4,3,2,1]) == [1,2,3,4,5]
```

</div>

<div id="0f2ee15b" class="cell code" execution_count="5"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-21T17:27:36.977346Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-21T17:27:36.976860Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-21T17:27:36.983546Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-21T17:27:36.982980Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.2184e-2,&quot;end_time&quot;:&quot;2024-09-21T17:27:36.984520&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-21T17:27:36.972336&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def qsort(nums: list[int]) -> list[int]:
    def partition(left: int, right: int, partition_idx: int) -> int:
        # Since we introduce a random pivot approach, we put it in a place
        # where our algorithm usually starts at
        nums[left], nums[partition_idx] = nums[partition_idx], nums[left]

        # Same steps
        pivot = nums[left]
        i = left + 1
        for j in range(left + 1, right + 1):
            if nums[j] < pivot:
                nums[i], nums[j] = nums[j], nums[i]
                i += 1

        nums[left], nums[i - 1] = nums[i - 1], nums[left]
        return i - 1

    def _qsort(start: int, end: int) -> None:
        if start < end:
            partition_idx = partition(start, end, random.randint(start, end))
            _qsort(start, partition_idx - 1)
            _qsort(partition_idx + 1, end)

    _qsort(0, len(nums) - 1)
    return nums

# Testing the solution
assert qsort([5,4,3,2,1]) == [1,2,3,4,5]
assert qsort([6,5,4,3,2,1]) == [1,2,3,4,5,6]
```

</div>

<div id="9fa5cda2" class="cell code" execution_count="6"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-21T17:27:36.994553Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-21T17:27:36.994000Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-21T17:27:36.999544Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-21T17:27:36.998942Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.1757e-2,&quot;end_time&quot;:&quot;2024-09-21T17:27:37.000476&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-21T17:27:36.988719&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def msort(nums: list[int]) -> list[int]:
    def _msort(left: int, right: int) -> None:
        if left < right:
            mid = (left + right) // 2

            # Very imp to split into (left, mid) and (mid + 1, right)
            # Try to do it other way (left, mid - 1), (mid, right) wouldn't work
            _msort(left, mid)
            _msort(mid + 1, right)

            # Merge the two sorted arrays
            temp: list[int] = []
            i, j = left, mid + 1
            while i <= mid or j <= right:
                if j > right or (i <= mid and nums[i] < nums[j]):
                    temp.append(nums[i])
                    i += 1
                else:
                    temp.append(nums[j])
                    j += 1

            # Reassign the sorted values back to original array
            nums[left: right + 1] = temp

    _msort(0, len(nums) - 1)
    return nums

# Testing the solution
assert msort([5,4,3,2,1]) == [1,2,3,4,5]
assert msort([6,5,4,3,2,1]) == [1,2,3,4,5,6]
```

</div>

<div id="bf753ad8" class="cell code" execution_count="7"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-21T17:27:37.010012Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-21T17:27:37.009450Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-21T17:27:37.013605Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-21T17:27:37.013163Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:9.83e-3,&quot;end_time&quot;:&quot;2024-09-21T17:27:37.014523&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-21T17:27:37.004693&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def secondLargestElement(nums: list[int]):
    "Largest - use min heap; Smallest - use max heap"
    heap: list[int] = []
    for n in set(nums):
        heapq.heappush(heap, n)
        if len(heap) > 2:
            heapq.heappop(heap)

    return heap[0] if len(heap) == 2 else -1

# Testing the solution
assert secondLargestElement([10,10,10,10,10]) == -1
assert secondLargestElement([8,8,7,6,5]) == 7
assert secondLargestElement([7,7,2,2,10,10,10]) == 7
```

</div>

<div id="649e052f" class="cell code" execution_count="8"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-21T17:27:37.024332Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-21T17:27:37.023753Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-21T17:27:37.028586Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-21T17:27:37.028124Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.0578e-2,&quot;end_time&quot;:&quot;2024-09-21T17:27:37.029522&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-21T17:27:37.018944&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def rotateArray(nums: list[int], K: int) -> list[int]:
    def reverse(start: int, end: int) -> None:
        while start < end:
            nums[start], nums[end] = nums[end], nums[start]
            start, end = start + 1, end - 1

    N = len(nums)
    K = K % N
    reverse(0, K - 1)
    reverse(K, N - 1)
    reverse(0, N - 1)
    return nums

# Testing the solution
assert rotateArray([1,2,3,4,5,6], 2) == [3,4,5,6,1,2]
assert rotateArray([3,4,1,5,3,-5], 8) == [1,5,3,-5,3,4]
assert rotateArray([1,2,3,4,5], 4) == [5,1,2,3,4]
```

</div>

<div id="60360c89" class="cell code" execution_count="9"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-21T17:27:37.038873Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-21T17:27:37.038351Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-21T17:27:37.041998Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-21T17:27:37.041448Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:9.034e-3,&quot;end_time&quot;:&quot;2024-09-21T17:27:37.042824&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-21T17:27:37.033790&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def moveZeros(nums: list[int]) -> None:
    # All index positions until i are filled with non zeros
    i = 0
    for j in range(len(nums)):
        if nums[j] != 0:
            nums[i] = nums[j]
            i += 1

    # Assign all left over positions as 0
    for j in range(i, len(nums)):
        nums[j] = 0
```

</div>

<div id="e23bf205" class="cell code" execution_count="10"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-21T17:27:37.051779Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-21T17:27:37.051324Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-21T17:27:37.054934Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-21T17:27:37.054397Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:9.026e-3,&quot;end_time&quot;:&quot;2024-09-21T17:27:37.055910&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-21T17:27:37.046884&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def removeDuplicates(nums: list[int]) -> None:
    # Two pointer approach
    i = 1
    for j in range(1, len(nums)):
        if nums[i - 1] != nums[j]:
            nums[i] = nums[j]
            i += 1

    # Assign left overs as 0
    for j in range(i, len(nums)):
        nums[j] = 0
```

</div>

<div id="3a3f2191" class="cell code" execution_count="11"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-21T17:27:37.065167Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-21T17:27:37.064983Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-21T17:27:37.071500Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-21T17:27:37.071059Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.2154e-2,&quot;end_time&quot;:&quot;2024-09-21T17:27:37.072336&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-21T17:27:37.060182&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def findSafeWalk(grid: list[list[int]], health: int) -> bool:
    M, N = len(grid), len(grid[0])
    costs: collections.defaultdict[tuple[int, int], int] = collections.defaultdict(lambda: 0)
    heap: list[tuple[int, tuple[int, int]]] = [(-health if grid[0][0] == 0 else -(health - 1), (0, 0))]
    while heap:
        curr_health, (x, y) = heapq.heappop(heap)
        curr_health = -curr_health
        for (x_, y_) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:
            if 0 <= x_ < M and 0 <= y_ < N:
                next_health = curr_health if grid[x_][y_] == 0 else curr_health - 1
                if next_health > costs[(x_, y_)]:
                    costs[(x_, y_)] = next_health
                    heapq.heappush(heap, (-next_health, (x_, y_)))

    return costs[(M - 1, N - 1)] > 0

# Testing the solution
assert findSafeWalk([[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]], 1) == True
assert findSafeWalk([[0,1,1,0,0,0],[1,0,1,0,0,0],[0,1,1,1,0,1],[0,0,1,0,1,0]], 3) == False
assert findSafeWalk([[1,1,1],[1,0,1],[1,1,1]], 5) == True
assert findSafeWalk([[1,1,1,1]], 4) == False
```

</div>

<div id="4620e621" class="cell code" execution_count="12"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-21T17:27:37.081605Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-21T17:27:37.081118Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-21T17:27:37.085401Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-21T17:27:37.084935Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:9.84e-3,&quot;end_time&quot;:&quot;2024-09-21T17:27:37.086337&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-21T17:27:37.076497&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def intersectionArray(nums1: list[int], nums2: list[int]) -> list[int]:
    i, j, N1, N2 = 0, 0, len(nums1), len(nums2)
    result: list[int] = []
    while i < N1 and j < N2:
        if nums1[i] == nums2[j]:
            result.append(nums1[i])
            i, j = i + 1, j + 1
        elif nums1[i] < nums2[j]:
            i += 1
        else:
            j += 1
    return result

# Testing the solution
assert intersectionArray([1,2,2,3,5], [1,2,7]) == [1,2]
assert intersectionArray([1,2,2,3], [4,5,7]) == []
```

</div>

<div id="6aace28f" class="cell code" execution_count="13"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-21T17:27:37.095867Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-21T17:27:37.095357Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-21T17:27:37.099854Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-21T17:27:37.099310Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.0221e-2,&quot;end_time&quot;:&quot;2024-09-21T17:27:37.100706&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-21T17:27:37.090485&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def leaders(nums: list[int]) -> list[int]:
    result: list[int] = []
    for i in range(len(nums) - 1, -1, -1):
        if not result or result[-1] < nums[i]:
            result.append(nums[i])
    result.reverse()
    return result

# Testing the solution
assert leaders([1,2,5,3,1,2]) == [5,3,2]
assert leaders([-3,4,5,1,-4,-5]) == [5,1,-4,-5]
assert leaders([-3,4,5,1,-30,-10]) == [5,1,-10]
```

</div>

<div id="1bc2207c" class="cell code" execution_count="14"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-21T17:27:37.109816Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-21T17:27:37.109363Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-21T17:27:37.115436Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-21T17:27:37.114993Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.147e-2,&quot;end_time&quot;:&quot;2024-09-21T17:27:37.116321&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-21T17:27:37.104851&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def spiralOrder(matrix: list[list[int]]) -> list[int]:
    i, j, M, N = 0, 0, len(matrix), len(matrix[0])
    result: list[int] = []
    for layer in range(math.ceil(min(M / 2, N / 2))):
        x, y = layer, layer
        result.append(matrix[x][y])

        # Go right
        travelled_right = False
        while y + 1 < N - layer:
            y += 1
            result.append(matrix[x][y])
            travelled_right = True

        # Go down
        travelled_down = False
        while x + 1 < M - layer:
            x += 1
            result.append(matrix[x][y])
            travelled_down = True

        # Go left
        travelled_left = False
        while travelled_down and y - 1 >= layer:
            y -= 1
            result.append(matrix[x][y])
            travelled_left = True

        # Go up
        travelled_up = False
        while travelled_left and x - 1 > layer:
            x -= 1
            result.append(matrix[x][y])
            travelled_up = True

    return result

# Testing the solution
assert spiralOrder([[1, 2, 3], [4 ,5 ,6], [7, 8, 9]]) == [1, 2, 3, 6, 9, 8, 7, 4, 5]
assert spiralOrder([[1, 2, 3, 4], [5, 6, 7, 8]]) == [1, 2, 3, 4, 8, 7, 6, 5]
assert spiralOrder([[1, 2], [3, 4], [5, 6], [7, 8]]) == [1, 2, 4, 6, 8, 7, 5, 3]
```

</div>

<div id="b1638de8" class="cell code" execution_count="15"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-21T17:27:37.125319Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-21T17:27:37.125135Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-21T17:27:37.129784Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-21T17:27:37.129322Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.0232e-2,&quot;end_time&quot;:&quot;2024-09-21T17:27:37.130766&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-21T17:27:37.120534&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def rearrangeArray(nums: list[int]) -> list[int]:
    # Split and obtain the nums into two diff arrays
    pos: collections.deque[int] = collections.deque([])
    neg: collections.deque[int] = collections.deque([])
    for n in nums:
        if n < 0:
            neg.append(n)
        else:
            pos.append(n)

    # Pos first, neg next preserving original order
    result: list[int] = []
    for i in range(len(nums) // 2):
        result.append(pos.popleft())
        result.append(neg.popleft())

    return result

# Testing the solution
assert rearrangeArray([1,-1,-3,-4,2,3]) == [1,-1,2,-3,3,-4]
assert rearrangeArray([-4,4,-4,4,-4,4]) == [4,-4,4,-4,4,-4]
```

</div>

<div id="72cfac21" class="cell code" execution_count="16"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-21T17:27:37.140031Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-21T17:27:37.139525Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-21T17:27:37.143718Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-21T17:27:37.143166Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:9.729e-3,&quot;end_time&quot;:&quot;2024-09-21T17:27:37.144603&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-21T17:27:37.134874&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def pascalTriangle(numRows: int) -> list[list[int]]:
    result: list[list[int]] = [[1]]
    for i in range(1, numRows):
        result.append([1])
        for j in range(i - 1):
            result[-1].append(result[-2][j] + result[-2][j + 1])
        result[-1].append(1)

    return result

# Testing the solution
assert pascalTriangle(5) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]
```

</div>

<div id="ab1590e1" class="cell code" execution_count="17"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-21T17:27:37.154007Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-21T17:27:37.153509Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-21T17:27:37.158800Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-21T17:27:37.158360Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.0927e-2,&quot;end_time&quot;:&quot;2024-09-21T17:27:37.159706&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-21T17:27:37.148779&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def rotateMatrix(matrix: list[list[int]]) -> list[list[int]]:
    """
    Similar to rotating an array by k places, this could be acheived
    by transposing the matrix first and then reversing the rows
    """
    N = len(matrix)

    # Transpose the matrix
    for i in range(N):
        for j in range(i + 1, N):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]

    # Reverse the rows
    for i in range(N):
        matrix[i].reverse()

    return matrix

# Testing the solution
assert rotateMatrix([[1,2,3], [4,5,6], [7,8,9]]) == [[7,4,1], [8,5,2], [9,6,3]]
assert rotateMatrix([[0,1,1,2], [2,0,3,1], [4,5,0,5], [5,6,7,0]]) == [[5,4,2,0], [6,5,0,1], [7,0,3,1], [0,5,1,2]]
assert rotateMatrix([[1,1,2], [5,3,1], [5,3,5]]) == [[5,5,1], [3,3,1], [5,1,2]]
```

</div>

<div id="3e260a7c" class="cell code" execution_count="18"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-21T17:27:37.168387Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-21T17:27:37.168207Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-21T17:27:37.173134Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-21T17:27:37.172579Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.0288e-2,&quot;end_time&quot;:&quot;2024-09-21T17:27:37.174016&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-21T17:27:37.163728&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def twoSum(nums: list[int], target: int) -> tuple[int, int]:
    N = len(nums)
    nums_: list[tuple[int, int]] = sorted(enumerate(nums), key=lambda x: x[1])
    i, j = 0, N - 1
    while i < j:
        curr = nums_[i][1] + nums_[j][1]
        pair = sorted([nums_[i][0], nums_[j][0]])
        if curr == target:
            return pair[0], pair[1]
        elif curr < target:
            i += 1
        else:
            j -= 1

    return -1, -1

# Testing the solution
assert twoSum([1,6,2,10,3], 7) == (0,1)
assert twoSum([1,3,5,-7,6,-3], 0) == (1,5)
assert twoSum([-6,7,1,-7,6,2], 3) == (2,5)
```

</div>

<div id="70e0ad16" class="cell code" execution_count="19"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-21T17:27:37.182864Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-21T17:27:37.182684Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-21T17:27:37.187722Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-21T17:27:37.187267Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.037e-2,&quot;end_time&quot;:&quot;2024-09-21T17:27:37.188532&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-21T17:27:37.178162&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def threeSum(nums: list[int]) -> set[tuple[int, int, int]]:
    N = len(nums)
    nums.sort()
    results: set[tuple[int, int, int]] = set()
    for i in range(N - 2):
        j, k = i + 1, N - 1
        while j < k:
            curr = nums[i] + nums[j] + nums[k]
            triplet = sorted([nums[i], nums[j], nums[k]])
            if curr == 0:
                results.add((triplet[0], triplet[1], triplet[2]))
                j, k = j + 1, k - 1
            elif curr > 0:
                k -= 1
            else:
                j += 1

    return results

# Testing the solution
assert threeSum([2, -2, 0, 3, -3, 5]) == {(-3, -2, 5), (-3, 0, 3), (-2, 0, 2)}
assert threeSum([2, -1, -1, 3, -1]) == {(-1, -1, 2)}
```

</div>

<div id="2696f7e0" class="cell code" execution_count="20"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-21T17:27:37.197284Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-21T17:27:37.197110Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-21T17:27:37.202582Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-21T17:27:37.202133Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.0832e-2,&quot;end_time&quot;:&quot;2024-09-21T17:27:37.203426&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-21T17:27:37.192594&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def fourSum(nums: list[int], target: int) -> set[tuple[int, int, int, int]]:
    """
    Iterate all combinations of i, j
    For each such combination deploy the two pointer approach
    """
    N = len(nums)
    nums.sort()
    results: set[tuple[int, int, int, int]] = set()
    for i in range(N - 3):
        for j in range(i + 1, N - 2):
            k, l = j + 1, N - 1
            while k < l:
                quad: list[int] = sorted([nums[i], nums[j], nums[k], nums[l]])
                total = nums[i] + nums[j] + nums[k] + nums[l]
                if total == target:
                    results.add((quad[0], quad[1], quad[2], quad[3]))
                    k, l = k + 1, l - 1
                elif total > target:
                    l -= 1
                else:
                    k += 1

    return results

# Testing the solution
assert fourSum([1,-2,3,5,7,9], 7) == {(-2,1,3,5)}
assert fourSum([7,-7,1,2,14,3], 9) == set()
assert fourSum([1,1,3,4,-3], 5) == {(-3,1,3,4)}
```

</div>

<div id="e460ed7b" class="cell code" execution_count="21"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-21T17:27:37.212352Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-21T17:27:37.212177Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-21T17:27:37.216531Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-21T17:27:37.216078Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:9.716e-3,&quot;end_time&quot;:&quot;2024-09-21T17:27:37.217372&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-21T17:27:37.207656&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def sortZeroOneTwo(nums: list[int]) -> list[int]:
    """
    Variation of Dutch National flag algorithm
    A much more intuitive algorithm is bucket sort

    DNF:
    Assume nums from [0, low], [high, N-1] are sorted.
    Numbers between (low, high) are unsorted
    """
    N = len(nums)
    low, mid, high = 0, 0, N - 1
    while mid <= high:
        # Correct position
        if nums[mid] == 1:
            mid += 1

        # Incorrect
        elif nums[mid] == 0:
            nums[low], nums[mid] = nums[mid], nums[low]
            low, mid = low + 1, mid + 1
        else:
            nums[high], nums[mid] = nums[mid], nums[high]
            high -= 1

    return nums

# Testing the solution
assert sortZeroOneTwo([0,0,1,2,0,1,2,2,1,0]) == [0,0,0,0,1,1,1,2,2,2]
```

</div>

<div id="5e1e76e9" class="cell code" execution_count="22"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-21T17:27:37.226769Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-21T17:27:37.226323Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-21T17:27:37.230429Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-21T17:27:37.229982Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:9.654e-3,&quot;end_time&quot;:&quot;2024-09-21T17:27:37.231287&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-21T17:27:37.221633&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def maxSubArray(nums: list[int]) -> int:
    """
    Kadane's algorithm
    If at any pt total becomes less than 0, reset it
    """
    max_, total = nums[0], 0
    for n in nums:
        total += n
        max_ = max(max_, total)
        if total < 0:
            total = 0
    return max_

# Testing the solution
assert maxSubArray([2, 3, 5, -2, 7, -4]) == 15
assert maxSubArray([-2, -3, -7, -2, -10, -4]) == -2
assert maxSubArray([-1, 2, 3, -1, 2, -6, 5]) == 6
```

</div>

<div id="028c7163" class="cell code" execution_count="23"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-21T17:27:37.241552Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-21T17:27:37.241105Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-21T17:27:37.245602Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-21T17:27:37.245062Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.1043e-2,&quot;end_time&quot;:&quot;2024-09-21T17:27:37.246469&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-21T17:27:37.235426&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def majorityElement(nums: list[int]) -> int:
    """
    Logic: Assume a number is the majority element, everytime we encounter num in nums that equals
    our curr we increment count by 1 else decrement count by 1.

    Continue doing until we have reached the end of the array
    """
    result: int|None = None
    freq: int = 0
    for n in nums:
        if not result:
            result, freq = n, 1
        elif n == result:
            freq += 1
        else:
            freq -= 1

        if freq == 0:
            result = None

    return result if result else 0

# Testing the solution
assert majorityElement([7, 0, 0, 1, 7, 7, 2, 7, 7]) == 7
assert majorityElement([1, 1, 1, 2, 1, 2]) == 1
assert majorityElement([-1, -1, -1, -1]) == -1
```

</div>

<div id="9ec51a9d" class="cell code" execution_count="24"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-21T17:27:37.255632Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-21T17:27:37.255282Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-21T17:27:37.260670Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-21T17:27:37.260240Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.087e-2,&quot;end_time&quot;:&quot;2024-09-21T17:27:37.261531&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-21T17:27:37.250661&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def majorityElementTwo(nums: list[int]) -> list[int]:
    """
    Same as prev question but we have two slots now.
    """
    N = len(nums)
    n1, f1, n2, f2 = 0, 0, 0, 0
    for n in nums:
        if f1 == 0 and n != n2:
            n1, f1 = n, 1
        elif f2 == 0 and n != n1:
            n2, f2 = n, 1
        elif n == n1:
            f1 += 1
        elif n == n2:
            f2 += 1
        else:
            f1, f2 = f1 - 1, f2 - 1

    # Double check to ensure that the majority
    # elements are occuring more than N // 3 times
    freq: dict[int, int] = dict()
    for n in nums:
        if n in (n1, n2):
            freq[n] = freq.get(n, 0) + 1

    return [n for n in (n1, n2) if freq.get(n, 0) > N // 3]

# Testing the solution
assert majorityElementTwo([1,1,1,1]) == [1]
assert majorityElementTwo([1,2,1,1,3,2,2]) == [1,2]
assert majorityElementTwo([1,2,1,1,3,2]) == [1]
assert majorityElementTwo([1,2,1,1,3,2,2,3]) == [1,2]
assert majorityElementTwo([1,1,2,2,3,3,4,4,5,5]) == []
```

</div>

<div id="2abcdcfe" class="cell code" execution_count="25"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-21T17:27:37.270661Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-21T17:27:37.270312Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-21T17:27:37.275693Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-21T17:27:37.275236Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.0779e-2,&quot;end_time&quot;:&quot;2024-09-21T17:27:37.276539&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-21T17:27:37.265760&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def numberOfInversions(nums: list[int]) -> int:
    def modified_mergesort(low: int, high: int) -> int:
        if low >= high:
            return 0

        else:
            # Merge sort left and right
            mid = (low + high) // 2
            cnt_left = modified_mergesort(low, mid)
            cnt_right = modified_mergesort(mid + 1, high)

            # Create temp array for storing in order
            temp: list[int] = []
            cnt, i, j = 0, low, mid + 1
            while i <= mid or j <= high:
                if j > high or (i <= mid and nums[i] <= nums[j]):
                    temp.append(nums[i])
                    i += 1
                else:
                    temp.append(nums[j])
                    j += 1

                    # We are inserting from the right portion
                    # Simply count how many elements we have
                    # left in the 'left' array
                    cnt += mid - i + 1

            # Copy from temp back to array
            for i in range(low, high + 1):
                nums[i] = temp[i - low]

            return cnt_left + cnt_right + cnt

    inversions = modified_mergesort(0, len(nums) - 1)
    return inversions

assert numberOfInversions([2, 3, 7, 1, 3, 5]) == 5
assert numberOfInversions([-10, -5, 6, 11, 15, 17]) == 0
assert numberOfInversions([9, 5, 4, 2]) == 6
```

</div>

<div id="9c0a8830" class="cell code" execution_count="26"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-21T17:27:37.285411Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-21T17:27:37.285232Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-21T17:27:37.290580Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-21T17:27:37.290132Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.074e-2,&quot;end_time&quot;:&quot;2024-09-21T17:27:37.291429&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-21T17:27:37.280689&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def reversePairs(nums: list[int]) -> int:
    N = len(nums)
    def modified_mergesort(left: int, right: int) -> int:
        if left >= right:
            return 0
        else:
            mid = (left + right) // 2
            left_rev_count = modified_mergesort(left, mid)
            right_rev_count = modified_mergesort(mid + 1, right)

            # Merge the two sorted portions together
            rev_count, i, j = 0, left, mid + 1
            temp: list[int] = []
            while i <= mid or j <= right:
                if j > right or (i <= mid and nums[i] <= nums[j]):
                    temp.append(nums[i])
                    i += 1
                else:
                    temp.append(nums[j])
                    rev_count += mid + 1 - bisect.bisect(nums, 2 * nums[j], left, mid + 1)
                    j += 1

            # Join back into nums in correct order
            for i in range(left, right + 1):
                nums[i] = temp[i - left]

            return left_rev_count + right_rev_count + rev_count

    return modified_mergesort(0, N - 1)

# Testing the solution
assert reversePairs([6, 4, 1, 2, 7]) == 3
assert reversePairs([5, 4, 4, 3, 3]) == 0
assert reversePairs([6, 4, 4, 2, 2]) == 2
```

</div>

<div id="710b07ce" class="cell code" execution_count="27"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-21T17:27:37.300359Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-21T17:27:37.300185Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-21T17:27:37.304661Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-21T17:27:37.304203Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:9.898e-3,&quot;end_time&quot;:&quot;2024-09-21T17:27:37.305556&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-21T17:27:37.295658&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def maxProduct(nums: list[int]) -> int:
    """
    If no negatives or even number of negatives, ans is the product of all
    If odd negatives we need to pick either the suffix product or the prefix product

    Iterate Left to right and then from right to left
    If n == 0, reset acc = 1
    Else acc *= n; max(result, acc)
    """
    N = len(nums)
    result, acc = nums[0], 1
    for i in range(N):
        acc *= nums[i]
        result = max(acc, result)
        if acc == 0:
            acc = 1

    acc = 1
    for i in range(N - 1, -1, -1):
        acc *= nums[i]
        result = max(acc, result)
        if acc == 0:
            acc = 1

    return result

# Testing the solution
assert maxProduct([4, 5, 3, 7, 1, 2]) == 840
assert maxProduct([-5, 0, -2]) == 0
assert maxProduct([1, -2, 3, 4, -4, -3]) == 144
```

</div>

<div id="013e8ce3" class="cell code" execution_count="28"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-21T17:27:37.314746Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-21T17:27:37.314408Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-21T17:27:37.318376Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-21T17:27:37.317914Z&quot;}"
papermill="{&quot;duration&quot;:9.492e-3,&quot;end_time&quot;:&quot;2024-09-21T17:27:37.319238&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-21T17:27:37.309746&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def merge(nums1: list[int], M: int, nums2: list[int], N: int) -> None:
    # Shift nums1 to the right
    i, j = M - 1, M + N - 1
    while i >= 0:
        nums1[j] = nums1[i]
        i, j = i - 1, j - 1

    # Do the usual merging that we do during merge sort
    i, j, head = N, 0, 0
    while i < M + N or j < N:
        if j >= N or (i < M + N and nums1[i] <= nums2[j]):
            nums1[head] = nums1[i]
            i, head = i + 1, head + 1
        else:
            nums1[head] = nums2[j]
            head, j = head + 1, j + 1
```

</div>
