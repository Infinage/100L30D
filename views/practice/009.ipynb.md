---
jupyter:
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
  language_info:
    codemirror_mode:
      name: ipython
      version: 3
    file_extension: .py
    mimetype: text/x-python
    name: python
    nbconvert_exporter: python
    pygments_lexer: ipython3
    version: 3.12.6
  nbformat: 4
  nbformat_minor: 5
  papermill:
    default_parameters: {}
    duration: 1.629113
    end_time: "2024-09-18T16:52:49.535291"
    environment_variables: {}
    input_path: practice/009.ipynb
    output_path: practice/009.ipynb
    parameters: {}
    start_time: "2024-09-18T16:52:47.906178"
    version: 2.6.0
---

<div id="8816b2e8" class="cell markdown"
papermill="{&quot;duration&quot;:4.531e-3,&quot;end_time&quot;:&quot;2024-09-18T16:52:49.073840&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-18T16:52:49.069309&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

#### Basic imports

</div>

<div id="b4a2ab2d" class="cell code" execution_count="1"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-18T16:52:49.082712Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-18T16:52:49.082282Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-18T16:52:49.086214Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-18T16:52:49.085667Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:9.364e-3,&quot;end_time&quot;:&quot;2024-09-18T16:52:49.087177&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-18T16:52:49.077813&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
import math
import heapq
import bisect
import collections
import itertools
import functools
import random
import typing
```

</div>

<div id="03c6208d" class="cell code" execution_count="2"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-18T16:52:49.095784Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-18T16:52:49.095271Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-18T16:52:49.099314Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-18T16:52:49.098885Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:9.139e-3,&quot;end_time&quot;:&quot;2024-09-18T16:52:49.100178&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-18T16:52:49.091039&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def ssort(nums: list[int]) -> list[int]:
    "Select the smallest / largest from the list and push it to the end."
    N = len(nums)
    for i in range(N):
        min_ = i
        for j in range(i + 1, N):
            if nums[min_] > nums[j]:
                min_ = j
        nums[min_], nums[i] = nums[i], nums[min_]
    return nums

# Testing the solution
assert ssort([7,4,1,5,3]) == [1,3,4,5,7]
```

</div>

<div id="5666a6a3" class="cell code" execution_count="3"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-18T16:52:49.108681Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-18T16:52:49.108200Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-18T16:52:49.112398Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-18T16:52:49.111933Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:9.334e-3,&quot;end_time&quot;:&quot;2024-09-18T16:52:49.113258&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-18T16:52:49.103924&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def bsort(nums: list[int]) -> list[int]:
    "Compare consecutive elements and bubble the larger number towards the end."
    N = len(nums)
    for j in range(N - 1, -1, -1):
        swapped = False
        for i in range(j):
            if nums[i] > nums[i + 1]:
                nums[i], nums[i + 1] = nums[i + 1], nums[i]
                swapped = True
        if not swapped:
            break
    return nums

# Testing the solution
assert bsort([7,4,1,5,3]) == [1,3,4,5,7]
```

</div>

<div id="db64fcf9" class="cell code" execution_count="4"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-18T16:52:49.121944Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-18T16:52:49.121419Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-18T16:52:49.125254Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-18T16:52:49.124749Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:9.184e-3,&quot;end_time&quot;:&quot;2024-09-18T16:52:49.126213&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-18T16:52:49.117029&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def isort(nums: list[int]) -> list[int]:
    "Take an element and place it at the correct order"
    N = len(nums)
    for i in range(1, N):
        curr, j = nums[i], i - 1
        while j >= 0 and nums[j] > curr:
            nums[j + 1] = nums[j]
            j -= 1
        nums[j + 1] = curr
    return nums

# Testing the solution
assert isort([5,4,3,2,1]) == [1,2,3,4,5]
```

</div>

<div id="0f2ee15b" class="cell code" execution_count="5"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-18T16:52:49.134411Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-18T16:52:49.133952Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-18T16:52:49.140530Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-18T16:52:49.139952Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.1475e-2,&quot;end_time&quot;:&quot;2024-09-18T16:52:49.141357&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-18T16:52:49.129882&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def qsort(nums: list[int]) -> list[int]:
    def partition(left: int, right: int, partition_idx: int) -> int:
        # Since we introduce a random pivot approach, we put it in a place
        # where our algorithm usually starts at
        nums[left], nums[partition_idx] = nums[partition_idx], nums[left]

        # Same steps
        pivot = nums[left]
        i = left + 1
        for j in range(left + 1, right + 1):
            if nums[j] < pivot:
                nums[i], nums[j] = nums[j], nums[i]
                i += 1

        nums[left], nums[i - 1] = nums[i - 1], nums[left]
        return i - 1

    def _qsort(start: int, end: int) -> None:
        if start < end:
            partition_idx = partition(start, end, random.randint(start, end))
            _qsort(start, partition_idx - 1)
            _qsort(partition_idx + 1, end)

    _qsort(0, len(nums) - 1)
    return nums

# Testing the solution
assert qsort([5,4,3,2,1]) == [1,2,3,4,5]
assert qsort([6,5,4,3,2,1]) == [1,2,3,4,5,6]
```

</div>

<div id="9fa5cda2" class="cell code" execution_count="6"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-18T16:52:49.149622Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-18T16:52:49.149150Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-18T16:52:49.154183Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-18T16:52:49.153699Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.0034e-2,&quot;end_time&quot;:&quot;2024-09-18T16:52:49.155017&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-18T16:52:49.144983&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def msort(nums: list[int]) -> list[int]:
    def _msort(left: int, right: int) -> None:
        if left < right:
            mid = (left + right) // 2

            # Very imp to split into (left, mid) and (mid + 1, right)
            # Try to do it other way (left, mid - 1), (mid, right) wouldn't work
            _msort(left, mid)
            _msort(mid + 1, right)

            # Merge the two sorted arrays
            temp: list[int] = []
            i, j = left, mid + 1
            while i <= mid or j <= right:
                if j > right or (i <= mid and nums[i] < nums[j]):
                    temp.append(nums[i])
                    i += 1
                else:
                    temp.append(nums[j])
                    j += 1

            # Reassign the sorted values back to original array
            nums[left: right + 1] = temp

    _msort(0, len(nums) - 1)
    return nums

# Testing the solution
assert msort([5,4,3,2,1]) == [1,2,3,4,5]
assert msort([6,5,4,3,2,1]) == [1,2,3,4,5,6]
```

</div>

<div id="bf753ad8" class="cell code" execution_count="7"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-18T16:52:49.163551Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-18T16:52:49.163063Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-18T16:52:49.167118Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-18T16:52:49.166599Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:9.098e-3,&quot;end_time&quot;:&quot;2024-09-18T16:52:49.168044&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-18T16:52:49.158946&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def secondLargestElement(nums: list[int]):
    "Largest - use min heap; Smallest - use max heap"
    heap: list[int] = []
    for n in set(nums):
        heapq.heappush(heap, n)
        if len(heap) > 2:
            heapq.heappop(heap)

    return heap[0] if len(heap) == 2 else -1

# Testing the solution
assert secondLargestElement([10,10,10,10,10]) == -1
assert secondLargestElement([8,8,7,6,5]) == 7
assert secondLargestElement([7,7,2,2,10,10,10]) == 7
```

</div>

<div id="649e052f" class="cell code" execution_count="8"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-18T16:52:49.176259Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-18T16:52:49.175754Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-18T16:52:49.180454Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-18T16:52:49.180002Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:9.578e-3,&quot;end_time&quot;:&quot;2024-09-18T16:52:49.181284&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-18T16:52:49.171706&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def rotateArray(nums: list[int], K: int) -> list[int]:
    def reverse(start: int, end: int) -> None:
        while start < end:
            nums[start], nums[end] = nums[end], nums[start]
            start, end = start + 1, end - 1

    N = len(nums)
    K = K % N
    reverse(0, K - 1)
    reverse(K, N - 1)
    reverse(0, N - 1)
    return nums

# Testing the solution
assert rotateArray([1,2,3,4,5,6], 2) == [3,4,5,6,1,2]
assert rotateArray([3,4,1,5,3,-5], 8) == [1,5,3,-5,3,4]
assert rotateArray([1,2,3,4,5], 4) == [5,1,2,3,4]
```

</div>

<div id="60360c89" class="cell code" execution_count="9"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-18T16:52:49.190541Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-18T16:52:49.189988Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-18T16:52:49.193630Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-18T16:52:49.193185Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:9.437e-3,&quot;end_time&quot;:&quot;2024-09-18T16:52:49.194483&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-18T16:52:49.185046&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def moveZeros(nums: list[int]) -> None:
    # All index positions until i are filled with non zeros
    i = 0
    for j in range(len(nums)):
        if nums[j] != 0:
            nums[i] = nums[j]
            i += 1

    # Assign all left over positions as 0
    for j in range(i, len(nums)):
        nums[j] = 0
```

</div>

<div id="e23bf205" class="cell code" execution_count="10"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-18T16:52:49.202835Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-18T16:52:49.202324Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-18T16:52:49.205806Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-18T16:52:49.205255Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:8.595e-3,&quot;end_time&quot;:&quot;2024-09-18T16:52:49.206671&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-18T16:52:49.198076&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def removeDuplicates(nums: list[int]) -> None:
    # Two pointer approach
    i = 1
    for j in range(1, len(nums)):
        if nums[i - 1] != nums[j]:
            nums[i] = nums[j]
            i += 1

    # Assign left overs as 0
    for j in range(i, len(nums)):
        nums[j] = 0
```

</div>

<div id="3a3f2191" class="cell code" execution_count="11"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-18T16:52:49.215033Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-18T16:52:49.214550Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-18T16:52:49.221616Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-18T16:52:49.221096Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.2112e-2,&quot;end_time&quot;:&quot;2024-09-18T16:52:49.222444&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-18T16:52:49.210332&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def findSafeWalk(grid: list[list[int]], health: int) -> bool:
    M, N = len(grid), len(grid[0])
    costs: collections.defaultdict[tuple[int, int], int] = collections.defaultdict(lambda: 0)
    heap: list[tuple[int, tuple[int, int]]] = [(-health if grid[0][0] == 0 else -(health - 1), (0, 0))]
    while heap:
        curr_health, (x, y) = heapq.heappop(heap)
        curr_health = -curr_health
        for (x_, y_) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:
            if 0 <= x_ < M and 0 <= y_ < N:
                next_health = curr_health if grid[x_][y_] == 0 else curr_health - 1
                if next_health > costs[(x_, y_)]:
                    costs[(x_, y_)] = next_health
                    heapq.heappush(heap, (-next_health, (x_, y_)))

    return costs[(M - 1, N - 1)] > 0

# Testing the solution
assert findSafeWalk([[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]], 1) == True
assert findSafeWalk([[0,1,1,0,0,0],[1,0,1,0,0,0],[0,1,1,1,0,1],[0,0,1,0,1,0]], 3) == False
assert findSafeWalk([[1,1,1],[1,0,1],[1,1,1]], 5) == True
assert findSafeWalk([[1,1,1,1]], 4) == False
```

</div>

<div id="4620e621" class="cell code" execution_count="12"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-18T16:52:49.230726Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-18T16:52:49.230245Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-18T16:52:49.234454Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-18T16:52:49.233936Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:9.281e-3,&quot;end_time&quot;:&quot;2024-09-18T16:52:49.235392&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-18T16:52:49.226111&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def intersectionArray(nums1: list[int], nums2: list[int]) -> list[int]:
    i, j, N1, N2 = 0, 0, len(nums1), len(nums2)
    result: list[int] = []
    while i < N1 and j < N2:
        if nums1[i] == nums2[j]:
            result.append(nums1[i])
            i, j = i + 1, j + 1
        elif nums1[i] < nums2[j]:
            i += 1
        else:
            j += 1
    return result

# Testing the solution
assert intersectionArray([1,2,2,3,5], [1,2,7]) == [1,2]
assert intersectionArray([1,2,2,3], [4,5,7]) == []
```

</div>

<div id="6aace28f" class="cell code" execution_count="13"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-18T16:52:49.243676Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-18T16:52:49.243220Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-18T16:52:49.247335Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-18T16:52:49.246916Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:9.138e-3,&quot;end_time&quot;:&quot;2024-09-18T16:52:49.248196&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-18T16:52:49.239058&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def leaders(nums: list[int]) -> list[int]:
    result: list[int] = []
    for i in range(len(nums) - 1, -1, -1):
        if not result or result[-1] < nums[i]:
            result.append(nums[i])
    result.reverse()
    return result

# Testing the solution
assert leaders([1,2,5,3,1,2]) == [5,3,2]
assert leaders([-3,4,5,1,-4,-5]) == [5,1,-4,-5]
assert leaders([-3,4,5,1,-30,-10]) == [5,1,-10]
```

</div>

<div id="1bc2207c" class="cell code" execution_count="14"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-18T16:52:49.256562Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-18T16:52:49.255988Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-18T16:52:49.262351Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-18T16:52:49.261890Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.131e-2,&quot;end_time&quot;:&quot;2024-09-18T16:52:49.263154&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-18T16:52:49.251844&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def spiralOrder(matrix: list[list[int]]) -> list[int]:
    i, j, M, N = 0, 0, len(matrix), len(matrix[0])
    result: list[int] = []
    for layer in range(math.ceil(min(M / 2, N / 2))):
        x, y = layer, layer
        result.append(matrix[x][y])

        # Go right
        travelled_right = False
        while y + 1 < N - layer:
            y += 1
            result.append(matrix[x][y])
            travelled_right = True

        # Go down
        travelled_down = False
        while x + 1 < M - layer:
            x += 1
            result.append(matrix[x][y])
            travelled_down = True

        # Go left
        travelled_left = False
        while travelled_down and y - 1 >= layer:
            y -= 1
            result.append(matrix[x][y])
            travelled_left = True

        # Go up
        travelled_up = False
        while travelled_left and x - 1 > layer:
            x -= 1
            result.append(matrix[x][y])
            travelled_up = True

    return result

# Testing the solution
assert spiralOrder([[1, 2, 3], [4 ,5 ,6], [7, 8, 9]]) == [1, 2, 3, 6, 9, 8, 7, 4, 5]
assert spiralOrder([[1, 2, 3, 4], [5, 6, 7, 8]]) == [1, 2, 3, 4, 8, 7, 6, 5]
assert spiralOrder([[1, 2], [3, 4], [5, 6], [7, 8]]) == [1, 2, 4, 6, 8, 7, 5, 3]
```

</div>

<div id="b1638de8" class="cell code" execution_count="15"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-18T16:52:49.271447Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-18T16:52:49.270960Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-18T16:52:49.275526Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-18T16:52:49.275102Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:9.639e-3,&quot;end_time&quot;:&quot;2024-09-18T16:52:49.276429&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-18T16:52:49.266790&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def rearrangeArray(nums: list[int]) -> list[int]:
    # Split and obtain the nums into two diff arrays
    pos: collections.deque[int] = collections.deque([])
    neg: collections.deque[int] = collections.deque([])
    for n in nums:
        if n < 0:
            neg.append(n)
        else:
            pos.append(n)

    # Pos first, neg next preserving original order
    result: list[int] = []
    for i in range(len(nums) // 2):
        result.append(pos.popleft())
        result.append(neg.popleft())

    return result

# Testing the solution
assert rearrangeArray([1,-1,-3,-4,2,3]) == [1,-1,2,-3,3,-4]
assert rearrangeArray([-4,4,-4,4,-4,4]) == [4,-4,4,-4,4,-4]
```

</div>

<div id="72cfac21" class="cell code" execution_count="16"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-18T16:52:49.284806Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-18T16:52:49.284289Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-18T16:52:49.288374Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-18T16:52:49.287960Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:9.071e-3,&quot;end_time&quot;:&quot;2024-09-18T16:52:49.289227&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-18T16:52:49.280156&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def pascalTriangle(numRows: int) -> list[list[int]]:
    result: list[list[int]] = [[1]]
    for i in range(1, numRows):
        result.append([1])
        for j in range(i - 1):
            result[-1].append(result[-2][j] + result[-2][j + 1])
        result[-1].append(1)

    return result

# Testing the solution
assert pascalTriangle(5) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]
```

</div>

<div id="ab1590e1" class="cell code" execution_count="17"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-18T16:52:49.297714Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-18T16:52:49.297240Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-18T16:52:49.302734Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-18T16:52:49.302208Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.0658e-2,&quot;end_time&quot;:&quot;2024-09-18T16:52:49.303574&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-18T16:52:49.292916&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def rotateMatrix(matrix: list[list[int]]) -> list[list[int]]:
    """
    Similar to rotating an array by k places, this could be acheived
    by transposing the matrix first and then reversing the rows
    """
    N = len(matrix)

    # Transpose the matrix
    for i in range(N):
        for j in range(i + 1, N):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]

    # Reverse the rows
    for i in range(N):
        matrix[i].reverse()

    return matrix

# Testing the solution
assert rotateMatrix([[1,2,3], [4,5,6], [7,8,9]]) == [[7,4,1], [8,5,2], [9,6,3]]
assert rotateMatrix([[0,1,1,2], [2,0,3,1], [4,5,0,5], [5,6,7,0]]) == [[5,4,2,0], [6,5,0,1], [7,0,3,1], [0,5,1,2]]
assert rotateMatrix([[1,1,2], [5,3,1], [5,3,5]]) == [[5,5,1], [3,3,1], [5,1,2]]
```

</div>

<div id="3e260a7c" class="cell code" execution_count="18"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-18T16:52:49.311864Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-18T16:52:49.311423Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-18T16:52:49.316187Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-18T16:52:49.315743Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:9.848e-3,&quot;end_time&quot;:&quot;2024-09-18T16:52:49.317069&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-18T16:52:49.307221&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def twoSum(nums: list[int], target: int) -> tuple[int, int]:
    N = len(nums)
    nums_: list[tuple[int, int]] = sorted(enumerate(nums), key=lambda x: x[1])
    i, j = 0, N - 1
    while i < j:
        curr = nums_[i][1] + nums_[j][1]
        pair = sorted([nums_[i][0], nums_[j][0]])
        if curr == target:
            return pair[0], pair[1]
        elif curr < target:
            i += 1
        else:
            j -= 1

    return -1, -1

# Testing the solution
assert twoSum([1,6,2,10,3], 7) == (0,1)
assert twoSum([1,3,5,-7,6,-3], 0) == (1,5)
assert twoSum([-6,7,1,-7,6,2], 3) == (2,5)
```

</div>

<div id="70e0ad16" class="cell code" execution_count="19"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-18T16:52:49.326330Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-18T16:52:49.325977Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-18T16:52:49.330874Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-18T16:52:49.330358Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.1068e-2,&quot;end_time&quot;:&quot;2024-09-18T16:52:49.331804&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-18T16:52:49.320736&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def threeSum(nums: list[int]) -> set[tuple[int, int, int]]:
    N = len(nums)
    nums.sort()
    results: set[tuple[int, int, int]] = set()
    for i in range(N - 2):
        j, k = i + 1, N - 1
        while j < k:
            curr = nums[i] + nums[j] + nums[k]
            triplet = sorted([nums[i], nums[j], nums[k]])
            if curr == 0:
                results.add((triplet[0], triplet[1], triplet[2]))
                j, k = j + 1, k - 1
            elif curr > 0:
                k -= 1
            else:
                j += 1

    return results

# Testing the solution
assert threeSum([2, -2, 0, 3, -3, 5]) == {(-3, -2, 5), (-3, 0, 3), (-2, 0, 2)}
assert threeSum([2, -1, -1, 3, -1]) == {(-1, -1, 2)}
```

</div>

<div id="2696f7e0" class="cell code" execution_count="20"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-18T16:52:49.340304Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-18T16:52:49.339903Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-18T16:52:49.345427Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-18T16:52:49.344994Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.0678e-2,&quot;end_time&quot;:&quot;2024-09-18T16:52:49.346288&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-18T16:52:49.335610&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def fourSum(nums: list[int], target: int) -> set[tuple[int, int, int, int]]:
    """
    Iterate all combinations of i, j
    For each such combination deploy the two pointer approach
    """
    N = len(nums)
    nums.sort()
    results: set[tuple[int, int, int, int]] = set()
    for i in range(N - 3):
        for j in range(i + 1, N - 2):
            k, l = j + 1, N - 1
            while k < l:
                quad: list[int] = sorted([nums[i], nums[j], nums[k], nums[l]])
                total = nums[i] + nums[j] + nums[k] + nums[l]
                if total == target:
                    results.add((quad[0], quad[1], quad[2], quad[3]))
                    k, l = k + 1, l - 1
                elif total > target:
                    l -= 1
                else:
                    k += 1

    return results

# Testing the solution
assert fourSum([1,-2,3,5,7,9], 7) == {(-2,1,3,5)}
assert fourSum([7,-7,1,2,14,3], 9) == set()
assert fourSum([1,1,3,4,-3], 5) == {(-3,1,3,4)}
```

</div>

<div id="e460ed7b" class="cell code" execution_count="21"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-18T16:52:49.354907Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-18T16:52:49.354485Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-18T16:52:49.358894Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-18T16:52:49.358385Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:9.666e-3,&quot;end_time&quot;:&quot;2024-09-18T16:52:49.359799&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-18T16:52:49.350133&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def sortZeroOneTwo(nums: list[int]) -> list[int]:
    """
    Variation of Dutch National flag algorithm
    A much more intuitive algorithm is bucket sort

    DNF:
    Assume nums from [0, low], [high, N-1] are sorted.
    Numbers between (low, high) are unsorted
    """
    N = len(nums)
    low, mid, high = 0, 0, N - 1
    while mid <= high:
        # Correct position
        if nums[mid] == 1:
            mid += 1

        # Incorrect
        elif nums[mid] == 0:
            nums[low], nums[mid] = nums[mid], nums[low]
            low, mid = low + 1, mid + 1
        else:
            nums[high], nums[mid] = nums[mid], nums[high]
            high -= 1

    return nums

# Testing the solution
assert sortZeroOneTwo([0,0,1,2,0,1,2,2,1,0]) == [0,0,0,0,1,1,1,2,2,2]
```

</div>

<div id="5e1e76e9" class="cell code" execution_count="22"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-18T16:52:49.368467Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-18T16:52:49.367915Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-18T16:52:49.372315Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-18T16:52:49.371898Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:9.528e-3,&quot;end_time&quot;:&quot;2024-09-18T16:52:49.373165&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-18T16:52:49.363637&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def maxSubArray(nums: list[int]) -> int:
    """
    Kadane's algorithm
    If at any pt total becomes less than 0, reset it
    """
    max_, total = nums[0], 0
    for n in nums:
        total += n
        max_ = max(max_, total)
        if total < 0:
            total = 0
    return max_

# Testing the solution
assert maxSubArray([2, 3, 5, -2, 7, -4]) == 15
assert maxSubArray([-2, -3, -7, -2, -10, -4]) == -2
assert maxSubArray([-1, 2, 3, -1, 2, -6, 5]) == 6
```

</div>

<div id="028c7163" class="cell code" execution_count="23"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-18T16:52:49.381941Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-18T16:52:49.381472Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-18T16:52:49.385881Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-18T16:52:49.385328Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:9.758e-3,&quot;end_time&quot;:&quot;2024-09-18T16:52:49.386775&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-18T16:52:49.377017&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def majorityElement(nums: list[int]) -> int:
    """
    Logic: Assume a number is the majority element, everytime we encounter num in nums that equals
    our curr we increment count by 1 else decrement count by 1.

    Continue doing until we have reached the end of the array
    """
    result: int|None = None
    freq: int = 0
    for n in nums:
        if not result:
            result, freq = n, 1
        elif n == result:
            freq += 1
        else:
            freq -= 1

        if freq == 0:
            result = None

    return result if result else 0

# Testing the solution
assert majorityElement([7, 0, 0, 1, 7, 7, 2, 7, 7]) == 7
assert majorityElement([1, 1, 1, 2, 1, 2]) == 1
assert majorityElement([-1, -1, -1, -1]) == -1
```

</div>

<div id="9ec51a9d" class="cell code" execution_count="24"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-18T16:52:49.395357Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-18T16:52:49.394849Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-18T16:52:49.400591Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-18T16:52:49.400085Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.0865e-2,&quot;end_time&quot;:&quot;2024-09-18T16:52:49.401414&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-18T16:52:49.390549&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def majorityElementTwo(nums: list[int]) -> list[int]:
    """
    Same as prev question but we have two slots now.
    """
    N = len(nums)
    n1, f1, n2, f2 = 0, 0, 0, 0
    for n in nums:
        if f1 == 0 and n != n2:
            n1, f1 = n, 1
        elif f2 == 0 and n != n1:
            n2, f2 = n, 1
        elif n == n1:
            f1 += 1
        elif n == n2:
            f2 += 1
        else:
            f1, f2 = f1 - 1, f2 - 1

    # Double check to ensure that the majority
    # elements are occuring more than N // 3 times
    freq: dict[int, int] = dict()
    for n in nums:
        if n in (n1, n2):
            freq[n] = freq.get(n, 0) + 1

    return [n for n in (n1, n2) if freq.get(n, 0) > N // 3]

# Testing the solution
assert majorityElementTwo([1,1,1,1]) == [1]
assert majorityElementTwo([1,2,1,1,3,2,2]) == [1,2]
assert majorityElementTwo([1,2,1,1,3,2]) == [1]
assert majorityElementTwo([1,2,1,1,3,2,2,3]) == [1,2]
assert majorityElementTwo([1,1,2,2,3,3,4,4,5,5]) == []
```

</div>

<div id="2abcdcfe" class="cell code" execution_count="25"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-09-18T16:52:49.410047Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-09-18T16:52:49.409855Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-09-18T16:52:49.415284Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-09-18T16:52:49.414855Z&quot;}"
papermill="{&quot;duration&quot;:1.0699e-2,&quot;end_time&quot;:&quot;2024-09-18T16:52:49.416070&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-09-18T16:52:49.405371&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def numberOfInversions(nums: list[int]) -> int:
    def modified_mergesort(low: int, high: int) -> int:
        if low >= high:
            return 0

        else:
            # Merge sort left and right
            mid = (low + high) // 2
            cnt_left = modified_mergesort(low, mid)
            cnt_right = modified_mergesort(mid + 1, high)

            # Create temp array for storing in order
            temp: list[int] = []
            cnt, i, j = 0, low, mid + 1
            while i <= mid or j <= high:
                if j > high or (i <= mid and nums[i] <= nums[j]):
                    temp.append(nums[i])
                    i += 1
                else:
                    temp.append(nums[j])
                    j += 1

                    # We are inserting from the right portion
                    # Simply count how many elements we have
                    # left in the 'left' array
                    cnt += mid - i + 1

            # Copy from temp back to array
            for i in range(low, high + 1):
                nums[i] = temp[i - low]

            return cnt_left + cnt_right + cnt

    inversions = modified_mergesort(0, len(nums) - 1)
    return inversions

assert numberOfInversions([2, 3, 7, 1, 3, 5]) == 5
assert numberOfInversions([-10, -5, 6, 11, 15, 17]) == 0
assert numberOfInversions([9, 5, 4, 2]) == 6
```

</div>
