---
jupyter:
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
  language_info:
    codemirror_mode:
      name: ipython
      version: 3
    file_extension: .py
    mimetype: text/x-python
    name: python
    nbconvert_exporter: python
    pygments_lexer: ipython3
    version: 3.10.14
  nbformat: 4
  nbformat_minor: 5
  papermill:
    default_parameters: {}
    duration: 28.844098
    end_time: "2024-04-21T15:47:33.086112"
    environment_variables: {}
    input_path: practice/001.ipynb
    output_path: practice/001.ipynb
    parameters: {}
    start_time: "2024-04-21T15:47:04.242014"
    version: 2.5.0
---

<div id="3f12b031" class="cell code" execution_count="1"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:05.441683Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:05.440978Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:05.946324Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:05.945598Z&quot;}"
papermill="{&quot;duration&quot;:0.53125,&quot;end_time&quot;:&quot;2024-04-21T15:47:05.948314&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:05.417064&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
from typing import List, Optional, Generator
import pandas as pd
import numpy as np
import sqlite3
import re
import io
import math
import collections
import itertools
import functools
import random
import string
import tqdm
import bisect

conn = sqlite3.connect(":memory:")

def regexp(expr, item):
    reg = re.compile(expr)
    return reg.search(item) is not None

def read_lc_df(s: str, dtypes: dict[str, str]=dict()) -> pd.DataFrame:
    temp = pd.read_csv(io.StringIO(s), sep="|", skiprows=2)
    temp = temp.iloc[1:-1, 1:-1]
    temp.columns = temp.columns.map(str.strip)
    temp = temp.map(lambda x: x if type(x) != str else None if x.strip() == 'null' else x.strip())
    temp = temp.astype(dtypes)
    return temp

conn.create_function("REGEXP", 2, regexp)
```

</div>

<div id="7f5a0241" class="cell markdown"
papermill="{&quot;duration&quot;:2.2359e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:05.993251&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:05.970892&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

#### Helper for Binary tree problems

</div>

<div id="85eb2598" class="cell code" execution_count="2"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:06.038308Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:06.037985Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:06.049413Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:06.048622Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.6155e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:06.051127&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:06.014972&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
class BinaryTreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

    def to_list(self):
        to_visit = [self]
        visited = []
        while len(to_visit) > 0:
            curr = to_visit.pop(0)
            if curr:
                to_visit.append(curr.left)
                to_visit.append(curr.right)
                visited.append(curr.val)
            else:
                visited.append(curr)

        while visited and not visited[-1]:
            visited.pop()

        return visited

    def __str__(self):
        return str(self.val)

    @staticmethod
    def from_array(nums: list[int|None]):
        '''Create a Tree from a list of nums. Returns the root node.'''
        if len(nums) == 0:
            return None
        elif len(nums) == 1:
            return BinaryTreeNode(nums[0])
        else:
            forest = [BinaryTreeNode(nums[0])]
            parent_idx = -1
            for i in range(1, len(nums)):

                curr = None
                if nums[i] is not None:
                    curr = BinaryTreeNode(nums[i])
                    forest.append(curr)

                if i % 2 == 1:
                    parent_idx += 1
                    forest[parent_idx].left = curr
                else:
                    forest[parent_idx].right = curr

        return forest[0]
```

</div>

<div id="1ef703cf" class="cell markdown"
papermill="{&quot;duration&quot;:2.1753e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:06.094853&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:06.073100&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

#### Helper for Singly Linked lists

</div>

<div id="3de163a1" class="cell code" execution_count="3"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:06.139573Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:06.139316Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:06.146289Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:06.145606Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.1383e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:06.147915&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:06.116532&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

    def __str__(self):
        return str(self.val)

    @staticmethod
    def to_singly_linked_list(nums: list[int]):
        root = prev = None
        for n in nums:
            curr = ListNode(n)
            # Init once
            if not root:
                root = curr
            if prev:
                prev.next = curr
            prev = curr

        return root

    def to_list(self) -> list[int]:
        result = []
        curr = self
        while curr:
            result.append(curr.val)
            curr = curr.next
        return result
```

</div>

<div id="35f93518" class="cell markdown"
papermill="{&quot;duration&quot;:2.139e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:06.190930&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:06.169540&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

#### Utility to generate random BST

</div>

<div id="848c43e5" class="cell code" execution_count="4"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:06.235419Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:06.234822Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:06.241511Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:06.240842Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.0748e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:06.243174&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:06.212426&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def generateBST(N: int, min_: int, max_: int) -> BinaryTreeNode|None:
    def insert(curr: BinaryTreeNode|None, n: int) -> BinaryTreeNode:
        if not curr:
            curr = BinaryTreeNode(n)
        elif curr.val < n:
            curr.right = insert(curr.right, n)
        else:
            curr.left = insert(curr.left, n)

        return curr

    assert N <= max_ - min_, "Number of available samples must be >= N"
    root: BinaryTreeNode|None = None
    for n in np.random.choice(np.arange(min_, max_), size=N, replace=False):
        root = insert(root, n)

    return root
```

</div>

<div id="e9a621b3" class="cell code" execution_count="5"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:06.288255Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:06.287661Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:06.294786Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:06.294047Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.1611e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:06.296464&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:06.264853&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Problem Category: Easy
# Link: https://leetcode.com/problems/find-mode-in-binary-search-tree/submissions/1187947888
class Solution:
    def findMode(self, root: BinaryTreeNode) -> List[int]:
        def backtrack(curr: BinaryTreeNode):
            if curr == None:
                return
            else:
                hm[curr.val] = hm.get(curr.val, 0) + 1
                backtrack(curr.left)
                backtrack(curr.right)

        hm: dict[int, int] = dict()
        backtrack(root)
        max_ = max(hm.values())
        result: list[int] = []
        for k, v in hm.items():
            if v == max_:
                result.append(k)
        return result

# Testing the solution
assert Solution().findMode(BinaryTreeNode.from_array([1,None,2,2])) == [2]
assert Solution().findMode(BinaryTreeNode.from_array([0])) == [0]
```

</div>

<div id="9b733058" class="cell code" execution_count="6"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:06.341586Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:06.341048Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:06.347583Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:06.346841Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.093e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:06.349365&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:06.318435&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Problem Category: Medium
# Link: https://leetcode.com/problems/find-bottom-left-tree-value/submissions/1188894879/
class Solution:
    def findBottomLeftValue(self, root: BinaryTreeNode) -> int:
        next_: list[BinaryTreeNode] = [root]
        while True:
            next_next_: list[BinaryTreeNode] = []
            for node in next_:
                if node.left:
                    next_next_.append(node.left)
                if node.right:
                    next_next_.append(node.right)
            if next_next_:
                next_ = next_next_
            else:
                break
        return next_[0].val

# Testing the solution
assert Solution().findBottomLeftValue(BinaryTreeNode.from_array([2, 1, 3])) == 1
assert Solution().findBottomLeftValue(BinaryTreeNode.from_array([1,2,3,4,None,5,6,None,None,7])) == 7
```

</div>

<div id="d0726800" class="cell code" execution_count="7"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:06.394070Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:06.393528Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:06.398753Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:06.398009Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.9376e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:06.400447&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:06.371071&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Problem Category: Easy
# Link: https://leetcode.com/problems/maximum-odd-binary-number/1190823057
class Solution:
    def maximumOddBinaryNumber(self, s: str) -> str:
        counts = dict(collections.Counter(s))
        zeros = counts.get('0', 0) * '0'
        ones = (counts.get('1', 0) - 1) * '1'
        return ones + zeros + '1'

# Testing the solution
assert Solution().maximumOddBinaryNumber("010") == "001"
assert Solution().maximumOddBinaryNumber("0101") == "1001"
```

</div>

<div id="a61be2aa" class="cell code" execution_count="8"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:06.445235Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:06.444711Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:06.451862Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:06.451125Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.1404e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:06.453655&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:06.422251&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Problem Category: Easy
# Link: https://leetcode.com/problems/squares-of-a-sorted-array
class Solution:
    def sortedSquares(self, nums: list[int]) -> list[int]:
        N = len(nums)
        i, j = 0, N - 1
        sorted_by_magnitude: list[int] = []
        while i <= j:
            if abs(nums[i]) > abs(nums[j]):
                sorted_by_magnitude.append(nums[i])
                i += 1
            else:
                sorted_by_magnitude.append(nums[j])
                j -= 1
        sorted_by_magnitude.reverse()

        result: list[int] = []
        for num in sorted_by_magnitude:
            result.append(num * num)

        return result

# Testing the solution
assert Solution().sortedSquares([-4,-1,0,3,10]) == [0, 1, 9, 16, 100]
assert Solution().sortedSquares([-7,-4,-1,0,3,10]) == [0, 1, 9, 16, 49, 100]
```

</div>

<div id="f1f33401" class="cell code" execution_count="9"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:06.498402Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:06.497839Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:06.505194Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:06.504490Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.1505e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:06.506845&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:06.475340&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Problem Category: Medium
# Link: https://leetcode.com/problems/minimum-length-of-string-after-deleting-similar-ends/submissions/1194814297
class Solution:
    def minimumLength(self, s: str) -> int:
        N = len(s)
        i, j = 0, N - 1
        while i < j:
            while i < N - 1 and s[i + 1] == s[i] and s[i] == s[j]:
                i += 1
            while j > 1 and s[j - 1] == s[j] and s[i] == s[j]:
                j -= 1
            if s[i] == s[j]:
                i += 1
                j -= 1
            else:
                return (j - i) + 1
        else:
            return 1 if i == j else 0

# Testing the solution
assert Solution().minimumLength("ca") == 2
assert Solution().minimumLength("cabaabac") == 0
assert Solution().minimumLength("aabccabba") == 3
assert Solution().minimumLength("bbbbbabbbbccbcbcbccbbabbb") == 1
assert Solution().minimumLength("aaaa") == 0
```

</div>

<div id="79086e5d" class="cell code" execution_count="10"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:06.552287Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:06.551734Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:06.558087Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:06.557412Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.0935e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:06.559653&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:06.528718&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Problem Category: Easy
# Link: https://leetcode.com/problems/ransom-note/submissions/1195815128
class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        cr = collections.Counter(ransomNote)
        cm = collections.Counter(magazine)
        for i in range(ord("a"), ord("z") + 1):
            ch = chr(i)
            if cm.get(ch, 0) < cr.get(ch, 0):
                return False
        else:
            return True

# Testing the solution
assert Solution().canConstruct("aa", "aab") == True
assert Solution().canConstruct("a", "b") == False
assert Solution().canConstruct("aa", "ab") == False
```

</div>

<div id="86315f1b" class="cell markdown"
papermill="{&quot;duration&quot;:4.1968e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:06.623469&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:06.581501&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Striver: Pascal's triangle Problem: Finding nCr in minimal time (part of
pascal's triangle) Find element at position 1st 2nd column in a pascal's
triangle Sol: math.comb(n -1, r - 1)

</div>

<div id="d8a93518" class="cell code" execution_count="11"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:06.668487Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:06.667827Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:06.674560Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:06.673842Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.1046e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:06.676234&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:06.645188&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def nCr(n: int, r: int) -> float:
    num = functools.reduce(lambda x, y: x * y, range(n, n - r, -1))
    den = functools.reduce(lambda x, y: x * y, range(r, 0, -1))
    return num / den

# Testing the solution
for i in range(50):
    i, j = sorted([random.randint(1, 50), random.randint(1, 50)], reverse=True)
    assert math.comb(i, j) == nCr(i, j), f"failed for {i, j}"
```

</div>

<div id="3936a59e" class="cell code" execution_count="12"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:06.721009Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:06.720391Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:06.732382Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:06.731643Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.6146e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:06.734094&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:06.697948&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# 4Sum
class Solution:
    def fourSum(self, arr: list[int], target: int) -> set[tuple[int]]:
        def update_until(idx: int, update: int, until: int):
            temp_idx = idx
            assert update != 0
            if update > 0:
                while temp_idx < until and arr[temp_idx] == arr[idx]:
                    temp_idx += update
            else:
                while temp_idx > until and arr[temp_idx] == arr[idx]:
                    temp_idx += update
            return temp_idx

        N = len(arr)
        arr.sort()
        result: set[tuple[int]] = set()
        i = 0
        while i < N - 3:
            j = i + 1
            while j < N - 2:
                k, l = j + 1, N - 1
                while k < l:
                    curr = arr[i], arr[j], arr[k], arr[l]
                    if sum(curr) == target:
                        result.add(curr)
                        # Increment k, l
                        k_, l_ = k, l
                        while k_ < l_ and arr[k_] == arr[k] and arr[l_] == arr[l]:
                            k_, l_ = k_ + 1, l_ - 1
                        k, l = k_, l_
                    elif sum(curr) < target:
                        # Increment k
                        k = update_until(k, 1, l)
                    else:
                        # Decrement l
                        l = update_until(l, -1, k)

                # Increment j
                j = update_until(j, 1, N - 2)

            # Increment i
            i = update_until(i, 1, N - 3)

        return result

# Testing the solution
assert Solution().fourSum([1,0,-1,0,-2,2], 0) == {(-2,-1,1,2), (-2,0,0,2), (-1,0,0,1)}
assert Solution().fourSum([2,2,2,2,2], 8) == {(2, 2, 2, 2)}
```

</div>

<div id="e839124e" class="cell markdown"
papermill="{&quot;duration&quot;:2.1731e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:06.777817&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:06.756086&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Leetcode Weekly contest - 17th March

</div>

<div id="e6574b26" class="cell code" execution_count="13"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:06.822653Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:06.822048Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:06.827359Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:06.826622Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.9544e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:06.829019&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:06.799475&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
class Solution:
    def isSubstringPresent(self, s: str) -> bool:
        rev_ = "".join(list(reversed(s)))
        N = len(s)
        for i in range(N - 1):
            if s[i:i+2] in rev_:
                return True
        return False

# Testing the solution
assert Solution().isSubstringPresent("leetcode") == True
assert Solution().isSubstringPresent("abcd") == False
```

</div>

<div id="f12cafc3" class="cell markdown"
papermill="{&quot;duration&quot;:2.1739e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:06.872521&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:06.850782&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

zz - z, z, zz (3) zzz - z, z, z, zz, zz, zzz (6) zzzz - z, z, z, z; zz,
zz, zz, zzz, zzz, zzzz (10) zzzzz - z, z, z, z, z, zz, zz, zz, zz, zzz,
zzz, zzz, zzzz, zzzz, zzzzz (15)

</div>

<div id="589d1561" class="cell code" execution_count="14"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:06.917397Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:06.916741Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:06.922185Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:06.921427Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.9515e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:06.923815&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:06.894300&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
class Solution:
    def countSubstrings(self, s: str, c: str) -> int:
        count = 0
        for ch in s:
            if ch == c:
                count += 1
        return (count * (count + 1)) / 2

# Testing the solution
assert Solution().countSubstrings("abada", "a") == 6
assert Solution().countSubstrings("zzz", "z") == 6
```

</div>

<div id="a0a48e4b" class="cell code" execution_count="15"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:06.968428Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:06.967856Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:06.974634Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:06.973895Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.106e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:06.976428&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:06.945368&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
class Solution:
    def minimumDeletions(self, word: str, k: int) -> int:
        freq: list[int] = sorted(collections.Counter(word).values())
        N = len(freq)

        result = math.inf
        sum_ = 0
        for i in range(N):
            sum_ += freq[i - 1] if i > 0 else 0
            curr_ = 0
            for j in range(i + 1, N):
                if freq[j] - freq[i] > k:
                    curr_ += freq[j] - freq[i] - k
            result = min(curr_ + sum_, result)

        return result

# Testing the solution
assert Solution().minimumDeletions("aabcaba", 0) == 3
assert Solution().minimumDeletions("dabdcbdcdcd", 2) == 2
assert Solution().minimumDeletions("aaabaaa", 2) == 1
```

</div>

<div id="acd2120e" class="cell markdown"
papermill="{&quot;duration&quot;:2.1648e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:07.019984&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:06.998336&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Leetcode Weekly contest - 17th March Link:
<https://leetcode.com/problems/search-in-rotated-sorted-array/submissions/1210464524/>

</div>

<div id="f7960549" class="cell code" execution_count="16"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:07.066774Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:07.066124Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:07.073857Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:07.073073Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.3839e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:07.075445&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:07.041606&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
class Solution:
    def search(self, nums: list[int], target: int) -> int:
        N = len(nums)
        low, high = 0, N - 1
        while low <= high:
            mid = (low + high) // 2
            if nums[mid] == target:
                return mid

            # Left portion is sorted
            elif nums[low] <= nums[mid]:
                if nums[low] <= target <= nums[mid]:
                    high = mid - 1
                else:
                    low = mid + 1

            # Right portion is sorted
            else:
                if nums[mid] <= target <= nums[high]:
                    low = mid + 1
                else:
                    high = mid - 1

        # Not found
        else:
            return -1

# Testing the solution
assert Solution().search([4,5,6,7,0,1,2], 0) == 4
assert Solution().search([4,5,6,7,0,1,2], 3) == -1
assert Solution().search([1], 0) == -1
```

</div>

<div id="6d00645d" class="cell markdown"
papermill="{&quot;duration&quot;:2.166e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:07.119101&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:07.097441&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Leetcode weekly contest 24th March, 2024

</div>

<div id="4115c1b7" class="cell code" execution_count="17"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:07.164103Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:07.163548Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:07.169925Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:07.169149Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.0727e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:07.171577&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:07.140850&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Q1 - Easy
class Solution:
    def maximumLengthSubstring(self, s: str) -> int:
        # Brute force
        N = len(s)
        max_ = 0
        for i in range(N - 1):
            counts = {s[i]: 1}
            for j in range(i + 1, N):
                curr_count = counts.get(s[j], 0) + 1
                if curr_count > 2:
                    break
                else:
                    counts[s[j]] = curr_count
                    max_ = max(max_, j - i + 1)
        return max_

# Testing the solution
assert Solution().maximumLengthSubstring("bcbbbcba") == 4
assert Solution().maximumLengthSubstring("aaaa") == 2
```

</div>

<div id="d41b9204" class="cell code" execution_count="18"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:07.216788Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:07.216142Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:07.221424Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:07.220669Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.9639e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:07.223056&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:07.193417&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Q2 - Medium
class Solution:
    def minOperations(self, k: int) -> int:
        "Can be optimized with binary search"
        min_ = k - 1
        for i in range(1, k):
            curr = i + math.ceil(k / i) - 2
            if curr < min_:
                min_ = curr

        return min_

# Testing the solution
assert Solution().minOperations(11) == 5
assert Solution().minOperations(1) == 0
```

</div>

<div id="51f6c341" class="cell code" execution_count="19"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:07.268176Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:07.267661Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:07.274420Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:07.273661Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.0967e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:07.276110&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:07.245143&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Q3 - Medium (Timeout)
class Solution:
    def mostFrequentIDs(self, nums: list[int], freq: list[int]) -> list[int]:
        "Brute force: O(N^2)"
        N = len(nums)
        counter = dict()
        result: list[int] = []
        for i in range(N):
            counter[nums[i]] = counter.get(nums[i], 0) + freq[i]
            curr_max = max(counter.items(), key=lambda x: x[1])
            result.append(curr_max[1])

        return result

# Testing the solution
assert Solution().mostFrequentIDs([5,5,3], [2,-2,1]) == [2, 0, 1]
assert Solution().mostFrequentIDs([2,3,2,1], [3,2,-3,1]) == [3,3,2,2]
```

</div>

<div id="f581903e" class="cell markdown"
papermill="{&quot;duration&quot;:2.1745e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:07.319677&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:07.297932&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Category: Medium Video Link:
<https://leetcode.com/problems/find-the-duplicate-number>

</div>

<div id="08bb3876" class="cell code" execution_count="20"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:07.364697Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:07.364103Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:07.372495Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:07.371878Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.269e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:07.374174&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:07.341484&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
class Solution:
    def findDuplicate_(self, nums: list[int]) -> int:
        # Time - O(N log N)
        nums.sort()

        # Time - O(N)
        for i in range(len(nums) -1):
            if nums[i] == nums[i + 1]:
                return nums[i]

        return -1

    def findDuplicate(self, nums: list[int]) -> int:
        def backtrack(start: int) -> None | int:
            next_ = nums[start]
            if next_ == -1:
                return start
            else:
                nums[start] = -1
                return backtrack(next_)

        for i in range(len(nums)):
            if nums[i] == i:
                nums[i] = -1
            else:
                curr = backtrack(nums[i])
                if curr is not None:
                    return curr
        else:
            return -1

# Testing the solution
assert Solution().findDuplicate([1,3,4,2,2]) == 2
assert Solution().findDuplicate([3,1,3,4,2]) == 3
assert Solution().findDuplicate([3,3,3,3,3]) == 3
```

</div>

<div id="18a3ddfa" class="cell markdown"
papermill="{&quot;duration&quot;:2.1739e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:07.417709&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:07.395970&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

#### Leetcode Contest: 31st March 2024 (# 391)

</div>

<div id="94eae322" class="cell code" execution_count="21"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:07.465007Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:07.464504Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:07.469257Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:07.468509Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.0679e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:07.470971&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:07.440292&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Q1 - Easy
class Solution:
    def sumOfTheDigitsOfHarshadNumber(self, x: int) -> int:
        result = sum(map(int, str(x)))
        if x % result == 0:
            return result
        else:
            return -1
```

</div>

<div id="3820ddc5" class="cell code" execution_count="22"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:07.516061Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:07.515388Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:07.522408Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:07.521763Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.115e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:07.524010&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:07.492860&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Q2 - Medium
class Solution:
    def maxBottlesDrunk(self, numBottles: int, numExchange: int) -> int:
        def exchange(empty: int, exchange: int) -> tuple[int, int, int]:
            """
            Given count of empty bottles and start exchange rate,
            returns number of full bottles we can form and the updated exchange rate

            For eg:

            empty = 10, exchange = 1

             E, R, F
            10, 1, 0
            9,  2, 1
            7,  3, 2
            4,  4, 3
            0,  5, 4

            empty = 9, exchange = 1

            E, R, F
            9, 1, 0
            8, 2, 1
            6, 3, 2
            3, 4, 3

            """
            filled = 0
            while empty >= exchange:
                empty -= exchange
                exchange += 1
                filled += 1

            return empty, exchange, filled

        total = empty = 0
        while numBottles:
            total += numBottles
            empty, numBottles = empty + numBottles, 0
            empty, numExchange, numBottles = exchange(empty, numExchange)

        return total

# Testing the solution
assert Solution().maxBottlesDrunk(10, 3) == 13
assert Solution().maxBottlesDrunk(13, 6) == 15
```

</div>

<div id="76322274" class="cell code" execution_count="23"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:07.569662Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:07.569086Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:07.575044Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:07.574358Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.06e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:07.576666&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:07.546066&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Q3 - Medium
class Solution:
    def countAlternatingSubarrays(self, nums: list[int]) -> int:
        count, curr, N = 0, 0, len(nums)
        for i in range(N + 1):
            if i == 0 or (i < N and nums[i - 1] != nums[i]):
                curr += 1
            else:
                count += (curr * (curr + 1)) // 2
                curr = 1

        return count

# Testing the solution
assert Solution().countAlternatingSubarrays([1,0,1,0]) == 10
assert Solution().countAlternatingSubarrays( [0,1,1,1]) == 5
```

</div>

<div id="aa42e3c4" class="cell markdown"
papermill="{&quot;duration&quot;:2.1744e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:07.620219&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:07.598475&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Easy Leetcode question:
<https://leetcode.com/problems/minimum-common-value>

</div>

<div id="d2e96902" class="cell code" execution_count="24"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:07.665140Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:07.664594Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:07.670642Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:07.669922Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.0279e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:07.672247&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:07.641968&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def getCommon(nums1: list[int], nums2: list[int]) -> int:
    N1, N2 = len(nums1), len(nums2)
    i = j = 0
    while i < N1 and j < N2:
        if nums1[i] == nums2[j]:
            return nums1[i]
        elif nums1[i] < nums2[j]:
            i += 1
        else:
            j += 1

    return -1

# Testing the solution
assert getCommon([1, 2, 3], [2, 4]) == 2
assert getCommon([1, 2, 3], [4, 5, 6]) == -1
assert getCommon([1, 2, 3], [3]) == 3
```

</div>

<div id="60f3c0df" class="cell markdown"
papermill="{&quot;duration&quot;:2.1616e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:07.715805&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:07.694189&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Diameter of binary Tree Problem Link:
<https://leetcode.com/problems/diameter-of-binary-tree/submissions/1222192232>

</div>

<div id="e0fb0a0f" class="cell code" execution_count="25"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:07.760607Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:07.759934Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:07.766095Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:07.765331Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.0209e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:07.767669&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:07.737460&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def diameterOfBinaryTree(root: BinaryTreeNode) -> int:
    """
    1. Perform a post order traversal
    2. Keep updating a global max_ variable as max(max_, left + right) before returning. This is our final result.
    3. At each recursive step, return max(left, right)
    """

    result: int = 0
    def postOrder(curr: BinaryTreeNode) -> int:
        nonlocal result
        if not curr:
            return 0
        else:
            left_max = postOrder(curr.left)
            right_max = postOrder(curr.right)
            result = max(result, left_max + right_max)
            return max(left_max, right_max) + 1

    postOrder(root)
    return result

# Testing the solution
assert diameterOfBinaryTree(BinaryTreeNode.from_array([1, 2, 3, 4, 5])) == 3
assert diameterOfBinaryTree(BinaryTreeNode.from_array([1, 2])) == 1
```

</div>

<div id="95066bc4" class="cell markdown"
papermill="{&quot;duration&quot;:2.1665e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:07.811350&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:07.789685&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Easy Leetcode question Problem Link:
<https://leetcode.com/problems/largest-3-same-digit-number-in-string/submissions/1222201215/>

</div>

<div id="dd3767a4" class="cell code" execution_count="26"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:07.856388Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:07.855804Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:07.864523Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:07.863762Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.2927e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:07.866216&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:07.833289&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def largestGoodInteger(num: str) -> str:
    for n in "9876543210":
        if n * 3 in num:
            return n * 3
    else:
        return ""

# Testing the solution
largestGoodInteger("6777133339")
```

<div class="output execute_result" execution_count="26">

    '777'

</div>

</div>

<div id="90d38ef2" class="cell markdown"
papermill="{&quot;duration&quot;:2.1806e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:07.910235&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:07.888429&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Easy Leetcode question Problem Link:
<https://leetcode.com/problems/largest-odd-number-in-string/submissions/1222208825>

</div>

<div id="ba91d179" class="cell code" execution_count="27"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:07.956475Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:07.955973Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:07.962439Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:07.961650Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.0769e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:07.964058&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:07.933289&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def largestOddNumber(num: str) -> str:
    N = len(num)
    for i in range(N - 1, -1, -1):
        if int(num[i]) % 2 == 1:
            return num[:i + 1]
    else:
        return ""

# Testing the solution
largestOddNumber("354278")
```

<div class="output execute_result" execution_count="27">

    '35427'

</div>

</div>

<div id="84ba2176" class="cell markdown"
papermill="{&quot;duration&quot;:2.2031e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:08.008434&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:07.986403&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Leetcode easy problem:
<https://leetcode.com/problems/make-the-string-great/submissions/1224126212>

</div>

<div id="94ade9d0" class="cell code" execution_count="28"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:08.053786Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:08.053153Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:08.058418Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:08.057635Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.9617e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:08.060022&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:08.030405&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def makeGood(s: str) -> str:
    stack: list[str] = []
    for c in s:
        if not stack or c.lower() != stack[-1].lower() or ord(c) == ord(stack[-1]):
            stack.append(c)
        else:
            stack.pop()

    return "".join(stack)

assert makeGood("leeEetcode") == "leetcode"
assert makeGood("abBAcC") == ""
```

</div>

<div id="b5cc8f93" class="cell markdown"
papermill="{&quot;duration&quot;:2.2359e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:08.104624&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:08.082265&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

#### Code Gladiators - 2k24

</div>

<div id="4fe7023d" class="cell code" execution_count="29"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:08.150773Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:08.150529Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:08.160513Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:08.159765Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.4692e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:08.162277&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:08.127585&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Q1
def Q1(P: int, X: int, R1: int, N: int, Y: int, R2: int):

    # Get travel time for comparison
    t1 = (P / X) + R1
    t2 = (N / Y) + R2

    if t1 < t2:
        return "NINA"
    elif t1 > t2:
        return "PAUL"
    else:
        return "BOTH"

# Q2:
def Q2(arr: list[int], N: int) -> int:

    def getPair(i: int, target: int) -> int:
        "Returns pair index j, such that arr[i] + arr[j] == target, returns -1 if not possible"
        for j in positions.get(target - arr[i], []):
            if j != i and j not in picked:
                return j
        else:
            return -1

    # Store all the values to a dict for quick reverse lookups
    positions: dict[int, list] = dict()
    for i in range(N):
        indices: list[int] = positions.get(arr[i], [])
        indices.append(i)
        positions[arr[i]] = indices

    # Weights can be between 2 * min_, 2 * max_
    max_count = 0
    for total_weight in range(min(arr) * 2, (max(arr) * 2) + 1):
        count = 0
        picked: set[int] = set()
        for i in range(N):
            j = getPair(i, total_weight) if i not in picked else -1
            if j != -1:
                picked.add(i)
                picked.add(j)
                count += 1

        max_count = max(max_count, count)

    return max_count

# Testing the solution
assert Q2([1, 1, 3, 4, 2, 2], 6) == 2
```

</div>

<div id="10f9ae1d" class="cell markdown"
papermill="{&quot;duration&quot;:3.6729e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:08.229520&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:08.192791&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Problem link:
<https://leetcode.com/problems/time-needed-to-buy-tickets/submissions/1227477603>

</div>

<div id="a8665a6b" class="cell code" execution_count="30"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:08.275912Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:08.275675Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:08.281105Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:08.280470Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.001e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:08.282773&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:08.252763&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Time: O(N), Space: O(1)
def timeRequiredToBuy(tickets: list[int], k: int) -> int:
    total = 0
    for i in range(len(tickets)):
        if i <= k:
            total += min(tickets[k], tickets[i])
        else:
            total += min(tickets[k] - 1, tickets[i])

    return total

# Testing the Solution
assert timeRequiredToBuy(tickets=[5, 1, 1, 1],  k=0) == 8
assert timeRequiredToBuy(tickets=[2, 3, 2], k=2) == 6
```

</div>

<div id="a8388f4e" class="cell markdown"
papermill="{&quot;duration&quot;:2.2086e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:08.327236&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:08.305150&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Problem Link:
<https://leetcode.com/problems/number-of-students-unable-to-eat-lunch/submissions/1227492211>

</div>

<div id="c54b1d35" class="cell code" execution_count="31"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:08.372531Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:08.372242Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:08.378223Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:08.377555Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.055e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:08.379884&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:08.349334&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def countStudents(students: list[int], sandwiches: list[int]) -> int:
    stud_pref: dict[int, int] = collections.Counter(students)
    for n in sandwiches:
        if stud_pref.get(n, 0) == 0:
            return stud_pref.get(0, 0) + stud_pref.get(1, 0)
        else:
            stud_pref[n] -= 1
    return 0

# Testing the Solution
assert countStudents([1,1,0,0], [0,1,0,1]) == 0
assert countStudents([1,1,1,0,0,1], [1,0,0,0,1,1]) == 3
```

</div>

<div id="bae9e756" class="cell markdown"
papermill="{&quot;duration&quot;:2.2015e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:08.424009&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:08.401994&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

All root to leaf paths in a Binary Tree

</div>

<div id="9b941cc0" class="cell code" execution_count="32"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:08.469790Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:08.469180Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:08.477076Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:08.476428Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.2578e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:08.478724&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:08.446146&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def allRootToLeaf(root: BinaryTreeNode) -> list[str]:
    """
    1. Do a pre order traversal.
    2. When a leaf node is encountered. Append the path to result.
    3. If not a leaf node, concat to a growing string path.
    """

    paths: list[str] = []
    def preOrder(curr: BinaryTreeNode, traveled: list[str]):
        traveled.append(str(curr.val))

        if not curr.left and not curr.right:
            nonlocal paths
            paths.append(" ".join(traveled))
        if curr.left:
            preOrder(curr.left, traveled)
        if curr.right:
            preOrder(curr.right, traveled)

        traveled.pop()

    preOrder(root, [])
    return paths

# Testing the solution
for ques, ans in (
        ([1, 2, 3, 4, None, 5, 6, None, 7, None, None, None, None, None, None], ["1 3 5", "1 3 6", "1 2 4 7"]),
        ([1, 2, 3, 4, 5, None, None, None, None, None, None], ["1 2 4", "1 2 5", "1 3"]),
    ):
    temp = allRootToLeaf(BinaryTreeNode.from_array(ques))
    for ans_str in ans:
        assert ans_str in temp, f"{ans_str} not found inside result: {temp}"
```

</div>

<div id="1e07c06f" class="cell markdown"
papermill="{&quot;duration&quot;:2.3892e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:08.531174&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:08.507282&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Problem Link:
<https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/submissions/1227536364>

</div>

<div id="bfdc7092" class="cell code" execution_count="33"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:08.577550Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:08.577222Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:08.585488Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:08.584705Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.3755e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:08.587130&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:08.553375&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def lowestCommonAncestor(root: BinaryTreeNode, p: BinaryTreeNode, q: BinaryTreeNode) -> BinaryTreeNode:
    p_path: list[BinaryTreeNode] = []
    q_path: list[BinaryTreeNode] = []
    def getPathsFromRoot(curr: BinaryTreeNode, traveled: list[BinaryTreeNode]):
        nonlocal p_path, q_path
        traveled.append(curr)
        if curr == p:
            p_path = list(traveled)
        if curr == q:
            q_path = list(traveled)
        if curr.left:
            getPathsFromRoot(curr.left, traveled)
        if curr.right:
            getPathsFromRoot(curr.right, traveled)
        traveled.pop()

    getPathsFromRoot(root, [])

    # Find common ancestor
    NP, NQ = len(p_path), len(q_path)
    i = j = 0
    while i < NP and j < NQ and p_path[i] == q_path[j]:
        i, j = i + 1, j + 1

    return p_path[i - 1]

# Testing the solution
temp: BinaryTreeNode = BinaryTreeNode.from_array([3,5,1,6,2,0,8,None,None,7,4])
assert lowestCommonAncestor(temp, p=temp.left, q=temp.left.right.right).val == 5
```

</div>

<div id="b4388e14" class="cell markdown"
papermill="{&quot;duration&quot;:2.2124e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:08.631647&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:08.609523&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Problem Link:
<https://leetcode.com/problems/maximum-width-of-binary-tree/submissions/1228429287>

</div>

<div id="876bfe38" class="cell code" execution_count="34"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:08.677422Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:08.676746Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:08.683929Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:08.683261Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.1697e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:08.685579&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:08.653882&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def widthOfBinaryTree(root: BinaryTreeNode) -> int:
    boundaries: dict[int, tuple[int, int]] = dict()
    max_width = 1
    def backtrack(curr: BinaryTreeNode, height: int, width: int):
        nonlocal boundaries, max_width
        if not curr:
            return
        else:
            curr_lr = boundaries.get(height, (2 ** height, 0))
            boundaries[height] = (min(curr_lr[0], width + 1), max(curr_lr[1], width + 1))
            max_width = max(max_width, boundaries[height][1] - boundaries[height][0] + 1)
            backtrack(curr.left, height + 1, width * 2)
            backtrack(curr.right, height + 1, (width * 2) + 1)

    backtrack(root, 0, 0)
    return max_width

# Testing the Solution
assert widthOfBinaryTree(BinaryTreeNode.from_array([1, 3, 2, 5, None, None, 9, 6, None, 7])) == 7
```

</div>

<div id="d1a33bbb" class="cell markdown"
papermill="{&quot;duration&quot;:2.2005e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:08.729559&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:08.707554&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Leetcode Easy:
<https://leetcode.com/problems/maximum-average-subarray-i/>

</div>

<div id="25620d4a" class="cell code" execution_count="35"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:08.774761Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:08.774520Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:08.779713Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:08.778959Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.9674e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:08.781242&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:08.751568&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def findMaxAverage(nums: list[int], k: int) -> float:
    sum_ = sum(nums[:k])
    max_avg = sum_ / k
    for i in range(k, len(nums)):
        sum_ = sum_ + nums[i] - nums[i - k]
        max_avg = max(max_avg, sum_ / k)

    return max_avg

# Testing the solution
assert findMaxAverage([1,12,-5,-6,50,3], 4) == 12.75
assert findMaxAverage([5], 1) == 5
```

</div>

<div id="7bcc5995" class="cell markdown"
papermill="{&quot;duration&quot;:2.1925e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:08.825382&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:08.803457&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Easy Leetcode Problem Link:
<https://leetcode.com/problems/average-of-levels-in-binary-tree/submissions/1228468053>

</div>

<div id="7efaf1c1" class="cell code" execution_count="36"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:08.870952Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:08.870297Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:08.876466Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:08.875694Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.0886e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:08.878293&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:08.847407&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def averageOfLevels(root: BinaryTreeNode) -> list[float]:
    result: list[float] = []
    queue: list[BinaryTreeNode] = [root]
    while queue:
        next_: list[BinaryTreeNode] = []
        sum_ = count_ = 0
        for curr in queue:
            sum_, count_ = sum_ + curr.val, count_ + 1
            if curr.left:
                next_.append(curr.left)
            if curr.right:
                next_.append(curr.right)
        result.append(sum_ / count_)
        queue = next_

    return result

# Testing the solution
assert averageOfLevels(BinaryTreeNode.from_array([3,9,20,None,None,15,7])) == [3.00,14.50,11.00]
```

</div>

<div id="6edc89e5" class="cell markdown"
papermill="{&quot;duration&quot;:2.2203e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:08.922840&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:08.900637&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Problem Link:
<https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree>

</div>

<div id="2f193894" class="cell code" execution_count="37"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:08.968713Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:08.968038Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:08.978912Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:08.978178Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.5617e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:08.980671&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:08.945054&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def distanceK(root: BinaryTreeNode, target: int, k: int) -> list[int]:
    adl: dict[int, set[int]] = dict()
    def createGraph(curr: BinaryTreeNode):
        nonlocal adl
        if curr:
            if curr.left:
                curr_neighbours = adl.get(curr.val, set())
                curr_neighbours.add(curr.left.val)
                adl[curr.val] = curr_neighbours
                left_neighbours = adl.get(curr.left.val, set())
                left_neighbours.add(curr.val)
                adl[curr.left.val] = left_neighbours
                createGraph(curr.left)
            if curr.right:
                curr_neighbours = adl.get(curr.val, set())
                curr_neighbours.add(curr.right.val)
                adl[curr.val] = curr_neighbours
                right_neighbours = adl.get(curr.right.val, set())
                right_neighbours.add(curr.val)
                adl[curr.right.val] = right_neighbours
                createGraph(curr.right)

    # Create a graph out of the binary Tree
    createGraph(root)

    # Starting from our target, find all nodes at K distance using BFS
    queue: list[int] = [target]
    visited: set[int] = set([target])
    while k > 0:
        next_: list[int] = []
        for curr in queue:
            for neighbour in adl.get(curr, set()):
                if neighbour not in visited:
                    visited.add(neighbour)
                    next_.append(neighbour)
        queue = next_
        k -= 1

    return queue

# Testing the solution
assert sorted(distanceK(BinaryTreeNode.from_array([3,5,1,6,2,0,8,None,None,7,4]), 5, 2)) == [1, 4, 7]
assert sorted(distanceK(BinaryTreeNode.from_array([3,5,1,6,2,0,8,None,None,7,4]), 4, 2)) == [5, 7]
```

</div>

<div id="29877a02" class="cell markdown"
papermill="{&quot;duration&quot;:2.1961e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:09.024875&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:09.002914&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Construct BT from Preorder and Inorder Problem Link:
<https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/submissions/1230345366>

</div>

<div id="7042888b" class="cell code" execution_count="38"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:09.070138Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:09.069521Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:09.078329Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:09.077536Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.3198e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:09.079939&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:09.046741&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def buildTreeFromPreOrder(inorder: list[int], preorder: list[int]) -> BinaryTreeNode|None:
    """
    Preorder: Root, Left, Right
    Inorder: Left, Root, Right

    Root based spliting.
    Use Preorder to determine which of the bunch is the root.
    Use inorder to determine which of the bunch goes to the left half and which right.
    """

    if not inorder:
        return None
    else:
        inorder_set = set(inorder)
        for root_val in preorder:
            if root_val in inorder_set:
                break

        root = BinaryTreeNode(root_val)
        if len(inorder) > 1:
            idx = inorder.index(root.val)
            left_inorder = inorder[:idx]
            root.left = buildTreeFromPreOrder(left_inorder, preorder)
            right_inorder = inorder[idx + 1:]
            root.right = buildTreeFromPreOrder(right_inorder, preorder)

        return root

# Testing the Solution
buildTreeFromPreOrder(inorder=[9,15,20,7], preorder=[3,9,20,15,7]).to_list()
```

<div class="output execute_result" execution_count="38">

    [9, None, 20, 15, 7]

</div>

</div>

<div id="2325a371" class="cell markdown"
papermill="{&quot;duration&quot;:2.2251e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:09.124573&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:09.102322&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Construct Binary Tree from Inorder and Postorder Traversal Problem Link:

</div>

<div id="c3a41642" class="cell code" execution_count="39"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:09.170486Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:09.169835Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:09.176634Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:09.175924Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.152e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:09.178270&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:09.146750&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def buildTreeFromPostOrder(inorder: list[int], postorder: list[int]) -> BinaryTreeNode|None:
    """
    Inorder: Root, Left, Right
    Postorder: Left, Right, Root

    Same as FromPreOrder, except that we always take the last element also present in inorder as our root.
    Simply reverse postorder and use the same function as before.
    """
    return buildTreeFromPreOrder(inorder=inorder, preorder=postorder[::-1])

# Testing the Solution
buildTreeFromPostOrder(inorder=[3, 2, 4, 1, 5], postorder=[3, 4, 2, 5, 1]).to_list()
```

<div class="output execute_result" execution_count="39">

    [1, 2, 5, 3, 4]

</div>

</div>

<div id="2e008839" class="cell markdown"
papermill="{&quot;duration&quot;:2.2128e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:09.222833&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:09.200705&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Medium Leetcode: <https://leetcode.com/problems/remove-k-digits>

</div>

<div id="cf7ab669" class="cell code" execution_count="40"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:09.268920Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:09.268325Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:09.276405Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:09.275753Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.2893e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:09.277982&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:09.245089&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Brute force solution
def removeKdigitsBrute(num: str, k: int) -> str:
    def removeDigit(curr: str) -> str:
        N = len(curr)
        for i in range(N):
            if i == N - 1 or num[i] > num[i + 1]:
                break

        return num[:i] + num[i + 1:]

    while k > 0:
        num = removeDigit(num)
        k -= 1

    num = num.lstrip("0")
    return "0" if not len(num) else num

# Testing the solution
removeKdigitsBrute("1432219", 1)
```

<div class="output execute_result" execution_count="40">

    '132219'

</div>

</div>

<div id="b073a96f" class="cell code" execution_count="41"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:09.324605Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:09.324006Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:09.366418Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:09.365657Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:6.7386e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:09.368080&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:09.300694&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Optimal solution after trial and errors: https://leetcode.com/problems/remove-k-digits/submissions/1231175827 
def removeKdigitsBetter(num: str, k: int) -> str:
    "Time: O(N), Space: O(N)"
    stack: list[str] = []
    for n in num:
        while stack and k > 0 and int(stack[-1]) > int(n):
            stack.pop()
            k -= 1
        stack.append(n)

    stack = stack[:-k] if k > 0 else stack
    num = "".join(stack).lstrip("0")
    num = num if num else "0"
    return num

# Testing the solution
for _ in tqdm.tqdm(range(1000)):
    N = random.randint(1, 25)
    i = random.randint(1, N)
    str_ = "".join(random.choices("0123456789", k=N))
    assert removeKdigitsBetter(str_, i) == removeKdigitsBrute(str_, i), f"failed for {str_}, {i}"
```

<div class="output stream stderr">

      0%|          | 0/1000 [00:00<?, ?it/s]

</div>

<div class="output stream stderr">

    100%|██████████| 1000/1000 [00:00<00:00, 34369.68it/s]

</div>

<div class="output stream stderr">

</div>

</div>

<div id="48a18c10" class="cell markdown"
papermill="{&quot;duration&quot;:2.2742e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:09.413848&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:09.391106&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Leetcode Weekly contest - Saturday (13th Apr)

</div>

<div id="07cf645f" class="cell code" execution_count="42"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:09.461435Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:09.460726Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:09.465336Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:09.464675Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.0306e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:09.467030&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:09.436724&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Q1 - Easy
def scoreOfString(s: str) -> int:
    N = len(s)
    result = 0
    for i in range(N - 1):
        result += abs(ord(s[i]) - ord(s[i + 1]))
    return result
```

</div>

<div id="3360d184" class="cell code" execution_count="43"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:09.514333Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:09.513779Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:09.519788Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:09.519145Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.1599e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:09.521565&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:09.489966&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Q2 - Medium
def minRectanglesToCoverPoints(points: list[list[int]], w: int) -> int:
    X = sorted(set(map(lambda x: x[0], points)))
    count = 0
    prev = -1
    for x in X:
        if prev == -1 or x - prev > w:
            count += 1
            prev = x

    return count

# Testing the solution
assert minRectanglesToCoverPoints([[0,0],[1,1],[2,2],[3,3],[4,4],[5,5],[6,6]], 2) == 3
assert minRectanglesToCoverPoints([[2,3],[1,2]], 0) == 2
```

</div>

<div id="91647588" class="cell markdown"
papermill="{&quot;duration&quot;:2.2867e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:09.567579&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:09.544712&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Binary Watch - Easy LC

</div>

<div id="3868d381" class="cell code" execution_count="44"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:09.615459Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:09.614794Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:09.625315Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:09.624563Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.6016e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:09.626982&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:09.590966&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/binary-watch/submissions/1231377431
def readBinaryWatch(turnedOn: int) -> list[str]:
    def getValue(code: str) -> tuple[int, int]:
        mapping = {
            "H8": (8, 0), "H4": (4, 0),
            "H2": (2, 0), "H1": (1, 0),

            "M32": (0, 32), "M16": (0, 16),
            "M8": (0, 8), "M4": (0, 4),
            "M2": (0, 2), "M1": (0, 1)
        }
        return mapping[code]

    leds: list[str] = ["H8", "H4", "H2", "H1", "M32", "M16", "M8", "M4", "M2", "M1"]
    possbilities = itertools.combinations(leds, r=turnedOn)

    result: list[str] = []
    for possb in possbilities:
        hour_ = min_ = 0
        for led in possb:
            H, M = getValue(led)
            hour_ += H
            min_ += M

        if 0 <= hour_ <= 11 and 0 <= min_ <= 59:
            result.append(f"{hour_}:{str(min_).zfill(2)}")

    return result

# Testing the solution
readBinaryWatch(1)
```

<div class="output execute_result" execution_count="44">

    ['8:00',
     '4:00',
     '2:00',
     '1:00',
     '0:32',
     '0:16',
     '0:08',
     '0:04',
     '0:02',
     '0:01']

</div>

</div>

<div id="1b69d7ad" class="cell markdown"
papermill="{&quot;duration&quot;:2.2934e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:09.673015&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:09.650081&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Valid Perfect Square:
<https://leetcode.com/problems/valid-perfect-square/submissions/1231389059>

</div>

<div id="97e2b8db" class="cell code" execution_count="45"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:09.720019Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:09.719498Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:09.724648Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:09.723932Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.0359e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:09.726228&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:09.695869&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def isPerfectSquare(num: int) -> bool:
    low, high = 0, num
    while low <= high:
        mid = (low + high) // 2
        square = mid * mid
        if square == num:
            return True
        elif square < num:
            low = mid + 1
        else:
            high = mid - 1

    return False

# Testing the solution
assert isPerfectSquare(16) == True
assert isPerfectSquare(3) == False
```

</div>

<div id="54962282" class="cell markdown"
papermill="{&quot;duration&quot;:2.2866e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:09.772193&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:09.749327&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Range sum query:
<https://leetcode.com/problems/range-sum-query-immutable/submissions/1231398800>

</div>

<div id="c95f87dd" class="cell code" execution_count="46"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:09.819533Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:09.819230Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:09.825124Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:09.824483Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.1442e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:09.826735&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:09.795293&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
class NumArray:
    def __init__(self, nums: list[int]):
        self.nums = nums
        self.cumsum = list(itertools.accumulate(nums, lambda x, y: x + y))

    def sumRange(self, left: int, right: int) -> int:
        result = self.cumsum[right]
        if left > 0:
            result -= self.cumsum[left - 1]
        return result

# Testing the Solution
obj = NumArray([-2, 0, 3, -5, 2, -1])
assert obj.sumRange(0, 2) == 1
assert obj.sumRange(2, 5) == -1
```

</div>

<div id="bd8e8248" class="cell markdown"
papermill="{&quot;duration&quot;:2.2685e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:09.872541&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:09.849856&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Cows and bulls:
<https://leetcode.com/problems/bulls-and-cows/submissions/1231417724>

</div>

<div id="264c9ee0" class="cell code" execution_count="47"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:09.919798Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:09.919252Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:09.925047Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:09.924376Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.1126e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:09.926727&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:09.895601&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def getHint(secret: str, guess: str) -> str:
    N = len(guess)
    secret_freq = collections.Counter(secret)
    guess_freq = collections.Counter(guess)
    cows = bulls = 0
    for i in range(N):
        if guess[i] == secret[i]:
            bulls += 1
            secret_freq[guess[i]] -= 1
            guess_freq[guess[i]] -= 1

    for k in guess_freq:
        cows += min(guess_freq[k], secret_freq.get(k, 0))

    return f"{bulls}A{cows}B"

# Testing the solution
assert getHint("1122", "1222") == "3A0B"
```

</div>

<div id="6bbf3690" class="cell markdown"
papermill="{&quot;duration&quot;:2.3003e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:09.973869&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:09.950866&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Weekly LC - Sunday: 14th April, 2024

</div>

<div id="1254e925" class="cell code" execution_count="48"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:10.021245Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:10.021003Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:10.029013Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:10.028252Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.3807e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:10.030732&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:09.996925&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Q1 - Easy
def findLatestTime(s: str) -> str:
    result = []
    for i in range(5):
        if s[i] == '?':
            if i == 0:
                result.append('0' if s[1].isdigit() and int(s[1]) > 1 else '1')
            elif i == 1:
                result.append('1' if result[0] == '1' else '9')
            elif i == 3:
                result.append('5')
            else:
                result.append('9')
        else:
            result.append(s[i])

    return ''.join(result)

# Testing the solution
findLatestTime("?2:3?")
```

<div class="output execute_result" execution_count="48">

    '02:39'

</div>

</div>

<div id="7e9a187d" class="cell code" execution_count="49"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:10.078894Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:10.078220Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:10.084382Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:10.083641Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.2084e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:10.086245&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:10.054161&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Q2 - Medium
def maximumPrimeDifference(nums: list[int]) -> int:
    primes = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97}

    N = len(nums)
    for i in range(N):
        if nums[i] in primes:
            break

    for j in range(N - 1, -1, -1):
        if nums[j] in primes:
            break

    return j - i

# Testing the solution
assert maximumPrimeDifference([4,2,9,5,3]) == 3
assert maximumPrimeDifference([4,8,2,8]) == 0
```

</div>

<div id="1d6959ea" class="cell code" execution_count="50"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:10.134393Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:10.133628Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:31.102165Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:31.101364Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:20.994335,&quot;end_time&quot;:&quot;2024-04-21T15:47:31.103902&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:10.109567&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Q3 - Hard
def findKthSmallestBrute(coins: list[int], k: int) -> int:
    curr = min(coins)
    while True:
        for coin in coins:
            if curr % coin == 0:
                k -= 1
                break

        if k == 0:
            return curr
        else:
            curr += 1

    return -1

# Testing the solution
assert findKthSmallestBrute([3,6,9], 3) == 9
assert findKthSmallestBrute([5,2], 7) == 12

# Q3 - Hard Better (Solved this post the test, proud moment since the acceptance rate was 3%!
# Leetcode Writeup: https://leetcode.com/problems/kth-smallest-amount-with-single-denomination-combination/solutions/5020415/binary-search-solution-python
def findKthSmallest(coins: list[int], k: int) -> int:
    N = len(coins)

    def count(num: int) -> int:
        """
        Given num, find k_ (position after set union and sorting)
        For eg:
            num = 20, coins = [2, 5]
            => [2, 4, 5, 6, 8, 10, 12, 14, 15, 16, 18, 20]
            => 12

        Logic:
            Assume we only had coin 2 available, 20's position would then be 20 // 2 = 10.
            We however have other denominations, so find count for each denomination.
            This way we would introduce duplicates - 10 would be counted twice.
            To avoid this we use formula: count(A | B) = count(A) + count(B) - count(A & B) extended for arbitrary length (A, B, C, ..)
        """
        total, add_ = 0, True

        for i in range(1, N + 1):
            curr = 0
            for comb in itertools.combinations(coins, r=i):
                curr += num // math.lcm(*comb)
            total = total + curr if add_ else total - curr
            add_ = not add_

        return total

    # Use a simple binary search
    # max => lowest denomination * k. The result must be lesser than this.
    low = min(coins)
    high = low * k
    while low <= high:
        mid = (low + high) // 2
        k_ = count(mid)
        if k_ < k:
            low = mid + 1
        else:
            high = mid - 1

    return low

# Testing the solution
for i in tqdm.tqdm(range(1, 100)):
    temp = list(range(11, 26))
    assert findKthSmallest(temp, i) == findKthSmallestBrute(temp, i)
```

<div class="output stream stderr">

      0%|          | 0/99 [00:00<?, ?it/s]

</div>

<div class="output stream stderr">

      2%|▏         | 2/99 [00:00<00:05, 16.35it/s]

</div>

<div class="output stream stderr">

      4%|▍         | 4/99 [00:00<00:09, 10.24it/s]

</div>

<div class="output stream stderr">

      6%|▌         | 6/99 [00:00<00:11,  8.30it/s]

</div>

<div class="output stream stderr">

      7%|▋         | 7/99 [00:00<00:11,  7.86it/s]

</div>

<div class="output stream stderr">

      8%|▊         | 8/99 [00:00<00:12,  7.19it/s]

</div>

<div class="output stream stderr">

      9%|▉         | 9/99 [00:01<00:12,  7.05it/s]

</div>

<div class="output stream stderr">

     10%|█         | 10/99 [00:01<00:12,  6.94it/s]

</div>

<div class="output stream stderr">

     11%|█         | 11/99 [00:01<00:13,  6.56it/s]

</div>

<div class="output stream stderr">

     12%|█▏        | 12/99 [00:01<00:13,  6.32it/s]

</div>

<div class="output stream stderr">

     13%|█▎        | 13/99 [00:01<00:13,  6.15it/s]

</div>

<div class="output stream stderr">

     14%|█▍        | 14/99 [00:01<00:14,  6.01it/s]

</div>

<div class="output stream stderr">

     15%|█▌        | 15/99 [00:02<00:14,  5.94it/s]

</div>

<div class="output stream stderr">

     16%|█▌        | 16/99 [00:02<00:14,  5.89it/s]

</div>

<div class="output stream stderr">

     17%|█▋        | 17/99 [00:02<00:14,  5.62it/s]

</div>

<div class="output stream stderr">

     18%|█▊        | 18/99 [00:02<00:14,  5.43it/s]

</div>

<div class="output stream stderr">

     19%|█▉        | 19/99 [00:02<00:15,  5.33it/s]

</div>

<div class="output stream stderr">

     20%|██        | 20/99 [00:03<00:15,  5.25it/s]

</div>

<div class="output stream stderr">

     21%|██        | 21/99 [00:03<00:15,  5.19it/s]

</div>

<div class="output stream stderr">

     22%|██▏       | 22/99 [00:03<00:15,  4.94it/s]

</div>

<div class="output stream stderr">

     23%|██▎       | 23/99 [00:03<00:15,  4.97it/s]

</div>

<div class="output stream stderr">

     24%|██▍       | 24/99 [00:03<00:15,  4.99it/s]

</div>

<div class="output stream stderr">

     25%|██▌       | 25/99 [00:04<00:14,  5.01it/s]

</div>

<div class="output stream stderr">

     26%|██▋       | 26/99 [00:04<00:14,  5.04it/s]

</div>

<div class="output stream stderr">

     27%|██▋       | 27/99 [00:04<00:14,  5.05it/s]

</div>

<div class="output stream stderr">

     28%|██▊       | 28/99 [00:04<00:14,  4.98it/s]

</div>

<div class="output stream stderr">

     29%|██▉       | 29/99 [00:04<00:13,  5.01it/s]

</div>

<div class="output stream stderr">

     30%|███       | 30/99 [00:05<00:13,  5.04it/s]

</div>

<div class="output stream stderr">

     31%|███▏      | 31/99 [00:05<00:13,  4.87it/s]

</div>

<div class="output stream stderr">

     32%|███▏      | 32/99 [00:05<00:14,  4.76it/s]

</div>

<div class="output stream stderr">

     33%|███▎      | 33/99 [00:05<00:13,  4.86it/s]

</div>

<div class="output stream stderr">

     34%|███▍      | 34/99 [00:05<00:13,  4.75it/s]

</div>

<div class="output stream stderr">

     35%|███▌      | 35/99 [00:06<00:13,  4.85it/s]

</div>

<div class="output stream stderr">

     36%|███▋      | 36/99 [00:06<00:12,  4.92it/s]

</div>

<div class="output stream stderr">

     37%|███▋      | 37/99 [00:06<00:12,  4.80it/s]

</div>

<div class="output stream stderr">

     38%|███▊      | 38/99 [00:06<00:12,  4.72it/s]

</div>

<div class="output stream stderr">

     39%|███▉      | 39/99 [00:07<00:12,  4.82it/s]

</div>

<div class="output stream stderr">

     40%|████      | 40/99 [00:07<00:12,  4.89it/s]

</div>

<div class="output stream stderr">

     41%|████▏     | 41/99 [00:07<00:12,  4.78it/s]

</div>

<div class="output stream stderr">

     42%|████▏     | 42/99 [00:07<00:12,  4.69it/s]

</div>

<div class="output stream stderr">

     43%|████▎     | 43/99 [00:07<00:12,  4.63it/s]

</div>

<div class="output stream stderr">

     44%|████▍     | 44/99 [00:08<00:11,  4.59it/s]

</div>

<div class="output stream stderr">

     45%|████▌     | 45/99 [00:08<00:11,  4.57it/s]

</div>

<div class="output stream stderr">

     46%|████▋     | 46/99 [00:08<00:11,  4.55it/s]

</div>

<div class="output stream stderr">

     47%|████▋     | 47/99 [00:08<00:11,  4.54it/s]

</div>

<div class="output stream stderr">

     48%|████▊     | 48/99 [00:08<00:11,  4.52it/s]

</div>

<div class="output stream stderr">

     49%|████▉     | 49/99 [00:09<00:11,  4.52it/s]

</div>

<div class="output stream stderr">

     51%|█████     | 50/99 [00:09<00:10,  4.52it/s]

</div>

<div class="output stream stderr">

     52%|█████▏    | 51/99 [00:09<00:10,  4.52it/s]

</div>

<div class="output stream stderr">

     53%|█████▎    | 52/99 [00:09<00:10,  4.50it/s]

</div>

<div class="output stream stderr">

     54%|█████▎    | 53/99 [00:10<00:10,  4.51it/s]

</div>

<div class="output stream stderr">

     55%|█████▍    | 54/99 [00:10<00:09,  4.51it/s]

</div>

<div class="output stream stderr">

     56%|█████▌    | 55/99 [00:10<00:09,  4.51it/s]

</div>

<div class="output stream stderr">

     57%|█████▋    | 56/99 [00:10<00:09,  4.51it/s]

</div>

<div class="output stream stderr">

     58%|█████▊    | 57/99 [00:10<00:09,  4.51it/s]

</div>

<div class="output stream stderr">

     59%|█████▊    | 58/99 [00:11<00:09,  4.51it/s]

</div>

<div class="output stream stderr">

     60%|█████▉    | 59/99 [00:11<00:08,  4.51it/s]

</div>

<div class="output stream stderr">

     61%|██████    | 60/99 [00:11<00:08,  4.51it/s]

</div>

<div class="output stream stderr">

     62%|██████▏   | 61/99 [00:11<00:08,  4.51it/s]

</div>

<div class="output stream stderr">

     63%|██████▎   | 62/99 [00:12<00:08,  4.51it/s]

</div>

<div class="output stream stderr">

     64%|██████▎   | 63/99 [00:12<00:07,  4.50it/s]

</div>

<div class="output stream stderr">

     65%|██████▍   | 64/99 [00:12<00:07,  4.50it/s]

</div>

<div class="output stream stderr">

     66%|██████▌   | 65/99 [00:12<00:07,  4.36it/s]

</div>

<div class="output stream stderr">

     67%|██████▋   | 66/99 [00:13<00:07,  4.39it/s]

</div>

<div class="output stream stderr">

     68%|██████▊   | 67/99 [00:13<00:07,  4.42it/s]

</div>

<div class="output stream stderr">

     69%|██████▊   | 68/99 [00:13<00:07,  4.31it/s]

</div>

<div class="output stream stderr">

     70%|██████▉   | 69/99 [00:13<00:07,  4.23it/s]

</div>

<div class="output stream stderr">

     71%|███████   | 70/99 [00:13<00:06,  4.18it/s]

</div>

<div class="output stream stderr">

     72%|███████▏  | 71/99 [00:14<00:06,  4.15it/s]

</div>

<div class="output stream stderr">

     73%|███████▎  | 72/99 [00:14<00:06,  4.13it/s]

</div>

<div class="output stream stderr">

     74%|███████▎  | 73/99 [00:14<00:06,  4.11it/s]

</div>

<div class="output stream stderr">

     75%|███████▍  | 74/99 [00:14<00:06,  4.08it/s]

</div>

<div class="output stream stderr">

     76%|███████▌  | 75/99 [00:15<00:05,  4.20it/s]

</div>

<div class="output stream stderr">

     77%|███████▋  | 76/99 [00:15<00:05,  4.29it/s]

</div>

<div class="output stream stderr">

     78%|███████▊  | 77/99 [00:15<00:05,  4.36it/s]

</div>

<div class="output stream stderr">

     79%|███████▉  | 78/99 [00:15<00:04,  4.41it/s]

</div>

<div class="output stream stderr">

     80%|███████▉  | 79/99 [00:16<00:04,  4.30it/s]

</div>

<div class="output stream stderr">

     81%|████████  | 80/99 [00:16<00:04,  4.23it/s]

</div>

<div class="output stream stderr">

     82%|████████▏ | 81/99 [00:16<00:04,  4.18it/s]

</div>

<div class="output stream stderr">

     83%|████████▎ | 82/99 [00:16<00:03,  4.28it/s]

</div>

<div class="output stream stderr">

     84%|████████▍ | 83/99 [00:17<00:03,  4.33it/s]

</div>

<div class="output stream stderr">

     85%|████████▍ | 84/99 [00:17<00:03,  4.25it/s]

</div>

<div class="output stream stderr">

     86%|████████▌ | 85/99 [00:17<00:03,  4.20it/s]

</div>

<div class="output stream stderr">

     87%|████████▋ | 86/99 [00:17<00:03,  4.16it/s]

</div>

<div class="output stream stderr">

     88%|████████▊ | 87/99 [00:18<00:02,  4.13it/s]

</div>

<div class="output stream stderr">

     89%|████████▉ | 88/99 [00:18<00:02,  4.12it/s]

</div>

<div class="output stream stderr">

     90%|████████▉ | 89/99 [00:18<00:02,  4.11it/s]

</div>

<div class="output stream stderr">

     91%|█████████ | 90/99 [00:18<00:02,  4.10it/s]

</div>

<div class="output stream stderr">

     92%|█████████▏| 91/99 [00:18<00:01,  4.07it/s]

</div>

<div class="output stream stderr">

     93%|█████████▎| 92/99 [00:19<00:01,  4.08it/s]

</div>

<div class="output stream stderr">

     94%|█████████▍| 93/99 [00:19<00:01,  4.08it/s]

</div>

<div class="output stream stderr">

     95%|█████████▍| 94/99 [00:19<00:01,  4.08it/s]

</div>

<div class="output stream stderr">

     96%|█████████▌| 95/99 [00:19<00:00,  4.07it/s]

</div>

<div class="output stream stderr">

     97%|█████████▋| 96/99 [00:20<00:00,  4.07it/s]

</div>

<div class="output stream stderr">

     98%|█████████▊| 97/99 [00:20<00:00,  4.07it/s]

</div>

<div class="output stream stderr">

     99%|█████████▉| 98/99 [00:20<00:00,  4.07it/s]

</div>

<div class="output stream stderr">

    100%|██████████| 99/99 [00:20<00:00,  4.05it/s]

</div>

<div class="output stream stderr">

    100%|██████████| 99/99 [00:20<00:00,  4.72it/s]

</div>

<div class="output stream stderr">

</div>

</div>

<div id="a4add1b8" class="cell markdown"
papermill="{&quot;duration&quot;:3.0272e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:31.165570&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:31.135298&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Sum of left leaves Problem Link:
<https://leetcode.com/problems/sum-of-left-leaves/submissions/1232098618>

</div>

<div id="08f2ccb4" class="cell code" execution_count="51"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:31.227738Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:31.227019Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:31.232116Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:31.231386Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.7853e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:31.233722&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:31.195869&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def sumOfLeftLeaves(root: BinaryTreeNode, left: bool = True) -> int:
    if not root:
        return 0
    elif not root.left and not root.right:
        return root.val if left else 0
    else:
        return sumOfLeftLeaves(root.left, True) + sumOfLeftLeaves(root.right, False)
```

</div>

<div id="0222f378" class="cell markdown"
papermill="{&quot;duration&quot;:3.0206e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:31.294763&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:31.264557&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Minimum element in BST

</div>

<div id="2268cda1" class="cell code" execution_count="52"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:31.357404Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:31.356766Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:31.361121Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:31.360411Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.727e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:31.362760&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:31.325490&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def minValue(root: BinaryTreeNode) -> int:
    "Time Complexity: O(N)"
    curr: BinaryTreeNode = root
    while curr and curr.left:
        curr = curr.left

    return curr.val if curr else -1
```

</div>

<div id="205a41bc" class="cell markdown"
papermill="{&quot;duration&quot;:3.0217e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:31.423880&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:31.393663&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Floor from BST

</div>

<div id="b4b9c2fe" class="cell code" execution_count="53"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:31.485637Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:31.485073Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:31.492227Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:31.491450Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.9902e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:31.493876&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:31.453974&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Read input as specified in the question
# target, *nums = list(map(lambda x: int(x) if x != '-1' else None, input().split()))
target, nums = 11, [5, 2, 9, 1, 3, 6, 10]
k: float = -1
queue: list[BinaryTreeNode] = []
for num in nums:
    curr = BinaryTreeNode(num) if num else None
    if curr:
        queue.append(curr)
    if k == -1:
        k += 1
    elif int(k) == k:
        queue[int(k)].left = curr
        k += 0.5
    else:
        queue[int(k)].right = curr
        k += 0.5

queue[0].to_list()

# Find the floor of the number
curr, floor = queue[0], -1
while curr:
    if curr.val <= target:
        floor = curr.val
        curr = curr.right
    else:
        curr = curr.left

print(floor)
```

<div class="output stream stdout">

    10

</div>

</div>

<div id="19c4167d" class="cell markdown"
papermill="{&quot;duration&quot;:3.0438e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:31.555065&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:31.524627&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Insert into a BST

</div>

<div id="246602ef" class="cell code" execution_count="54"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:31.618517Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:31.617845Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:31.623467Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:31.622712Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.9504e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:31.625114&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:31.585610&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def insertIntoBST(root: BinaryTreeNode, val: int) -> BinaryTreeNode:
    if not root:
        root = BinaryTreeNode(val)
    elif root.val < val:
        root.right = insertIntoBST(root.right, val)
    else:
        root.left = insertIntoBST(root.left, val)

    return root

# Testing the solution
assert insertIntoBST(BinaryTreeNode.from_array([4,2,7,1,3]), 5).to_list() == [4,2,7,1,3,5]
```

</div>

<div id="245f9178" class="cell markdown"
papermill="{&quot;duration&quot;:3.0527e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:31.686378&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:31.655851&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

LCA in a BST of two nodes:
<https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/submissions/1234964550>

</div>

<div id="5f723be8" class="cell code" execution_count="55"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:31.748761Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:31.748095Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:31.754892Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:31.754152Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.9764e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:31.756546&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:31.716782&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def lowestCommonAncestor(root: BinaryTreeNode, p: BinaryTreeNode, q: BinaryTreeNode) -> BinaryTreeNode:
    """
    If root equals p/q or if p < root < q that is our LCA. Otherwise traverse left of right.
    Time: O(log N), Space: O(1)
    """

    low = p if p.val < q.val else q
    high = q if p.val < q.val else p

    if root.val == low.val or root.val == high.val or low.val < root.val < high.val:
        return root
    elif root.val > p.val and root.val > q.val:
        return lowestCommonAncestor(root.left, p, q)
    else:
        return lowestCommonAncestor(root.right, p, q)

# Testing the solution
temp: BinaryTreeNode = BinaryTreeNode.from_array([6,2,8,0,4,7,9,None,None,3,5])
assert lowestCommonAncestor(temp, p=temp.left, q=temp.right).val == 6
```

</div>

<div id="591d92a4" class="cell markdown"
papermill="{&quot;duration&quot;:3.0519e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:31.817900&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:31.787381&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Smallest string starting from leaf:
<https://leetcode.com/problems/smallest-string-starting-from-leaf/submissions/1235018957>

</div>

<div id="654f9b3f" class="cell code" execution_count="56"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:31.880118Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:31.879369Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:31.886854Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:31.886231Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:4.0251e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:31.888484&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:31.848233&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def smallestFromLeaf(root: BinaryTreeNode) -> str:
    result: str = chr(ord('z') + 1)
    def backtrack(curr: BinaryTreeNode, acc: str = ""):
        if curr:
            acc_ = chr(curr.val + ord('a')) + acc
            if not curr.left and not curr.right:
                nonlocal result
                result = min(result, acc_)
            else:
                backtrack(curr.left, acc_)
                backtrack(curr.right, acc_)

    backtrack(root)
    return result

# Testing the solution
assert smallestFromLeaf(BinaryTreeNode.from_array([25,1,3,1,3,0,2])) == "adz"
assert smallestFromLeaf(BinaryTreeNode.from_array([2,2,1,None,1,0,None,0])) == "abc"
assert smallestFromLeaf(BinaryTreeNode.from_array([4,0,1,1])) == "bae"
assert smallestFromLeaf(BinaryTreeNode.from_array([25,1,None,0,0,1,None,None,None,0])) == "ababz"
```

</div>

<div id="0938e6bc" class="cell markdown"
papermill="{&quot;duration&quot;:3.0349e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:31.949490&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:31.919141&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Island Permeter:
<https://leetcode.com/problems/island-perimeter/submissions/1235424369/>

</div>

<div id="003c3125" class="cell code" execution_count="57"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:32.011846Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:32.011281Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:32.017850Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:32.017112Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.9614e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:32.019541&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:31.979927&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def islandPerimeter(grid: list[list[int]]) -> int:
    "Time: O(MN), Space: O(1)"
    N, M = len(grid), len(grid[0])
    perimeter: int = 0
    for i in range(N):
        for j in range(M):
            if grid[i][j] == 1:
                perimeter += i == 0 or grid[i - 1][j] == 0
                perimeter += j == 0 or grid[i][j - 1] == 0
                perimeter += i == N - 1 or grid[i + 1][j] == 0
                perimeter += j == M - 1 or grid[i][j + 1] == 0

    return perimeter

# Testing the Solution
assert islandPerimeter([[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]) == 16
```

</div>

<div id="c9452394" class="cell markdown"
papermill="{&quot;duration&quot;:3.3915e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:32.084134&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:32.050219&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Predecessor And Successor In BST

</div>

<div id="88e2210d" class="cell code" execution_count="58"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:32.146850Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:32.146341Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:32.156048Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:32.155422Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:4.2926e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:32.157651&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:32.114725&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def predecessorSuccessorBrute(root: BinaryTreeNode, key: int):
    "Time: O(N), Space: O(N)"
    inorder: list[int] = []
    stack: list[BinaryTreeNode] = []
    curr = root
    while stack or curr:
        if curr:
            stack.append(curr)
            curr = curr.left
        else:
            curr = stack.pop()
            inorder.append(curr.val)
            curr = curr.right

    # Find the Idx where the element can go, it may or may not exist.
    inorder = [-1, *inorder, -1]
    N = len(inorder)
    low, high = 1, N - 2
    while low <= high:
        idx = (low + high) // 2
        if inorder[idx] == key:
            return inorder[idx - 1], inorder[idx + 1]
        if inorder[idx] < key:
            low = idx + 1
        else:
            high = idx - 1
    else:
        return inorder[low - 1], inorder[low]

# Testing the solution
assert predecessorSuccessorBrute(BinaryTreeNode.from_array([2, 1, 3]), 2) == (1, 3)
assert predecessorSuccessorBrute(BinaryTreeNode.from_array([2, 1, 3]), 1) == (-1, 2)
assert predecessorSuccessorBrute(BinaryTreeNode.from_array([2, 1, 3]), 3) == (2, -1)
assert predecessorSuccessorBrute(BinaryTreeNode.from_array([2, 1, 3]), 4) == (3, -1)
assert predecessorSuccessorBrute(BinaryTreeNode.from_array([2, 1, 3]), 0) == (-1, 1)
assert predecessorSuccessorBrute(BinaryTreeNode.from_array([2, 0, 3]), 1) == (0, 2)
```

</div>

<div id="2b775761" class="cell markdown"
papermill="{&quot;duration&quot;:3.0303e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:32.218500&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:32.188197&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Binary Search Tree Iterator:
<https://leetcode.com/problems/binary-search-tree-iterator/submissions/1235796453>

</div>

<div id="8b544b45" class="cell code" execution_count="59"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:32.280495Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:32.279919Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:32.288109Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:32.287345Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:4.1018e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:32.289779&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:32.248761&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
class BSTIterator:
        def __init__(self, root: BinaryTreeNode):

            # Logic to find the max of BST
            self.max_ = -1
            curr = root
            while curr:
                self.max_ = curr.val
                curr = curr.right

            self.generator = BSTIterator.inorder(root)
            self.prev = -1

        @staticmethod
        def inorder(curr: BinaryTreeNode) -> Generator[int, None, None]:
            if not curr:
                yield -1
            else:
                yield from BSTIterator.inorder(curr.left)
                yield curr.val
                yield from BSTIterator.inorder(curr.right)

        def next(self) -> int:
            curr = -1
            while curr == -1:
                curr = next(self.generator)

            self.prev = curr
            return curr

        def hasNext(self) -> bool:
            return self.prev < self.max_

# Testing the solution
bstIter = BSTIterator(BinaryTreeNode.from_array([7,3,15,None,None,9,20]))
temp: list[int] = []
while bstIter.hasNext():
    temp.append(bstIter.next())

assert temp == [3, 7, 9, 15, 20]
```

</div>

<div id="b746cac5" class="cell markdown"
papermill="{&quot;duration&quot;:3.0456e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:32.350989&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:32.320533&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Problem Link:
<https://leetcode.com/problems/recover-binary-search-tree/submissions/1236357794/>

</div>

<div id="417a1ab3" class="cell code" execution_count="60"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:32.413099Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:32.412814Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:32.435644Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:32.435025Z&quot;}"
papermill="{&quot;duration&quot;:5.5807e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:32.437353&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:32.381546&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def recoverTree(root: BinaryTreeNode) -> None:
    "Time: O(N), Space: O(1)"
    stack: list[BinaryTreeNode] = []

    prev: BinaryTreeNode|None = None
    curr: BinaryTreeNode|None = root
    swap1: BinaryTreeNode|None = None
    swap2: BinaryTreeNode|None = None

    while curr or stack:
        if curr:
            stack.append(curr)
            curr = curr.left
        else:
            curr = stack.pop()
            if not swap1 and prev and curr.val < prev.val:
                swap1 = prev
            elif not swap2 and swap1 and curr.val > swap1.val:
                swap2 = prev
                break

            prev, curr = curr, curr.right

    if not swap2:
        swap2 = prev

    # Swap the values of the two pointers
    if swap1 and swap2:
        swap1.val, swap2.val = swap2.val, swap1.val

for i in range(3, 50):
    original = generateBST(i, 1, 100).to_list()
    copy = [*original]
    j_, k_ = np.random.choice(range(i), 2, replace=False)
    while not copy[j_] or not copy[k_]:
        j_, k_ = np.random.choice(range(i), 2, replace=False)
    copy[j_], copy[k_] = copy[k_], copy[j_]
    bst = BinaryTreeNode.from_array(copy)
    recoverTree(bst)
    assert bst.to_list() == original
```

</div>

<div id="4ea8e86e" class="cell markdown"
papermill="{&quot;duration&quot;:3.0454e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:32.498541&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:32.468087&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Problem link:
<https://leetcode.com/problems/rising-temperature/description/>

</div>

<div id="2e5cf08b" class="cell code" execution_count="61"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:32.561020Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:32.560419Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:32.573836Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:32.573185Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:4.6607e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:32.575500&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:32.528893&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
import datetime as dt
def rising_temperature_pandas(weather: pd.DataFrame) -> pd.DataFrame:
    records = dict(zip(weather['recordDate'], weather['temperature']))
    results: list[str] = []

    for row in weather.itertuples():
        prevDay = row[2] - dt.timedelta(days=1)
        if records.get(prevDay, math.inf) < row[3]:
            results.append(row[1])

    return pd.DataFrame(data=results, columns=['id'])

# Testing the solution
temp = read_lc_df("""
+----+------------+-------------+
| id | recordDate | temperature |
| -- | ---------- | ----------- |
| 1  | 2000-12-14 | 3           |
| 2  | 2000-12-16 | 5           |
+----+------------+-------------+
""", dtypes={'recordDate': 'datetime64[ns]', 'temperature': 'float'})

# temp['temperature'] = temp['temperature'].astype(float)
# temp['recordDate'] = pd.to_datetime(temp['recordDate'])
assert rising_temperature_pandas(temp)['id'].to_list() == []
```

</div>

<div id="42548d2d" class="cell markdown"
papermill="{&quot;duration&quot;:3.1169e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:32.637516&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:32.606347&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Merge two BST: <https://leetcode.com/problems/merge-two-binary-trees/>

</div>

<div id="af67741c" class="cell code" execution_count="62"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:32.699754Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:32.699178Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:32.704976Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:32.704244Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.8792e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:32.706664&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:32.667872&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def mergeTrees(root1: BinaryTreeNode, root2: BinaryTreeNode) -> BinaryTreeNode:
    if not root1:
        return root2
    elif not root2:
        return root1
    else:
        curr = BinaryTreeNode(root1.val + root2.val)
        curr.left = mergeTrees(root1.left, root2.left)
        curr.right = mergeTrees(root1.right, root2.right)
        return curr

# Testing the solution
assert mergeTrees(BinaryTreeNode.from_array([1,3,2,5]), BinaryTreeNode.from_array([2,1,3,None,4,None,7])).to_list() == [3,4,5,5,4,None,7]
```

</div>

<div id="1dcb94b1" class="cell markdown"
papermill="{&quot;duration&quot;:3.0424e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:32.767615&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:32.737191&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

LC Easy: Find if path exists in Graph
<https://leetcode.com/problems/find-if-path-exists-in-graph/submissions/1238132630>

</div>

<div id="98a5c5b3" class="cell code" execution_count="63"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-21T15:47:32.829729Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-21T15:47:32.829078Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-21T15:47:32.837133Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-21T15:47:32.836504Z&quot;}"
papermill="{&quot;duration&quot;:4.0858e-2,&quot;end_time&quot;:&quot;2024-04-21T15:47:32.838770&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-21T15:47:32.797912&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def validPath(n: int, edges: list[list[int]], source: int, destination: int) -> bool:
    adjl: dict[int, list[int]] = dict()

    def DFS(src: int) -> bool:
        if src == destination:
            return True

        elif src not in visited:
            visited.add(src)
            for next_ in adjl.get(src, []):
                if DFS(next_):
                    return True

        return False

    # Convert to Adjancency list
    for n1, n2 in edges:
        n1_neighbours, n2_neighbours = adjl.get(n1, []), adjl.get(n2, [])
        n1_neighbours.append(n2)
        n2_neighbours.append(n1)
        adjl[n1], adjl[n2] = n1_neighbours, n2_neighbours

    # Do a DFS to check if reachable
    visited: set[int] = set()
    return DFS(source)

# Testing the solution
assert validPath(3, [[0,1],[1,2],[2,0]], 0, 2) == True
assert validPath(6, [[0,1],[0,2],[3,5],[5,4],[4,3]], 0, 5) == False
```

</div>
