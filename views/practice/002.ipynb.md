---
jupyter:
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
  language_info:
    codemirror_mode:
      name: ipython
      version: 3
    file_extension: .py
    mimetype: text/x-python
    name: python
    nbconvert_exporter: python
    pygments_lexer: ipython3
    version: 3.10.14
  nbformat: 4
  nbformat_minor: 5
  papermill:
    default_parameters: {}
    duration: 2.481514
    end_time: "2024-04-30T02:45:38.471848"
    environment_variables: {}
    input_path: practice/002.ipynb
    output_path: practice/002.ipynb
    parameters: {}
    start_time: "2024-04-30T02:45:35.990334"
    version: 2.5.0
---

<div id="337a233c" class="cell code" execution_count="1"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-30T02:45:37.047202Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-30T02:45:37.046872Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-30T02:45:37.559286Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-30T02:45:37.558553Z&quot;}"
papermill="{&quot;duration&quot;:0.524136,&quot;end_time&quot;:&quot;2024-04-30T02:45:37.561325&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:37.037189&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
from typing import List, Optional, Generator
import pandas as pd
import numpy as np
import sqlite3
import re
import io
import math
import collections
import itertools
import functools
import random
import string
import tqdm
import bisect
import heapq

conn = sqlite3.connect(":memory:")

def regexp(expr, item):
    reg = re.compile(expr)
    return reg.search(item) is not None

def read_lc_df(s: str, dtypes: dict[str, str]=dict()) -> pd.DataFrame:
    temp = pd.read_csv(io.StringIO(s), sep="|", skiprows=2)
    temp = temp.iloc[1:-1, 1:-1]
    temp.columns = temp.columns.map(str.strip)
    temp = temp.map(lambda x: x if type(x) != str else None if x.strip() == 'null' else x.strip())
    temp = temp.astype(dtypes)
    return temp

conn.create_function("REGEXP", 2, regexp)
```

</div>

<div id="a97299f5" class="cell markdown"
papermill="{&quot;duration&quot;:7.849e-3,&quot;end_time&quot;:&quot;2024-04-30T02:45:37.577166&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:37.569317&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

#### Helper for Binary tree problems

</div>

<div id="e9415fef" class="cell code" execution_count="2"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-30T02:45:37.593500Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-30T02:45:37.592794Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-30T02:45:37.602847Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-30T02:45:37.602095Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.0038e-2,&quot;end_time&quot;:&quot;2024-04-30T02:45:37.604563&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:37.584525&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
class BinaryTreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

    def to_list(self):
        to_visit = [self]
        visited = []
        while len(to_visit) > 0:
            curr = to_visit.pop(0)
            if curr:
                to_visit.append(curr.left)
                to_visit.append(curr.right)
                visited.append(curr.val)
            else:
                visited.append(curr)

        while visited and not visited[-1]:
            visited.pop()

        return visited

    def __str__(self):
        return str(self.val)

    @staticmethod
    def from_array(nums: list[int|None]):
        '''Create a Tree from a list of nums. Returns the root node.'''
        if len(nums) == 0:
            return None
        elif len(nums) == 1:
            return BinaryTreeNode(nums[0])
        else:
            forest = [BinaryTreeNode(nums[0])]
            parent_idx = -1
            for i in range(1, len(nums)):

                curr = None
                if nums[i] is not None:
                    curr = BinaryTreeNode(nums[i])
                    forest.append(curr)

                if i % 2 == 1:
                    parent_idx += 1
                    forest[parent_idx].left = curr
                else:
                    forest[parent_idx].right = curr

        return forest[0]
```

</div>

<div id="f25563dc" class="cell markdown"
papermill="{&quot;duration&quot;:7.229e-3,&quot;end_time&quot;:&quot;2024-04-30T02:45:37.619195&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:37.611966&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

#### Helper for Singly Linked lists

</div>

<div id="5403a3fd" class="cell code" execution_count="3"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-30T02:45:37.635236Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-30T02:45:37.634622Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-30T02:45:37.641041Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-30T02:45:37.640287Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.6151e-2,&quot;end_time&quot;:&quot;2024-04-30T02:45:37.642621&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:37.626470&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

    def __str__(self):
        return str(self.val)

    @staticmethod
    def to_singly_linked_list(nums: list[int]):
        root = prev = None
        for n in nums:
            curr = ListNode(n)
            # Init once
            if not root:
                root = curr
            if prev:
                prev.next = curr
            prev = curr

        return root

    def to_list(self) -> list[int]:
        result = []
        curr = self
        while curr:
            result.append(curr.val)
            curr = curr.next
        return result
```

</div>

<div id="9cb590dd" class="cell markdown"
papermill="{&quot;duration&quot;:7.237e-3,&quot;end_time&quot;:&quot;2024-04-30T02:45:37.657333&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:37.650096&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

#### Utility to generate random BST

</div>

<div id="d2d8c823" class="cell code" execution_count="4"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-30T02:45:37.673589Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-30T02:45:37.672890Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-30T02:45:37.679378Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-30T02:45:37.678610Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.6409e-2,&quot;end_time&quot;:&quot;2024-04-30T02:45:37.681155&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:37.664746&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def generateBST(N: int, min_: int, max_: int) -> BinaryTreeNode|None:
    def insert(curr: BinaryTreeNode|None, n: int) -> BinaryTreeNode:
        if not curr:
            curr = BinaryTreeNode(n)
        elif curr.val < n:
            curr.right = insert(curr.right, n)
        else:
            curr.left = insert(curr.left, n)

        return curr

    assert N <= max_ - min_, "Number of available samples must be >= N"
    root: BinaryTreeNode|None = None
    for n in np.random.choice(np.arange(min_, max_), size=N, replace=False):
        root = insert(root, n)

    return root
```

</div>

<div id="5ae16de1" class="cell markdown"
papermill="{&quot;duration&quot;:7.295e-3,&quot;end_time&quot;:&quot;2024-04-30T02:45:37.696028&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:37.688733&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

GFG Jobathon: 32

</div>

<div id="b420e590" class="cell markdown"
papermill="{&quot;duration&quot;:7.209e-3,&quot;end_time&quot;:&quot;2024-04-30T02:45:37.710562&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:37.703353&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Q1: Lead Engineer

</div>

<div id="e632458b" class="cell code" execution_count="5"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-30T02:45:37.726675Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-30T02:45:37.726124Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-30T02:45:37.730988Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-30T02:45:37.730246Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.4827e-2,&quot;end_time&quot;:&quot;2024-04-30T02:45:37.732588&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:37.717761&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def leadOptions(self, N : int, E : List[int]) -> int:
    maxE: tuple[int, int] = -1, 0
    for exp in E:
        if exp == maxE[0]:
            maxE = maxE[0], maxE[1] + 1
        if exp > maxE[0]:
            maxE = exp, 0

    return maxE[1]
```

</div>

<div id="6b67334f" class="cell markdown"
papermill="{&quot;duration&quot;:7.231e-3,&quot;end_time&quot;:&quot;2024-04-30T02:45:37.747143&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:37.739912&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Codeforces: 20/C (Dijkstra)

</div>

<div id="a165d425" class="cell code" execution_count="6"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-30T02:45:37.763447Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-30T02:45:37.762852Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-30T02:45:37.773952Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-30T02:45:37.773181Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.1051e-2,&quot;end_time&quot;:&quot;2024-04-30T02:45:37.775598&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:37.754547&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def dijkstra(src: int, adjl: dict[int, list[tuple[int, int]]]) -> dict[int, tuple[float, int]]:
    heap: list[tuple[int, int, int]] = [(1, src, 1)]
    shortest: dict[int, tuple[float, int]] = dict()
    while heap:
        curr_dist, curr, prev = heapq.heappop(heap)
        if curr not in shortest or curr_dist < shortest[curr][0]:
            shortest[curr] = (curr_dist, prev)
            for next_, next_dist in adjl.get(curr, []):
                heapq.heappush(heap, (curr_dist + next_dist, next_, curr))

    return shortest

def twentyC(V: int, E: int, edges: list[tuple[int, int, int]]) -> str:
    adjl: dict[int, list[tuple[int, int]]] = dict()
    for n1, n2, d in edges:
        n1_neighbours, n2_neighbours = adjl.get(n1, []), adjl.get(n2, [])
        n1_neighbours.append((n2, d))
        n2_neighbours.append((n1, d))
        adjl[n1], adjl[n2] = n1_neighbours, n2_neighbours

    paths = dijkstra(1, adjl)
    if V in paths:
        result: list[int] = [V]
        curr = V
        while curr != 1:
            dist, prev = paths[curr]
            result.append(prev)
            curr = prev

        result.reverse()
        return ' '.join(map(str, result))
    else:
        return '-1'

# Testing the solution
assert twentyC(5, 5, [(1, 2, 2), (2, 5, 5), (2, 3, 4), (1, 4, 1), (4, 3, 3), (3, 5, 1)]) == '1 4 3 5'
```

</div>

<div id="a4263f01" class="cell markdown"
papermill="{&quot;duration&quot;:7.435e-3,&quot;end_time&quot;:&quot;2024-04-30T02:45:37.790551&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:37.783116&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

LC Medium: Course Schedule 2

</div>

<div id="eb152abe" class="cell code" execution_count="7"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-30T02:45:37.806996Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-30T02:45:37.806282Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-30T02:45:37.817146Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-30T02:45:37.816414Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.0812e-2,&quot;end_time&quot;:&quot;2024-04-30T02:45:37.818837&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:37.798025&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/course-schedule-ii/submissions/1239496066
def findOrder(numCourses: int, prerequisites: list[list[int]]) -> list[int]:
    adjl: dict[int, list[int]] = dict()
    for c1, c2 in prerequisites:
        # To take up C1, C2 must be done already
        c1_neighbours: list[int] = adjl.get(c1, [])
        c1_neighbours.append(c2)
        adjl[c1] = c1_neighbours

    paths: dict[int, list[int]] = dict()
    def getOrdering(curr: int, visited: set[int] = set()) -> list[int]:
        if curr in paths:
            return paths[curr]
        elif curr in visited:
            return []
        else:
            result: list[int] = [curr]
            visited.add(curr)
            for next_ in adjl.get(curr, []):
                deps: list[int] = getOrdering(next_, visited)
                if not deps:
                    return []
                else:
                    result.extend(deps)

            visited.remove(curr)
            paths[curr] = result
            return result

    # Courses are ordered from 0 to numCourses - 1
    result: list[int] = []
    completed: set[int] = set()
    for course in range(numCourses):
        deps = getOrdering(course)
        deps.reverse()
        if not deps:
            return []
        else:
            for dep in deps:
                if dep not in completed:
                    completed.add(dep)
                    result.append(dep)

    return result

# Testing the solution
assert findOrder(4, [[1,0], [2,0], [3,1], [3,2]]) in ([0,1,2,3], [0,2,1,3])
assert findOrder(5, [[1,0], [2,0], [3,4], [4,3]]) == []
```

</div>

<div id="ca3a0889" class="cell markdown"
papermill="{&quot;duration&quot;:7.19e-3,&quot;end_time&quot;:&quot;2024-04-30T02:45:37.833461&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:37.826271&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

LC Medium: Course Schedule 1 (DFS)

</div>

<div id="bdeaef7f" class="cell code" execution_count="8"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-30T02:45:37.849623Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-30T02:45:37.848887Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-30T02:45:37.859528Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-30T02:45:37.858942Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.0535e-2,&quot;end_time&quot;:&quot;2024-04-30T02:45:37.861260&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:37.840725&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/course-schedule/submissions/1240858033/
def canFinish(numCourses: int, prerequisites: list[list[int]]) -> bool:
    # Convert pre-req to adj list
    adj: dict[int, list[int]] = dict()
    for n1, n2 in prerequisites:
        n1_neighbours = adj.get(n1, [])
        n1_neighbours.append(n2)
        adj[n1] = n1_neighbours

    # DFS Algorithm to check for cycles
    def hasCycle(curr: int, paths: set[int] = set()) -> bool:
        if curr in paths:
            return True
        elif curr in visited:
            return False
        else:
            visited.add(curr)
            paths.add(curr)
            for next_ in adj.get(curr, []):
                if hasCycle(next_, paths):
                    return True
            paths.remove(curr)
            return False

    visited: set[int] = set()
    for curr in range(numCourses):
        if hasCycle(curr):
            return False
    else:
        return True

# Testing the solution
assert canFinish(2, [[1,0]]) == True
assert canFinish(2, [[1,0],[0,1]]) == False
```

</div>

<div id="2113dbd0" class="cell markdown"
papermill="{&quot;duration&quot;:7.295e-3,&quot;end_time&quot;:&quot;2024-04-30T02:45:37.877744&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:37.870449&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Shortest path in undirected graph with unit weights

</div>

<div id="de8ecf19" class="cell code" execution_count="9"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-30T02:45:37.894067Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-30T02:45:37.893481Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-30T02:45:37.901887Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-30T02:45:37.901147Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.8478e-2,&quot;end_time&quot;:&quot;2024-04-30T02:45:37.903715&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:37.885237&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def shortestPathUG(n: int, edges: list[tuple[int, int]], src: int) -> list[int]:
    # Create an adj list
    adj: dict[int, list[int]] = dict()
    for n1, n2 in edges:
        n1_neighbours, n2_neighbours = adj.get(n1, []), adj.get(n2, [])
        n1_neighbours.append(n2)
        n2_neighbours.append(n1)
        adj[n1], adj[n2] = n1_neighbours, n2_neighbours

    shortest: list[int] = [-1 for _ in range(n)]
    heap: list[tuple[int, int]] = [(0, src)]
    while heap:
        curr_dist, curr = heapq.heappop(heap)
        shortest[curr] = curr_dist if shortest[curr] == -1 or shortest[curr] > curr_dist else shortest[curr]
        for next_ in adj.get(curr, []):
            if shortest[next_] == -1 or curr_dist + 1 < shortest[next_]:
                heapq.heappush(heap, (curr_dist + 1, next_))

    return shortest

# Testing the solution
assert shortestPathUG(5, [(0, 1), (1, 4), (2, 3), (2, 4), (3, 4)], 1) == [1, 0, 2, 2, 1]
```

</div>

<div id="765658c5" class="cell markdown"
papermill="{&quot;duration&quot;:7.403e-3,&quot;end_time&quot;:&quot;2024-04-30T02:45:37.918647&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:37.911244&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Shortest path in DAG

</div>

<div id="c7e19951" class="cell code" execution_count="10"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-30T02:45:37.935869Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-30T02:45:37.935283Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-30T02:45:37.943550Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-30T02:45:37.942816Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.8529e-2,&quot;end_time&quot;:&quot;2024-04-30T02:45:37.945718&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:37.927189&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def shortestPathInDAG(N: int, M: int, edges: list[list[int]]) -> list[int]:
    # Create an adj list
    adj: dict[int, list[tuple[int, int]]] = dict()
    for n1, n2, w in edges:
        n1_neighbours = adj.get(n1, [])
        n1_neighbours.append((n2, w))
        adj[n1] = n1_neighbours

    # Dijkstra's algo!
    shortest: list[int] = [-1 for _ in range(N)]
    heap: list[tuple[int, int]] = [(0, 0)]
    while heap:
        curr_dist, curr = heapq.heappop(heap)
        if shortest[curr] == -1 or curr_dist < shortest[curr]:
            shortest[curr] = curr_dist
            for next_, next_dist in adj.get(curr, []):
                heapq.heappush(heap, (next_dist + curr_dist, next_))

    return shortest

# Testing the solution
assert shortestPathInDAG(3, 3, [[0,1,2], [1,2,3], [0,2,6]]) == [0, 2, 5]
assert shortestPathInDAG(3, 3, [[2,0,4],[0,1,3],[2,1,2]]) == [0, 3, -1]
```

</div>

<div id="36a13aa2" class="cell markdown"
papermill="{&quot;duration&quot;:7.276e-3,&quot;end_time&quot;:&quot;2024-04-30T02:45:37.960918&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:37.953642&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

LC Hard: Word Ladder

</div>

<div id="30ef6d16" class="cell code" execution_count="11"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-30T02:45:37.977047Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-30T02:45:37.976435Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-30T02:45:37.986899Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-30T02:45:37.986154Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.0568e-2,&quot;end_time&quot;:&quot;2024-04-30T02:45:37.988740&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:37.968172&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/word-ladder/submissions/1241826378
def ladderLengthBrute(beginWord: str, endWord: str, wordList: list[str]) -> int:
    def pathExists(w1: str, w2: str) -> bool:
        N, i = len(w1), 0
        dist = 0
        while i < N:
            if w1[i] != w2[i]:
                dist += 1
            if dist > 1:
                break
            i += 1

        return dist == 1

    def BFS(root: str):
        queue: collections.deque = collections.deque([root])
        distances[root] = 0
        while queue:
            curr = queue.popleft()
            for next_ in adj.get(curr, []):
                if next_ not in distances or distances[next_] > distances[curr] + 1:
                    distances[next_] = distances[curr] + 1
                    queue.append(next_)
                    if next_ == endWord:
                        return

    # Create an adjacency list
    adj: dict[str, list[str]] = dict()
    for w1, w2 in itertools.combinations([beginWord] + wordList, r=2):
        if pathExists(w1, w2):
            w1_neighbours, w2_neighbours = adj.get(w1, []), adj.get(w2, [])
            w1_neighbours.append(w2)
            w2_neighbours.append(w1)
            adj[w1], adj[w2] = w1_neighbours, w2_neighbours

    distances: dict[str, int] = dict()
    BFS(beginWord)
    return distances[endWord] + 1 if endWord in distances else 0

# Testing the solution
assert ladderLengthBrute("hit", "cog", ["hot","dot","dog","lot","log","cog"]) == 5
assert ladderLengthBrute("hit", "cog", ["hot","dot","dog","lot","log"]) == 0
```

</div>

<div id="a8ca8c27" class="cell markdown"
papermill="{&quot;duration&quot;:7.228e-3,&quot;end_time&quot;:&quot;2024-04-30T02:45:38.004668&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:37.997440&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

LC Hard: Word Ladder - 2:
<https://leetcode.com/problems/word-ladder-ii/>

</div>

<div id="e55a5c30" class="cell code" execution_count="12"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-30T02:45:38.021089Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-30T02:45:38.020539Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-30T02:45:38.035684Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-30T02:45:38.034944Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.5015e-2,&quot;end_time&quot;:&quot;2024-04-30T02:45:38.037358&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:38.012343&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# TLE :(
def findLadders(beginWord: str, endWord: str, wordList: list[str]) -> list[list[str]]:
    # BFS traversal to get the list of all shortest prev nodes
    N = len(beginWord)
    wordMap: dict[str, tuple[float, set[str]]] = {word: (math.inf, set()) for word in wordList}
    wordMap[beginWord] = (0, set())
    queue: collections.deque[tuple[str, int, str|None]] = collections.deque([(beginWord, 0, None)])
    while queue:
        curr, dist, prev = queue.popleft()
        for i in range(N):
            for j in range(ord('a'), ord('z') + 1):
                next_ = curr[:i] + chr(j) + curr[i + 1:]
                if next_ in wordMap:
                    next_dist, prevs = wordMap[next_]
                    if dist + 1 < next_dist:
                        prevs = set([curr])
                        next_dist = dist + 1
                        queue.append((next_, dist + 1, curr))
                    elif dist + 1 == next_dist:
                        prevs.add(curr)
                        queue.append((next_, dist + 1, curr))

                    wordMap[next_] = next_dist, prevs

    # Reverse the edges
    adj: dict[str, set[str]] = dict()
    for k, v in wordMap.items():
        n1, n1_neighbours = k, v[1]
        for n2 in n1_neighbours:
            n2_neighbours = adj.get(n2, set())
            n2_neighbours.add(n1)
            adj[n2] = n2_neighbours

    # Do any traversal to get the final result
    results: list[list[str]] = []
    def DFS(root: str, paths: list[str]):
        paths.append(root)
        if root == endWord:
            results.append(list(paths))
        else:
            for next_ in adj.get(root, set()):
                DFS(next_, paths)
        paths.pop()

    DFS(beginWord, [])
    return sorted(results)

# Testing the solution
assert findLadders("hit", "cog", ["hot","dot","dog","lot","log","cog"]) == [['hit', 'hot', 'dot', 'dog', 'cog'], ['hit', 'hot', 'lot', 'log', 'cog']]
assert findLadders("hit", "cog", ["hot","dot","dog","lot","log"]) == []
assert findLadders("a", "c", ["a", "b", "c"]) == [["a", "c"]]
assert findLadders("red", "tax", ["ted","tex","red","tax","tad","den","rex","pee"]) == [['red', 'rex', 'tex', 'tax'],['red', 'ted', 'tad', 'tax'],['red', 'ted', 'tex', 'tax']]
```

</div>

<div id="034f704f" class="cell markdown"
papermill="{&quot;duration&quot;:7.39e-3,&quot;end_time&quot;:&quot;2024-04-30T02:45:38.053912&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:38.046522&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

LC Biweekly contest: 129 (27th Apr 2024)

</div>

<div id="dfa6e9e0" class="cell code" execution_count="13"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-30T02:45:38.070070Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-30T02:45:38.069536Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-30T02:45:38.076606Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-30T02:45:38.075837Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.693e-2,&quot;end_time&quot;:&quot;2024-04-30T02:45:38.078232&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:38.061302&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Q1 - Easy
def canMakeSquare(grid: list[list[str]]) -> bool:
    for i, j in [(0, 0), (0, 1), (1, 0), (1, 1)]:
        count = 0
        for x, y in [(0, 0), (0, 1), (1, 0), (1, 1)]:
            i_, j_ = i + x, j + y
            if grid[i_][j_] == "W":
                count += 1
        if count != 2:
            return True
    else:
        return False

# Testing the solution
assert canMakeSquare([["B","W","B"],["B","W","W"],["B","W","W"]]) == True
assert canMakeSquare([["B","W","B"],["W","B","W"],["B","W","B"]]) == False
assert canMakeSquare([["B","B","B"],["B","B","B"],["B","B","B"]]) == True
```

</div>

<div id="b4f425f7" class="cell code" execution_count="14"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-30T02:45:38.095050Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-30T02:45:38.094466Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-30T02:45:38.102545Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-30T02:45:38.101815Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.7819e-2,&quot;end_time&quot;:&quot;2024-04-30T02:45:38.104238&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:38.086419&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Q2 - Medium
def numberOfRightTriangles(grid: list[list[int]]) -> int:
    # Find the dimensions
    M, N = len(grid), len(grid[0])

    # Precompute the number of 1's row & col wise
    rows = [0 for i in range(M)]
    cols = [0 for i in range(N)]
    for i in range(M):
        for j in range(N):
            if grid[i][j] == 1:
                rows[i] += 1
                cols[j] += 1

    # Traverse through the grid again. Each time we encounter a 1, count 1's in that row and excluding itself and find the product
    count = 0
    for i in range(M):
        for j in range(N):
            if grid[i][j] == 1:
                count += (rows[i] - 1) * (cols[j] - 1)

    return count

# Testing the solution
assert numberOfRightTriangles([[1,0,1],[1,0,0],[1,0,0]]) == 2
assert numberOfRightTriangles([[1,0,0,0],[0,1,0,1],[1,0,0,0]]) == 0
assert numberOfRightTriangles([[0,1,0],[0,1,1],[0,1,0]]) == 2
```

</div>

<div id="770f92f2" class="cell markdown"
papermill="{&quot;duration&quot;:7.413e-3,&quot;end_time&quot;:&quot;2024-04-30T02:45:38.119134&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:38.111721&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

LC Weekly Contest - 395 (28th Apr 2024)

</div>

<div id="bc82d8e7" class="cell code" execution_count="15"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-30T02:45:38.135269Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-30T02:45:38.134742Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-30T02:45:38.141363Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-30T02:45:38.140629Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.6549e-2,&quot;end_time&quot;:&quot;2024-04-30T02:45:38.143098&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:38.126549&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Q3: Medium
def minEnd(n: int, x: int) -> int:

    # convert to bin
    x_str = bin(x)[2:]
    n_str = bin(n - 1)[2:]

    # compute length of both bins
    xn, nn = len(x_str), len(n_str)

    # store on stack, use two pointers
    stack: list[str] = []
    i, j = xn - 1, nn - 1
    while i >= 0 or j >= 0:
        if j < 0 or (i >= 0 and x_str[i] == '1'):
            stack.append(x_str[i])
            i -= 1
        else:
            stack.append(n_str[j])
            i, j = i - 1, j - 1

    stack.reverse()
    return int(''.join(stack), base=2)

# Testing the solution
assert minEnd(9, 9) == 41
assert minEnd(3, 4) == 6
```

</div>

<div id="be39542d" class="cell markdown"
papermill="{&quot;duration&quot;:7.283e-3,&quot;end_time&quot;:&quot;2024-04-30T02:45:38.159617&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:38.152334&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Practice Bellman Ford, Floyd Warshall

</div>

<div id="ecdb0ceb" class="cell code" execution_count="16"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-30T02:45:38.175973Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-30T02:45:38.175391Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-30T02:45:38.181149Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-30T02:45:38.180411Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.5697e-2,&quot;end_time&quot;:&quot;2024-04-30T02:45:38.182776&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:38.167079&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def bellmanFord(N: int, M: int, src: int, edges: list[list[int]]) -> list[float]:
   # Compute the distances and store to a vector
   distances: list[float] = [math.inf for n1 in range(N + 1)]
   distances[src] = 0

   # Relax all edges for N - 1 iterations
   for i in range(N - 1):
       for n1, n2, w in edges:
           distances[n2] = min(distances[n2], distances[n1] + w)

   # Detect negative cycle
   for n1, n2, w in edges:
       if distances[n1] + w < distances[n2]:
           return [-1]

   # Return the distances array
   return distances
```

</div>

<div id="e6fd85e8" class="cell code" execution_count="17"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-30T02:45:38.199558Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-30T02:45:38.199030Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-30T02:45:38.205406Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-30T02:45:38.204658Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.6187e-2,&quot;end_time&quot;:&quot;2024-04-30T02:45:38.207086&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:38.190899&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def floydWarshall(N: int, M: int, src: int, dest: int, edges: list[list[int]]):
    # Create an adjacency matrix
    distances: list[list[float]] = [[math.inf if i != j else 0 for j in range(N)] for i in range(N)]
    for n1, n2, w in edges:
        distances[n1][n2] = w

    # Run the Floyd Warshall algorithm
    for k in range(N):
        for i in range(N):
            for j in range(N):
                distances[i][j] = min(distances[i][j], distances[i][k] + distances[k][j])

    # Check for cycles (matrix[i][i] < 0)
    for i in range(N):
        if distances[i][i] < 0:
            return []

    # Return the cost matrix
    return distances
```

</div>

<div id="c72f5184" class="cell markdown"
papermill="{&quot;duration&quot;:7.444e-3,&quot;end_time&quot;:&quot;2024-04-30T02:45:38.222810&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:38.215366&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Prim's Algorithm for MST

</div>

<div id="36eb7a78" class="cell code" execution_count="18"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-04-30T02:45:38.238998Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-04-30T02:45:38.238757Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-04-30T02:45:38.244289Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-04-30T02:45:38.243539Z&quot;}"
papermill="{&quot;duration&quot;:1.5408e-2,&quot;end_time&quot;:&quot;2024-04-30T02:45:38.245845&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-04-30T02:45:38.230437&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def prim(V: int, adj: list[list[list[int]]]):
    # Initial config
    visited: set[int] = set()
    mst_weight = 0
    heap: list[tuple[int, int]] = [(0, 0)]

    # Prim's algo
    while heap:
        curr_weight, curr = heapq.heappop(heap)
        if curr not in visited:
            visited.add(curr)
            mst_weight += curr_weight
            for next_, next_weight in adj[curr]:
                heapq.heappush(heap, (next_weight, next_))

    return mst_weight
```

</div>
