---
jupyter:
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
  language_info:
    codemirror_mode:
      name: ipython
      version: 3
    file_extension: .py
    mimetype: text/x-python
    name: python
    nbconvert_exporter: python
    pygments_lexer: ipython3
    version: 3.11.9
  nbformat: 4
  nbformat_minor: 5
  papermill:
    default_parameters: {}
    duration: 2.808796
    end_time: "2024-07-26T15:58:10.424394"
    environment_variables: {}
    input_path: practice/006.ipynb
    output_path: practice/006.ipynb
    parameters: {}
    start_time: "2024-07-26T15:58:07.615598"
    version: 2.6.0
---

<div id="1dbda701" class="cell code" execution_count="1"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:08.775004Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:08.774785Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:09.134434Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:09.133795Z&quot;}"
papermill="{&quot;duration&quot;:0.370658,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.135858&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:08.765200&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
from typing import List, Optional, Generator
import pandas as pd
import numpy as np
import sqlite3
import re
import io
import math
import collections
import itertools
import functools
import random
import string
import tqdm
import bisect
import heapq

conn = sqlite3.connect(":memory:")

def regexp(expr, item):
    reg = re.compile(expr)
    return reg.search(item) is not None

def read_lc_df(s: str, dtypes: dict[str, str]=dict()) -> pd.DataFrame:
    temp = pd.read_csv(io.StringIO(s), sep="|", skiprows=2)
    temp = temp.iloc[1:-1, 1:-1]
    temp.columns = temp.columns.map(str.strip)
    temp = temp.map(lambda x: x if type(x) != str else None if x.strip() == 'null' else x.strip())
    temp = temp.astype(dtypes)
    return temp

conn.create_function("REGEXP", 2, regexp)
```

</div>

<div id="a161421c" class="cell markdown"
papermill="{&quot;duration&quot;:6.532e-3,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.149353&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.142821&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

#### Helper for Binary tree problems

</div>

<div id="07be0a7b" class="cell code" execution_count="2"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:09.163923Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:09.163303Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:09.171098Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:09.170640Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.6415e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.172227&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.155812&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
class BinaryTreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

    def to_list(self):
        to_visit = [self]
        visited = []
        while len(to_visit) > 0:
            curr = to_visit.pop(0)
            if curr:
                to_visit.append(curr.left)
                to_visit.append(curr.right)
                visited.append(curr.val)
            else:
                visited.append(curr)

        while visited and not visited[-1]:
            visited.pop()

        return visited

    def __str__(self):
        return str(self.val)

    @staticmethod
    def from_array(nums: list[int|None]):
        '''Create a Tree from a list of nums. Returns the root node.'''
        if len(nums) == 0:
            return None
        elif len(nums) == 1:
            return BinaryTreeNode(nums[0])
        else:
            forest = [BinaryTreeNode(nums[0])]
            parent_idx = -1
            for i in range(1, len(nums)):

                curr = None
                if nums[i] is not None:
                    curr = BinaryTreeNode(nums[i])
                    forest.append(curr)

                if i % 2 == 1:
                    parent_idx += 1
                    forest[parent_idx].left = curr
                else:
                    forest[parent_idx].right = curr

        return forest[0]
```

</div>

<div id="6e9c13aa" class="cell markdown"
papermill="{&quot;duration&quot;:6.402e-3,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.185293&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.178891&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

#### Helper for Singly Linked lists

</div>

<div id="6abb9392" class="cell code" execution_count="3"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:09.199627Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:09.199104Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:09.203831Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:09.203301Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.3106e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.204878&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.191772&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

    def __str__(self):
        return str(self.val)

    @staticmethod
    def to_singly_linked_list(nums: list[int]):
        root = prev = None
        for n in nums:
            curr = ListNode(n)
            # Init once
            if not root:
                root = curr
            if prev:
                prev.next = curr
            prev = curr

        return root

    def to_list(self) -> list[int]:
        result = []
        curr = self
        while curr:
            result.append(curr.val)
            curr = curr.next
        return result
```

</div>

<div id="4f436676" class="cell markdown"
papermill="{&quot;duration&quot;:6.476e-3,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.217929&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.211453&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Codeforces Practice

</div>

<div id="8f687e9e" class="cell code" execution_count="4"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:09.232487Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:09.231963Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:09.244757Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:09.244193Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.141e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.245863&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.224453&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def pair_of_numbers(N: int, nums: list[int]) -> tuple[int, int, list[int]]:
    """
    Starting at index, check how far right you can go. Repeat same step on the leftwards direction.
    Combine the left and right to get the actual window that index i can cover (where nums[i] is the gcd and divides all)

    Problem occurs where there are duplicates where we skip those numbers since it was already covered in the window. Backward
    pass travels in the opp direction and we might end up missing the proper range.

    For eg:   2, 3, 1, 1, 3
    Forward:  0  0  3  0  0
    Backward: 0  0  0  4  0

    We could choose to ignore duplicates but that would miss nonoverlapping ranges
    We could try merging intervals but it wouldn't be trivial and we would need to merge only cases where the values match (need to lookback the entire length making it N^2)

    Simpler approach is to store the duplicates into an array and fill it in when we update i.
    """

    # Forward pass
    forward: dict[int, int] = {i: i for i in range(N)}
    i = j = 0
    match: list[int] = []
    while j <= N:
        if j < N and nums[j] % nums[i] == 0:
            if nums[j] == nums[i]:
                match.append(j)
            forward[i], j = j, j + 1
        else:
            for k in match:
                forward[k] = forward[i]
            i, j, match = j, j + 1, []

    # Backward pass
    backward: dict[int, int] = {i: i for i in range(N)}
    i = j = N - 1
    match = []
    while j >= -1:
        if j >= 0 and nums[j] % nums[i] == 0:
            if nums[j] == nums[i]:
                match.append(j)
            backward[i], j = j, j - 1
        else:
            for k in match:
                backward[k] = backward[i]
            i, j, match = j, j - 1, []

    # Merge both passes and store to a map seperated by distance
    valid_pairs: collections.defaultdict[int, set[int]] = collections.defaultdict(set)
    max_: int = 0
    for i in range(N):
        diff = forward[i] - backward[i]
        valid_pairs[diff].add(backward[i] + 1)
        max_ = max(max_, diff)

    return len(valid_pairs[max_]), max_, sorted(valid_pairs[max_])

# Testing the solution
assert pair_of_numbers(9, [2,4,3,6,9,8,10,2,4]) == (1, 3, [6])
assert pair_of_numbers(5, [4,6,9,3,6]) == (1, 3, [2])
assert pair_of_numbers(5, [1,3,5,7,9]) == (1, 4, [1])
assert pair_of_numbers(5, [2,3,5,7,11]) == (5, 0, [1,2,3,4,5])
assert pair_of_numbers(5, [1,2,3,2,1]) == (1, 4, [1])
assert pair_of_numbers(5, [2,4,1,1,2]) == (1, 4, [1])

# Good substrings - 271D
class Trie:
    def __init__(self, end: bool = False) -> None:
        self.nodes: dict[str, 'Trie'] = dict()
        self.end = end

    def __getitem__(self, ch: str) -> 'Trie':
        self.nodes[ch] = self.nodes.get(ch, Trie())
        return self.nodes[ch]

def good_substrings(S: str, good_chars_: str, K: int) -> int:
    N, count = len(S), 0
    good_chars: set[str] = {chr(ord('a') + i) for i in range(26) if good_chars_[i] == '1'}
    root: Trie = Trie()
    for i in range(N):
        k_, curr = K, root
        for j in range(i, N):
            if S[j] not in good_chars:
                k_ -= 1
            if k_ >= 0:
                curr = curr[S[j]]
                count += not curr.end
                curr.end = True
            else:
                break

    return count

# Testing the solution
assert good_substrings("ababab", "01000000000000000000000000", 1) == 5
assert good_substrings("acbacbacaa", "00000000000000000000000000", 2) == 8
```

</div>

<div id="711735e2" class="cell markdown"
papermill="{&quot;duration&quot;:6.531e-3,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.259142&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.252611&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

LC POTD

</div>

<div id="aec51cad" class="cell code" execution_count="5"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:09.273419Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:09.273002Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:09.279127Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:09.278578Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.4623e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.280210&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.265587&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/create-binary-tree-from-descriptions/submissions/1321920493/?envType=daily-question&envId=2024-07-15
def createBinaryTree(descriptions: list[list[int]]) -> BinaryTreeNode:
    """Node without parent is the root"""
    # Create the binary tree
    nodes_dict: dict[int, BinaryTreeNode] = dict()
    parents: set[int] = set()
    children: set[int] = set()
    for parent, child, direction in descriptions:
        p_node, c_node = nodes_dict.get(parent, BinaryTreeNode(parent)), nodes_dict.get(child, BinaryTreeNode(child))
        nodes_dict[parent], nodes_dict[child] = p_node, c_node

        if direction == 1:
            p_node.left = c_node
        else:
            p_node.right = c_node

        if parent not in children:
            parents.add(parent)
        if child in parents:
            parents.remove(child)
        children.add(child)

    assert len(parents) == 1
    return nodes_dict[parents.pop()]

# Testing the solution
assert createBinaryTree([[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]]).to_list() == [50,20,80,15,17,19]
assert createBinaryTree([[1,2,1],[2,3,0],[3,4,1]]).to_list() == [1,2,None,None,3,4]
```

</div>

<div id="c157b54c" class="cell markdown"
papermill="{&quot;duration&quot;:6.461e-3,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.293370&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.286909&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

KMP Algorithm

</div>

<div id="3898dc59" class="cell code" execution_count="6"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:09.307781Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:09.307286Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:09.311550Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:09.311029Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.279e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.312620&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.299830&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def create_lps_array(pattern: str) -> list[int]:
    N = len(pattern)
    pi: list[int] = [0] * N
    j = 0
    for i in range(1, N):
        while pattern[j] != pattern[i] and j > 0:
            j = pi[j - 1]
        if pattern[i] == pattern[j]:
            j += 1
        pi[i] = j

    return pi

# Testing the solution
assert create_lps_array("abcdabc") == [0, 0, 0, 0, 1, 2, 3]
```

</div>

<div id="0ee5d9b0" class="cell markdown"
papermill="{&quot;duration&quot;:6.418e-3,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.325656&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.319238&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Codeforces Practice

</div>

<div id="b252c334" class="cell code" execution_count="7"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:09.339873Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:09.339410Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:09.345911Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:09.345458Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.4958e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.346994&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.332036&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def longest_prefix_suffix_palindome(S: str) -> str:
    def KMP(pattern: str) -> list[int]:
        pattern_length = len(pattern)
        pi: list[int] = [0] * pattern_length
        j = 0
        for i in range(1, pattern_length):
            while pattern[i] != pattern[j] and j > 0:
                j = pi[j - 1]
            if pattern[i] == pattern[j]:
                j += 1
            pi[i] = j

        return pi

    N = len(S)
    i, j = 0, N - 1

    # Find greatest k such that S[0..k] + S[N - k - 1.. N - 1] is a palindrome
    k = 0
    for k in range(N // 2):
        if S[k] != S[N - k - 1]:
            break

    # Find longest prefix-suffix of S[k..N-k-1]
    middle = S[k: N - k]
    lps = middle[:KMP(middle + '#' + middle[::-1])[-1]]

    # Find longest prefix-suffix of reversed(S[k..N-k-1])
    middle_reversed = middle[::-1]
    lps_reversed = middle_reversed[:KMP(middle_reversed + '#' + middle_reversed[::-1])[-1]]

    return S[:k] + (lps if len(lps) > len(lps_reversed) else lps_reversed[::-1]) + S[N - k:]

# Testing the solution
assert len(longest_prefix_suffix_palindome("abcdfdcecba")) == len("abcdfdcba")
assert len(longest_prefix_suffix_palindome("abbaxyzyx")) == len("xyzyx")
assert len(longest_prefix_suffix_palindome("acbba")) == len("abba")
assert len(longest_prefix_suffix_palindome("a")) == len("a")
assert len(longest_prefix_suffix_palindome("codeforces")) == len("c")
```

</div>

<div id="e6f93b0e" class="cell markdown"
papermill="{&quot;duration&quot;:6.626e-3,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.360225&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.353599&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

#### LC Practice - Strings - KMP

</div>

<div id="7cdab853" class="cell code" execution_count="8"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:09.374650Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:09.374058Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:09.379988Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:09.379550Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.4423e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.381012&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.366589&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# LC: https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/
def strStr(haystack: str, needle: str) -> int:
    def create_lps(pattern: str, M: int) -> list[int]:
        j = 0
        lps = [0] * M
        for i in range(1, M):
            while pattern[i] != pattern[j] and j > 0:
                j = lps[j - 1]
            if pattern[i] == pattern[j]:
                j += 1
            lps[i] = j

        return lps

    N, M = len(haystack), len(needle)
    lps = create_lps(needle, M)
    j = 0
    for i in range(N):
        while haystack[i] != needle[j] and j > 0:
            j = lps[j - 1]
        if haystack[i] == needle[j]:
            j += 1
        if j >= M:
            return i - j + 1

    return -1

# Testing the solution
assert strStr("asabadzabababababaaababaabba", "abababab") == 7
```

</div>

<div id="5232f86f" class="cell code" execution_count="9"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:09.395205Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:09.394735Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:09.400233Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:09.399755Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.3702e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.401227&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.387525&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/repeated-substring-pattern/
def repeatedSubstringPattern(S: str) -> bool:
    def create_lps(pattern: str) -> list[int]:
        pattern_length, j = len(pattern), 0
        lps: list[int] = [0] * pattern_length
        for i in range(1, pattern_length):
            while pattern[i] != pattern[j] and j > 0:
                j = lps[j - 1]
            if pattern[i] == pattern[j]:
                j += 1
            lps[i] = j

        return lps

    # Create LPS, find the longest repeating pattern length
    # Ensure that the pattern repeats itself
    N = len(S)
    lps = create_lps(S)
    repeat_str_length = N - lps[-1]

    for i in range(N):
        if S[i % repeat_str_length] != S[i]:
            return False
    return (repeat_str_length < N) and (N % repeat_str_length == 0)

# Testing the solution
assert repeatedSubstringPattern("acbaaacbaa") == repeatedSubstringPattern("aaabbaaabb") == True
assert repeatedSubstringPattern("abcabcabc") == repeatedSubstringPattern("abaababaab") == True
assert repeatedSubstringPattern("abcabcabz") == repeatedSubstringPattern("aba") == False
```

</div>

<div id="301b862f" class="cell code" execution_count="10"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:09.415459Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:09.415045Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:09.422809Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:09.422267Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.6248e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.423982&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.407734&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# TLE :(
def watto_mechanism_trie(input_patterns: list[str], search_patterns: list[str]) -> list[bool]:
    class TrieNode:
        def __init__(self, end: bool = False):
            self.nodes: collections.defaultdict[str, 'TrieNode'] = collections.defaultdict(TrieNode)
            self.end: bool = end

        def __getitem__(self, ch: str) -> 'TrieNode':
            return self.nodes[ch]

    def search(string: str) -> bool:
        N = len(string)
        stack: list[tuple[TrieNode, int, bool]] = [(ROOT, 0, True)]
        while stack:
            curr, idx, editable = stack.pop()
            if idx == N:
                if not editable and curr.end:
                    return True
            else:
                for next_ch in ['a', 'b', 'c']:
                    if next_ch in curr.nodes:
                        if next_ch == string[idx]:
                            stack.append((curr[next_ch], idx + 1, editable))
                        elif next_ch != string[idx] and editable:
                            stack.append((curr[next_ch], idx + 1, False))
        return False

    # Convert the input patterns into a trie data strucute
    ROOT = TrieNode()
    for inp in input_patterns:
        curr = ROOT
        for ch in inp:
            curr = curr[ch]
        curr.end = True

    results: list[bool] = []
    for search_pattern in search_patterns:
        results.append(search(search_pattern))

    return results

# Testing the solution
assert watto_mechanism_trie(["aaaaa", "acacaca"], ["aabaa", "ccacacc", "caaac"]) == [True, False, False]
assert watto_mechanism_trie(["acbacbacb"], ["cbacbacb", "acbacbac", "aacbacbacb", "acbacbacbb", "acbaabacb"]) == [False, False, False, False, True]
assert watto_mechanism_trie(["ab", "cacab", "cbabc", "acc", "cacab"], ["abc", "aa", "acbca", "cb"]) == [True, True, False, True]
```

</div>

<div id="f6731b9c" class="cell code" execution_count="11"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:09.438930Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:09.438302Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:09.445542Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:09.445113Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.593e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.446668&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.430738&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def watto_mechanism(input_patterns: list[str], search_patterns: list[str]) -> list[bool]:
    """
    Idea from editorial:
        1. Compute and store the polynomial rolling hashes for each of the input_patterns
        2. For each search string, compute possibilities and check if they exist in the hash
    """

    # Constants for polynomial rolling hash
    P, M = 257, 2 ** 61 + 7

    def poly_hash(string: str) -> int:
        nonlocal P, M
        N, hash_val, p_ = len(string), 0, 1
        for i in range(N):
            hash_val = (hash_val + (ord(string[i]) * p_)) % M
            p_ = (p_ * P) % M
        return hash_val

    def search(string: str) -> bool:
        nonlocal P, M
        N, hash_val, p_ = len(string), poly_hash(string), 1
        for i in range(N):
            for ch in ('a', 'b', 'c'):
                modified_hash = (hash_val + (ord(ch) - ord(string[i])) * p_) % M
                if ch != string[i] and modified_hash in hashes:
                    return True
            p_ = (p_ * P) % M
        return False

    # Store all the input strs as poly hashes
    hashes: set[int] = set()
    for inp in input_patterns:
        hashes.add(poly_hash(inp))

    # Iterate through the search strings, compute all hashes for all combinations in O(1) time
    results: list[bool] = []
    for inp in search_patterns:
        results.append(search(inp))

    return results

# Testing the solution
assert watto_mechanism(["aaaaa", "acacaca"], ["aabaa", "ccacacc", "caaac"]) == [True, False, False]
assert watto_mechanism(["acbacbacb"], ["cbacbacb", "acbacbac", "aacbacbacb", "acbacbacbb", "acbaabacb"]) == [False, False, False, False, True]
assert watto_mechanism(["ab", "cacab", "cbabc", "acc", "cacab"], ["abc", "aa", "acbca", "cb"]) == [True, True, False, True]
```

</div>

<div id="45e647a3" class="cell markdown"
papermill="{&quot;duration&quot;:6.662e-3,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.460366&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.453704&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Codeforces Practice

</div>

<div id="20dc1c55" class="cell code" execution_count="12"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:09.474820Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:09.474289Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:09.479490Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:09.479062Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.371e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.480548&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.466838&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def palindrome_degree(string: str) -> int:
    """
    Iterate through string, check if current substr is a palindrome.
    If it is, degree equals degree[substr // 2] + 1.
    Assume degree[substr // 2] if not found as 0.
    Return sum of all degrees.

    Checking if substr is a palindrome, check if prefix_hash hash(S[i..j]) == rev_prefix_hash hash(S[j..i])

    PREFIX_HASH = sum(ord(s[i]) * p ** i)
        abc: a + bP + cP^2

    REV_PREFIX_HASH is a little tricky but when running in a loop it is pretty simple
        abc: (rev_prefix_hash * P) + ord(s[i])
            a -> a
            b -> aP + b
            c -> aP^2 + bP + c
    """
    # Paramaters for rolling hash
    P, M = 257, 2**61 - 1

    N = len(string)
    degree: list[int] = [0 for i in range(N)]
    prefix_hash = rev_prefix_hash = ord(string[0])
    total_degree = degree[0] = 1
    p = P
    for i in range(1, N):
        prefix_hash, p = (prefix_hash + ord(string[i]) * p) % M, (P * p) % M
        rev_prefix_hash = (rev_prefix_hash * P + ord(string[i])) % M
        if prefix_hash == rev_prefix_hash:
            degree[i] = degree[(i - 1) // 2] + 1
            total_degree += degree[i]

    return total_degree

# Testing the solution
assert palindrome_degree("a2A") == 1
assert palindrome_degree("abacaba") == 6
```

</div>

<div id="bd066408" class="cell code" execution_count="13"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:09.494730Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:09.494509Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:09.501479Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:09.500962Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.5362e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.502569&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.487207&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def spy_syndrome2(secret: str, words: list[str]) -> str:
    # Parameters for rolling Hash
    P, M = 257, 10**9 + 7

    def poly_hash(string: str) -> int:
        nonlocal P, M
        word_length, hash_value, p = len(string), 0, 1
        for i in range(word_length):
            hash_value, p = (hash_value + p * ord(string[i].lower())) % M, (p * P) % M

        return hash_value

    # Store the list of words as hashes
    hashes: dict[int, str] = dict()
    for word in words:
        hashes[poly_hash(word)] = word

    # Compute the rev prefix hash as we iterate through the secret, if
    # match found reset and add to list of words found, note that we
    # might need to backtrack which is handled by the stack code here!
    result: list[str] = []
    secret_length = len(secret)
    stack: list[tuple[int, int]] = [(0, 0)]
    while stack:
        idx, hash_value = stack.pop()
        if idx == secret_length:
            if hash_value == 0:
                break
            else:
                result.pop()
        else:
            hash_value = (hash_value * P + ord(secret[idx].lower())) % M
            stack.append((idx + 1, hash_value))
            if hash_value in hashes:
                result.append(hashes[hash_value])
                stack.append((idx + 1, 0))

    return ' '.join(result)

# Testing the solution
assert spy_syndrome2("ariksihsidlihcdnaehsetahgnisol", ["Kira", "hates", "is", "he", "losing", "death", "childish", "L", "and", "Note"]) == "Kira is childish and he hates losing"
assert spy_syndrome2("iherehtolleh", ["HI", "Ho", "there", "HeLLo", "hello"]).lower() == "HI there HeLLo".lower()
assert spy_syndrome2("ababaaba", ["aba", "ababa"]) == "ababa aba"
```

</div>

<div id="a4ef7399" class="cell markdown"
papermill="{&quot;duration&quot;:6.511e-3,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.515690&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.509179&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Codeforces Practice

</div>

<div id="bc104a4b" class="cell code" execution_count="14"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:09.529964Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:09.529538Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:09.537236Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:09.536812Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.6158e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.538311&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.522153&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def xor_paths(M: int, N: int, matrix: list[list[int]], K: int) -> int:
    """
    Meet in the middle to reduce the time complexity.
    """

    valid_path_count, max_moves = 0, M + N - 2
    counts: collections.defaultdict[tuple[int, int, int], int] = collections.defaultdict(int)

    # Starting from (0, 0), make max_moves // 2: travelling right or down
    stack: list[tuple[int, int, int, int]] = [(0, 0, 0, 0)]
    while stack:
        i, j, xor_sum, moves = stack.pop()
        xor_sum ^= matrix[i][j]
        if moves == max_moves // 2:
            counts[i, j, xor_sum] += 1
        else:
            if i + 1 < M:
                stack.append((i + 1, j, xor_sum, moves + 1))
            if j + 1 < N:
                stack.append((i, j + 1, xor_sum, moves + 1))

    # Starting from (M - 1, N - 1), make max_moves - (max_moves // 2): travelling left or up
    stack = [(M - 1, N - 1, K, 0)]
    while stack:
        i, j, xor_sum, moves = stack.pop()
        if moves == max_moves - (max_moves // 2):
            # In the end counts[i, j, xor_sum] that we reached from the
            # front and the end would be such that xor_sum ^ K == 0
            valid_path_count += counts[i, j, xor_sum]
        else:
            if i - 1 >= 0:
                stack.append((i - 1, j, xor_sum ^ matrix[i][j], moves + 1))
            if j - 1 >= 0:
                stack.append((i, j - 1, xor_sum ^ matrix[i][j], moves + 1))

    return valid_path_count

# Testing the solution
assert xor_paths(3, 3, [[2, 1, 5], [7, 10, 0], [12, 6, 4]], 11) == 3
assert xor_paths(3, 4, [[1, 3, 3, 3], [0, 3, 3, 2], [3, 0, 1, 1]], 2) == 5
assert xor_paths(3, 4, [[1, 3, 3, 3], [0, 3, 3, 2], [3, 0, 1, 1]], 1000000000000000000) == 0
```

</div>

<div id="f3b79ef1" class="cell markdown"
papermill="{&quot;duration&quot;:6.445e-3,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.551238&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.544793&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

CP Easy: Trees

</div>

<div id="79f51e67" class="cell code" execution_count="15"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:09.566337Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:09.565920Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:09.572295Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:09.571751Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.4936e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.573328&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.558392&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def subordinates(n_employees: int, bosses: list[int]) -> list[int]:
    """
    The recusive solution using cache is trivial, using the
    iterative approach to prevent stackoverflow
    """

    subordinate_counts: list[int] = [-1 for i in range(n_employees + 1)]
    subordinates: collections.defaultdict[int, list[int]] = collections.defaultdict(list)
    for i, boss in enumerate(bosses, start=2):
        subordinates[boss].append(i)

    # Starting with the director, count subordinates recursively using stack
    stack: list[int] = [1]
    while stack:
        emp, subordinate_count = stack[-1], 0
        for subordinate in subordinates[emp]:
            if subordinate_counts[subordinate] == -1:
                stack.append(subordinate)
            else:
                subordinate_count += 1 + subordinate_counts[subordinate]
        if emp == stack[-1]:
            subordinate_counts[emp] = subordinate_count
            stack.pop()

    return subordinate_counts[1:]

# Testing the solution
assert subordinates(5, [1, 1, 2, 3]) == [4, 1, 1, 0, 0]
assert subordinates(10, [1,1,1,1,1,1,1,1,1]) == [9,0,0,0,0,0,0,0,0,0]
assert subordinates(10, [1,2,3,4,5,6,7,8,9]) == [9,8,7,6,5,4,3,2,1,0]
```

</div>

<div id="74595f0d" class="cell code" execution_count="16"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:09.587960Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:09.587532Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:09.593740Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:09.593280Z&quot;}"
papermill="{&quot;duration&quot;:1.4654e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.594819&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.580165&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def tree_matching(E: int, edges: list[tuple[int, int]]) -> int:
    """
    Only having a superficial understanding, converted with trial and
    errors the solution from recursive to iterative.
    """
    adjl: collections.defaultdict[int, list] = collections.defaultdict(list)
    for i, j in edges:
        adjl[i].append(j)
        adjl[j].append(i)

    # greedily keep matching a leaf with the only vertex adjacent to it while possible
    visited: set[int] = {1}
    picked: set[int] = set()
    stack: list[tuple[int, int]] = [(1, -1)]
    matching: int = 0
    while stack:
        curr, prev = stack[-1]
        for next_ in adjl[curr]:
            if next_ not in visited:
                visited.add(next_)
                stack.append((next_, curr))
        if stack[-1] == (curr, prev):
            stack.pop()
            # At the end of each recursive call, as per recursive code logic
            # we skip the first 'edge' (1, -1)
            if prev != -1 and prev not in picked and curr not in picked:
                matching += 1
                picked.add(curr)
                picked.add(prev)

    return matching

# Testing the solution
assert tree_matching(5, [(1,2), (1,3), (3,4), (3,5)]) == 2
assert tree_matching(10, [(8,9), (10,9), (1,4), (7,1), (8,3), (10,5), (4,2), (3,7), (6,4)]) == 4
```

</div>

<div id="b8a3aee7" class="cell markdown" lines_to_next_cell="2"
papermill="{&quot;duration&quot;:6.614e-3,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.608078&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.601464&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Diameter of a tree: Naive approach is to run DFS on all nodes which
would lead to a time complexity of O(n \* n).<br> Better approach would
be to run DFS from any node and find the farthest point. From this point
run DFS again and fnd the farthest point. Compute distance between these
two nodes.

</div>

<div id="f9da7b22" class="cell code" execution_count="17"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:09.622458Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:09.622057Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:09.629350Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:09.628851Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.5937e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.630505&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.614568&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def circumference(N: int, edges: list[tuple[int, int]]) -> int:
    def farthest(node: int) -> tuple[int, int]:
        result: tuple[int, int] = (-1, -1)
        queue: collections.deque[tuple[int, int, int]] = collections.deque([(node, -1, 0)])
        while queue:
            curr, prev, dist = queue.popleft()
            if dist > result[1]:
                result = curr, dist
            for next_ in adjl[curr]:
                if next_ != prev:
                    queue.append((next_, curr, dist + 1))

        return result

    # Create an adj list from the provided edges
    adjl: collections.defaultdict[int, list[int]] = collections.defaultdict(list)
    for n1, n2 in edges:
        adjl[n1].append(n2)
        adjl[n2].append(n1)

    # Take any random node and run DFS to find the farthest point
    n1, _ = farthest(edges[0][0])
    n2, D = farthest(n1)

    # Wrong formula but this is the expected formula
    return 3 * D

# Testing the solution
assert circumference(3, [(3,2), (2,1)]) == 6
assert circumference(5, [(4,2), (1,4), (5,4), (3,4)]) == 6
```

</div>

<div id="0891c413" class="cell markdown"
papermill="{&quot;duration&quot;:6.529e-3,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.643605&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.637076&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

LC Biweekly - 20th July 2024

</div>

<div id="a81c610d" class="cell code" execution_count="18"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:09.657802Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:09.657392Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:09.661126Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:09.660719Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.2098e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.662171&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.650073&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def losingPlayer(x: int, y: int) -> str:
    alice_turn = True
    x_req, y_req = 1, 4
    while x >= x_req and y >= y_req:
        x, y = x - x_req, y - y_req
        alice_turn = not alice_turn

    return "Alice" if not alice_turn else "Bob"

# Testing the solution
assert losingPlayer(2, 7) == "Alice"
assert losingPlayer(4, 11) == "Bob"
```

</div>

<div id="2d2dc400" class="cell code" execution_count="19"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:09.676520Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:09.676057Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:09.679696Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:09.679185Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.1979e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.680702&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.668723&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def minimumLength(s: str) -> int:
    freq: collections.Counter = collections.Counter(s)
    return sum(map(lambda x: x if x <= 2 else 1 if x % 2 == 1 else 2, freq.values()))

# Testing the solution
assert minimumLength("abaacbcbb") == 5
assert minimumLength("aa") == 2
```

</div>

<div id="bfa64614" class="cell code" execution_count="20"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:09.714309Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:09.714014Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:09.719712Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:09.719248Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.4218e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.720741&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.706523&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# TLE :)
def minChanges(nums: list[int], K: int) -> int:
    N, min_changes = len(nums), math.inf
    max_diff = max([*nums, K])
    for x in range(max_diff + 1):
        changes = 0.
        for i in range(N // 2):
            L, R = nums[i], nums[N - i - 1]
            if abs(L - R) == x:
                changes += 0
            elif (L - K <= x <= max(L, abs(L - K))) or (R - K <= x <= max(R, abs(R - K))):
                changes += 1
            elif 0 <= x <= K:
                changes += 2
            else:
                changes += math.inf

        min_changes = min(min_changes, changes)

    return int(min_changes)

# Testing the solution
assert minChanges([1,0,1,2,4,3], 4) == 2
assert minChanges([0,1,2,3,3,6,5,4], 6) == 2
assert minChanges([3,1,7,7,8,7,0,5,8,0,6,7,0,2,6,6], 8) == 6
```

</div>

<div id="86a332d3" class="cell markdown"
papermill="{&quot;duration&quot;:6.529e-3,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.733942&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.727413&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

LC Weekly Contest - 21st July 2024

</div>

<div id="8ed3be79" class="cell code" execution_count="21"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:09.748366Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:09.747878Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:09.752352Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:09.751828Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.3034e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.753496&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.740462&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def minBitChanges(N: int, K: int) -> int:
    changes = 0.
    while N > 0 or K > 0:
        N_bit, K_bit = N & 1, K & 1
        N, K = N >> 1, K >> 1
        if N_bit == 1 and K_bit == 0:
            changes += 1
        elif N_bit == K_bit:
            changes += 0
        else:
            changes += math.inf

    return int(changes) if not math.isinf(changes) else -1

# Testing the solution
assert minBitChanges(13, 4) == 2
assert minBitChanges(21, 21) == 0
assert minBitChanges(14, 13) == -1
```

</div>

<div id="e74d786a" class="cell code" execution_count="22"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:09.767783Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:09.767374Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:09.770898Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:09.770382Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.1767e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.771973&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.760206&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def doesAliceWin(s: str) -> bool:
    vc = 0
    for ch in s:
        if ch in ('a', 'e', 'i', 'o', 'u'):
            vc += 1

    return vc != 0

# Testing the solution
assert doesAliceWin("leetcoder") == True
assert doesAliceWin("bcd") == False
```

</div>

<div id="4d022653" class="cell code" execution_count="23"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:09.785996Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:09.785528Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:09.789358Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:09.788897Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.1943e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.790445&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.778502&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def maxOperations(S: str) -> int:
    N = len(S)
    ops = ones = 0
    for i in range(N):
        if S[i] == '1':
            ones += 1
        elif S[i - 1] == '1':
            ops += ones

    return ops

# Testing the solution
assert maxOperations("1001101") == 4
assert maxOperations("00111") == 0
assert maxOperations("1000") == 1
assert maxOperations("1110") == 3
```

</div>

<div id="25db5338" class="cell code" execution_count="24"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:09.804462Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:09.804065Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:09.811185Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:09.810707Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.5277e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.812268&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.796991&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Solved at 9:40 :)
def minimumOperations(nums: list[int], target: list[int]) -> int:
    def equal_sign(n1: int, n2: int) -> bool:
        return (n1 < 0 and n2 < 0) or (n1 > 0 and n2 > 0) or (n1 == n2 == 0)

    def split(left: int, right: int) -> list[tuple[int, int]]:
        result: list[tuple[int, int]] = []
        prev = left
        for i in range(left, right + 2):
            if i == right + 1 or not equal_sign(deltas[i], deltas[prev]):
                result.append((prev, i - 1))
                prev = i

        return result

    def count(left: int, right: int) -> int:
        min_ = abs(deltas[left])
        for i in range(left, right+1):
            deltas[i] = abs(deltas[i])
            min_ = min(min_, deltas[i])

        for i in range(left, right+1):
            deltas[i] -= min_

        slices: list[tuple[int, int]] = split(left, right)
        ops_ = min_
        if min_ > 0:
            for i, j in slices:
                ops_ += count(i, j)

        return ops_

    N, ops = len(nums), 0
    deltas: list[int] = [nums[i] - target[i] for i in range(N)]
    slices: list[tuple[int, int]] = split(0, N - 1)
    for i, j in slices:
        ops += count(i, j)

    return ops

# Testing the solution
assert minimumOperations([3,5,1,2], [4,6,2,4]) == 2
assert minimumOperations([1,3,2], [2,1,4]) == 5
```

</div>

<div id="19c7f6ff" class="cell code" execution_count="25"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:09.826220Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:09.825890Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:09.832232Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:09.831810Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.4427e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.833256&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.818829&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def dynamic_dyameter(N: int, edges: list[tuple[int, int]]) -> list[int]:
    def BFS(start: int) -> tuple[int, set[int]]:
        distances: collections.defaultdict[int, set[int]] = collections.defaultdict(set)
        queue: collections.deque[tuple[int, int, int]] = collections.deque([(start, 0, 0)])
        max_dist = 0
        while queue:
            curr, prev, dist = queue.popleft()
            distances[dist].add(curr)
            max_dist = max(dist, max_dist)
            for next_ in adjl[curr]:
                if next_ != prev:
                    queue.append((next_, curr, dist + 1))

        return max_dist, distances[max_dist]

    # Convert edges to adjancency list
    adjl: collections.defaultdict[int, list[int]] = collections.defaultdict(list)
    for n1, n2 in edges:
        adjl[n1].append(n2)
        adjl[n2].append(n1)

    # Find the farthest from a random node
    nodes = BFS(1)[1]
    leaves: set[int] = {*nodes}
    D, farthest_nodes = BFS(next(iter(leaves)))
    leaves.update(farthest_nodes)

    return [D + 1 if i in leaves else D for i in range(1, N + 1)]

# Testing the solution
assert dynamic_dyameter(3, [(3,2), (2,1)]) == [3,2,3]
assert dynamic_dyameter(5, [(4,2), (1,4), (5,4), (3,4)]) == [3,3,3,2,3]
```

</div>

<div id="f5eb47cb" class="cell code" execution_count="26"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:09.847340Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:09.846844Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:09.853899Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:09.853465Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.5164e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.854948&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.839784&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def military_problem(n_officers: int, superiors: list[int], queries: list[tuple[int, int]]) -> list[int]:
    adjl: collections.defaultdict[int, list[int]] = collections.defaultdict(list)
    for officer, superior in enumerate(superiors, start=2):
        adjl[superior].append(officer)

    # DFS starting from the supreme commander - 1
    # Create variables for storing the DFS order and the start/end index for each
    order: list[int] = []
    ranges: collections.defaultdict[int, tuple[int, int]] = collections.defaultdict(lambda: (0, 0))
    stack: list[tuple[int, int]] = [(1, 0)]
    while stack:
        curr, idx = stack[-1]
        if idx == 0:
            order.append(curr)
            ranges[curr] = len(order) - 1, len(order) - 1
        if idx < len(adjl[curr]):
            stack[-1] = curr, idx + 1
            stack.append((adjl[curr][idx], 0))
        else:
            stack.pop()
            ranges[curr] = ranges[curr][0], len(order) - 1

    # Answer the queries
    result: list[int] = []
    for officer, kth in queries:
        start, end = ranges[officer]
        if end - start + 1 >= kth:
            result.append(order[start + kth - 1])
        else:
            result.append(-1)

    return result

# Testing the solution
assert military_problem(9, [1,2,2,3,5,3,6,7], [(1,5), (7,3), (1,8), (1,9)]) == [6,-1,9,4]
assert military_problem(9, [1,1,1,3,5,3,5,7], [(3,1), (1,5), (3,4), (7,3), (1,8), (1,9)]) == [3,6,8,-1,9,4]
```

</div>

<div id="03b63bfc" class="cell markdown"
papermill="{&quot;duration&quot;:6.496e-3,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.867969&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.861473&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Binary Lifting - LCA

</div>

<div id="232e564a" class="cell code" execution_count="27"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:09.881866Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:09.881544Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:09.888154Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:09.887656Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.4847e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.889303&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.874456&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/kth-ancestor-of-a-tree-node://leetcode.com/problems/kth-ancestor-of-a-tree-node/
class TreeAncestor:
    def __init__(self, N: int, parent: list[int]):
        # Store the ancestors into a sparse table
        self.ancestors: dict[int, collections.defaultdict[int, int]] = {}

        # Store for level 1 (2 ** 0 => 1)
        pending: list[int] = []
        level = 0
        for node in range(N):
            self.ancestors[node] = collections.defaultdict(lambda: -1)
            self.ancestors[node][level] = parent[node]
            if self.ancestors[node][level] != -1:
                pending.append(node)

        # Compute next level of ancestors until we hit -1 for all nodes
        level += 1
        while pending:
            still_pending: list[int] = []
            for node in pending:
                self.ancestors[node][level] = self.ancestors[self.ancestors[node][level - 1]][level - 1]
                if self.ancestors[node][level] != -1:
                    still_pending.append(node)
            pending, level = still_pending, level + 1

    def getKthAncestor(self, node: int, K: int) -> int:
        while K > 0 and node != -1:
            jump = int(math.log2(K))
            node = self.ancestors[node][jump]
            K -= 1 << jump # k - (2 ** jump)

        return node

# Testing the solution
tree_ancestor = TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2])
assert tree_ancestor.getKthAncestor(5, 2) == 0
assert tree_ancestor.getKthAncestor(6, 3) == -1
assert tree_ancestor.getKthAncestor(6, 0) == 6
assert tree_ancestor.getKthAncestor(6, 9) == -1
```

</div>

<div id="64cb4a96" class="cell markdown"
papermill="{&quot;duration&quot;:6.457e-3,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.902377&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.895920&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

CP Practice - LCA

</div>

<div id="a6f4756f" class="cell code" execution_count="28"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:09.916581Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:09.916267Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:09.930577Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:09.930038Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2655e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.931597&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.908942&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def sloth_naptime(N: int, edges: list[tuple[int, int]], Q: int, queries: list[tuple[int, int, int]]) -> list[int]:
    def get_distances_from_lca(N1: int, N2: int) -> tuple[int, int]:
        n1, n2 = N1, N2

        # Make sure that we start at the same heights
        if heights[n1] > heights[n2]:
            n1 = get_kth_ancestor(n1, heights[n1] - heights[n2])
        if heights[n1] < heights[n2]:
            n2 = get_kth_ancestor(n2, heights[n2] - heights[n1])

        # If n1 had been the ancestor of n2
        if n1 == n2:
            lca = n1
        else:
            # Run a `logrithmic` search, starting at max power reducing it
            # If match do nothing, otherwise update n1, n2 to where it didn't match
            for power in range(MAX_POWER - 1, -1, -1):
                if ancestors[n1][power] != ancestors[n2][power]:
                    n1, n2 = ancestors[n1][power], ancestors[n2][power]
            lca = ancestors[n1][0]

        return  heights[N1] - heights[lca], heights[N2] - heights[lca]

    def get_kth_ancestor(n: int, k: int) -> int:
        while k > 0 and n != -1:
            jump = int(math.log2(k))
            n, k = ancestors[n][jump], k - (1 << jump)

        return n

    # Max width of ancestors
    MAX_POWER = math.ceil(math.log2(N)) + 1
    ancestors: list[list[int]] = [[-1] * MAX_POWER for i in range(N + 1)]
    heights: dict[int, int] = {}

    # Convert edges into adjacency list
    adjl: collections.defaultdict[int, list[int]] = collections.defaultdict(list)
    for n1, n2 in edges:
        adjl[n1].append(n2)
        adjl[n2].append(n1)

    # Do a DFS traversal, compute the ancestors and the depth
    stack: list[tuple[int, int, int]] = [(1, 0, 0)]
    while stack:
        curr, prev, height = stack.pop()
        ancestors[curr][0] = prev
        heights[curr] = height
        for next_ in adjl[curr]:
            if next_ != prev:
                stack.append((next_, curr, height + 1))

    # Compute the ancestors for powers up to MAX_N
    for power in range(1, MAX_POWER):
        for node in range(1, N + 1):
            ancestors[node][power] = ancestors[ancestors[node][power - 1]][power - 1]

    # Compute the results
    results: list[int] = []
    for n1, n2, E in queries:
        L, R = get_distances_from_lca(n1, n2)
        if E <= L:
            results.append(get_kth_ancestor(n1, E))
        elif E < L + R:
            results.append(get_kth_ancestor(n2, L + R - E))
        else:
            results.append(n2)

    return results

# Testing the solution
assert sloth_naptime(5, [(4,2), (1,4), (5,4), (3,4)], 6, [(3,5,2), (3,5,4), (1,5,5), (4,5,4), (1,5,4), (3,5,0)]) == [5, 5, 5, 5, 5, 3]
assert sloth_naptime(3, [(3,2), (2,1)], 3, [(2,2,2), (1,1,2), (3,3,3)]) == [2,1,3]
assert sloth_naptime(21, [(6, 9), (8, 1), (11, 10), (18, 17), (5, 17), (14, 7), (11, 14), (4, 18), (17, 13), (1, 14), (16, 21), (19, 6), (19, 14), (5, 9), (14, 16), (3, 20), (19, 15), (7, 2), (17, 3), (12, 7)], 21, [(15, 12, 16), (14, 10, 8), (17, 2, 16), (6, 14, 5), (4, 9, 5), (16, 16, 18), (18, 18, 12), (10, 8, 10), (7, 4, 3), (3, 10, 11), (11, 12, 4), (4, 20, 3), (13, 16, 17), (6, 2, 1), (17, 6, 13), (1, 9, 14), (9, 11, 9), (12, 6, 1), (14, 14, 19), (12, 12, 6), (16, 13, 4)]) == [12, 10, 2, 14, 9, 16, 18, 8, 6, 10, 12, 3, 16, 19, 6, 9, 11, 7, 14, 12, 9]
```

</div>

<div id="92407e00" class="cell code" execution_count="29"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:09.945715Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:09.945453Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:09.958940Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:09.958406Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.18e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.959964&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.938164&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Correct but memory limit exceeded
def cycle_free_flow(N: int, E: int, edges: list[tuple[int, int, int]], Q: int, queries: list[tuple[int, int]]) -> list[int]:
    def get_min_flow(N1: int, N2: int) -> int:
        n1, n2 = N1, N2
        flow: float = math.inf
        if heights[n1] > heights[n2]:
            n1, flow = get_kth_ancestor(n1, heights[n1] - heights[n2])
        if heights[n2] > heights[n1]:
            n2, flow = get_kth_ancestor(n2, heights[n2] - heights[n1])

        if n1 == n2:
            return int(flow)

        # Run a 'binary search'
        for power in range(MAX_POWER - 1, -1, -1):
            (n1_ancestor, n1_flow), (n2_ancestor, n2_flow) = ancestors[n1][power], ancestors[n2][power]
            if n1_ancestor != n2_ancestor:
                n1, n2, flow = n1_ancestor, n2_ancestor, min(n1_flow, n2_flow)

        return int(min(flow, ancestors[n1][0][1], ancestors[n2][0][1]))

    def get_kth_ancestor(curr: int, K: int) -> tuple[int, float]:
        flow: float = math.inf
        while curr != -1 and K > 0:
            jump = int(math.log2(K))
            curr, next_flow = ancestors[curr][jump]
            flow = min(flow, next_flow)
            K = K - (1 << jump)

        return curr, flow

    # Maximum power for computing the ancestors
    MAX_POWER = int(math.log2(N)) + 1
    ancestors: list[list[tuple[int, int]]] = [[(-1, 0)] * MAX_POWER for i in range(N + 1)]
    heights: dict[int, int] = dict()

    # Convert edges into Adjl list
    adjl: collections.defaultdict[int, list[tuple[int, int]]] = collections.defaultdict(list)
    for n1, n2, w in edges:
        adjl[n1].append((n2, w))
        adjl[n2].append((n1, w))

    # Run DFS and compute the level 1 ancestors
    stack: list[tuple[int, int]] = [(1, 0)]
    ancestors[1][0] = (0, 0)
    while stack:
        curr, height = stack.pop()
        for next_node, next_weight in adjl[curr]:
            if next_node not in heights:
                heights[next_node] = height + 1
                ancestors[next_node][0] = (curr, next_weight)
                stack.append((next_node, height + 1))

    # Compute the ancestors
    for power in range(1, MAX_POWER):
        for node in range(1, N + 1):
            prev_ancestor, prev_flow = ancestors[node][power - 1]
            next_ancestor, next_flow = ancestors[prev_ancestor][power - 1]
            ancestors[node][power] = next_ancestor, min(prev_flow, next_flow)

    # Process each query
    results: list[int] = []
    for n1, n2 in queries:
        results.append(get_min_flow(n1, n2))

    return results

# Testing the solution
assert cycle_free_flow(10, 9, [(7,10,1680), (10,5,18380), (5,8,8111), (8,9,22597), (3,10,27859), (4,3,9944), (6,10,26721), (1,10,4444), (2,5,2282)], 10, [(10,7), (4,2), (5,4), (9,6), (5,3), (4,10), (4,5), (2,1), (6,9), (9,4)]) == [1680, 2282, 9944, 8111, 18380, 9944, 9944, 2282, 8111, 8111]
assert cycle_free_flow(3, 3, [(3,2,4814), (2,1,1832)], 3, [(2,1), (1,2), (3,1)]) == [1832, 1832, 1832]
assert cycle_free_flow(5, 4, [(4,2,10348), (1,4,2690), (5,4,9807), (3,4,8008)], 5, [(5,4), (1,5)]) == [9807, 2690]
assert cycle_free_flow(5, 4, [(1,3,2653), (4,1,322), (5,1,8657), (2,4,4896)], 5, [(4,2), (2,5), (1,3), (4,5)]) == [4896, 322, 2653, 322]
```

</div>

<div id="b6f81d8c" class="cell code" execution_count="30"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:09.974599Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:09.974101Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:09.978108Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:09.977611Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.256e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.979273&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.966713&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def sortPeople(names: list[str], heights: list[int]) -> list[str]:
    return list(map(lambda x: x[1], sorted(zip(heights, names), reverse=True)))

# Testing the solution
assert sortPeople(["Mary","John","Emma"], [180,165,170]) == ["Mary","Emma","John"]
assert sortPeople(["Alice","Bob","Bob"], [155,185,150]) == ["Bob","Alice","Bob"]
```

</div>

<div id="76ca025a" class="cell code" execution_count="31"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:09.993668Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:09.993335Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:09.997672Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:09.997246Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.2754e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:09.998726&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:09.985972&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def frequencySort(nums: list[int]) -> list[int]:
    freq: collections.Counter = collections.Counter(nums)
    result: list[int] = []
    for k, v in sorted(freq.most_common(), key=lambda x: (x[1], -x[0])):
        for i in range(v):
            result.append(k)

    return result

# Testing the solution
assert frequencySort([1,1,2,2,2,3]) == [3,1,1,2,2,2]
assert frequencySort([2,3,1,3,2]) == [1,3,3,2,2]
```

</div>

<div id="93584f24" class="cell markdown"
papermill="{&quot;duration&quot;:6.495e-3,&quot;end_time&quot;:&quot;2024-07-26T15:58:10.011797&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:10.005302&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Codeforces Practice - LCA

</div>

<div id="2316de6e" class="cell code" execution_count="32"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:10.026187Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:10.025748Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:10.035324Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:10.034793Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.8113e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:10.036394&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:10.018281&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def tree_queries_better(N: int, Q: int, edges: list[tuple[int, int]], queries: list[tuple[int, list[int]]]) -> list[bool]:
    """
    Thought process:
    For each query figure out the deepest node
    Iterate through each node in current query - `node`:
        - Init curr as deepest
        - Get kth ancestor such that curr and node are at same level
        - Either curr == node or node in adjl[ancestor[curr][0]]
    """

    # Init variables
    MAX_POWER = int(math.log2(N)) + 1
    ancestors: list[list[int]] = [[0 for j in range(MAX_POWER)] for i in range(N + 1)]

    @functools.cache
    def get_kth_ancestor(N: int, K: int) -> int:
        while N != 0 and K > 0:
            jump = int(math.log2(K))
            N, K = ancestors[N][jump], K - (1 << jump)

        return N

    # Create adjacency list
    adjl: collections.defaultdict[int, set[int]] = collections.defaultdict(set)
    for n1, n2 in edges:
        adjl[n1].add(n2)
        adjl[n2].add(n1)

    # Do a DFS to find level 1 ancestor and the height
    heights: dict[int, int] = dict()
    stack: list[tuple[int, int, int]] = [(1, 0, 0)]
    while stack:
        curr, prev, height = stack.pop()
        heights[curr] = height
        ancestors[curr][0] = prev
        for next_node in adjl[curr]:
            if next_node not in heights:
                stack.append((next_node, curr, height + 1))

    # Compute the ancestors
    for power in range(1, MAX_POWER):
        for node in range(1, N + 1):
            ancestors[node][power] = ancestors[ancestors[node][power - 1]][power - 1]

    # Process the queries
    results: list[bool] = []
    for _, query in queries:
        # Check the deepest node
        deepest_node: int = 1
        for n in query:
            if heights[n] > heights[deepest_node]:
                deepest_node = n

        # Process again through each node
        for n in query:
            curr = get_kth_ancestor(deepest_node, heights[deepest_node] - heights[n])
            if curr != n and n not in adjl[ancestors[curr][0]]:
                results.append(False)
                break
        else:
            results.append(True)

    return results

# Testing the solution
assert tree_queries_better(10, 6, [(1,2), (1,3), (1,4), (2,5), (2,6), (3,7), (7,8), (7,9), (9,10)], [(4, [3,8,9,10]), (3, [2,4,6]), (3, [2,1,5]), (3, [4,8,2]), (2, [6,10]), (3, [5,4,7])]) == [True, True, True, True, False, False]
```

</div>

<div id="f45fab4d" class="cell code" execution_count="33"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:10.051326Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:10.050876Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:10.059503Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:10.059054Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.7325e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:10.060573&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:10.043248&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def tree_queries(N: int, Q: int, edges: list[tuple[int, int]], queries: list[tuple[int, list[int]]]) -> list[bool]:
    # Initialize variables
    TIME: int = 0
    TIN: list[int] = [-1 for i in range(N + 1)]
    TOUT: list[int] = [-1 for i in range(N + 1)]
    AH: dict[int, tuple[int, int]] = dict()

    # Edges to Adj list
    adjl: collections.defaultdict[int, list[int]] = collections.defaultdict(list)
    for n1, n2 in edges:
        adjl[n1].append(n2)
        adjl[n2].append(n1)

    # DFS traversal to keep track of in, out times; the ancestor and height
    stack: list[tuple[int, int, int, int]] = [(1, 1, 0, 0)]
    while stack:
        curr, prev, idx, height = stack[-1]
        AH[curr] = prev, height

        # If adding for the first time
        if idx == 0:
            TIN[curr] = TIME
            TIME += 1

        # If all its children have been visited
        if idx == len(adjl[curr]):
            stack.pop()
            TOUT[curr] = TIME
            TIME += 1

        # Children pending visit
        else:
            stack[-1] = (curr, prev, idx + 1, height)
            if prev != adjl[curr][idx]:
                stack.append((adjl[curr][idx], curr, 0, height + 1))

    # Solve for each query
    results: list[bool] = []
    for q, query in queries:

        # Find the deepest node
        deepest_node: int = 1
        for n in query:
            if AH[n][1] > AH[deepest_node][1]:
                deepest_node = n

        # Check if each node is ancestor of deepest_node
        result = all(map(lambda x: TIN[AH[x][0]] <= TIN[deepest_node] and  TOUT[deepest_node] <= TOUT[AH[x][0]], query))
        results.append(result)

    return results

# Testing the solution
assert tree_queries(10, 6, [(1,2), (1,3), (1,4), (2,5), (2,6), (3,7), (7,8), (7,9), (9,10)], [(4, [3,8,9,10]), (3, [2,4,6]), (3, [2,1,5]), (3, [4,8,2]), (2, [6,10]), (3, [5,4,7])]) == [True, True, True, True, False, False]
```

</div>

<div id="d205c5ee" class="cell code" execution_count="34"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:10.075470Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:10.074966Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:10.087742Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:10.087264Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.1428e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:10.088824&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:10.067396&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def one_tree_queries(N: int, edges: list[tuple[int, int]], Q: int, queries: list[tuple[int, int, int, int, int]]) -> list[bool]:
    """
    Per question, we can travel any node/edge any number of times.
    Assume path exists from s-e, we can introduce arbitrary 2Z (Z: 1 .. inf).
    Since it is 2Z, parity (odd / even) would remain same. So it suffices to check if
    we have a length of matching parity as k that is less than or equal to k

    Given query: h1, h2, s, e, k
    Paths possible:
        1. Direct path: s - e
        2. Indirect path via helpers: s - h1 - h2 - e
        3. Indirect path via helpers: s - h2 - h1 - e
    """

    def get_kth_ancestor(curr: int, K: int) -> int:
        while curr != -1 and K > 0:
            jump = int(math.log2(K))
            curr, K = ancestors[curr][jump], K - (1 << jump)
        return curr

    def compute_distance(N1: int, N2: int) -> int:
        # Compute LCA; dist from (N1 - LCA) + (N2 - LCA)
        n1, n2 = N1, N2
        if heights[n1] > heights[n2]:
            n1 = get_kth_ancestor(n1, heights[n1] - heights[n2])
        if heights[n2] > heights[n1]:
            n2 = get_kth_ancestor(n2, heights[n2] - heights[n1])

        if n1 == n2:
            lca = n1
        else:
            # `log` search to find LCA
            for power in range(MAX_POWER - 1, -1, -1):
                if ancestors[n1][power] != ancestors[n2][power]:
                    n1, n2 = ancestors[n1][power], ancestors[n2][power]
            lca = ancestors[n1][0]

        return abs(heights[lca] - heights[N1]) + abs(heights[lca] - heights[N2])

    # Initialize variables
    MAX_POWER = int(math.log2(N)) + 1
    ancestors: list[list[int]] = [[-1] * MAX_POWER for i in range(N + 1)]
    heights: dict[int, int] = {}
    adjl: collections.defaultdict[int, list[int]] = collections.defaultdict(list)

    # Convert edges into adjl
    for n1, n2 in edges:
        adjl[n1].append(n2)
        adjl[n2].append(n1)

    # DFS to compute the ancestors
    stack: list[tuple[int, int, int]] = [(1, 0, 0)]
    while stack:
        curr, prev, height = stack.pop()
        ancestors[curr][0] = prev
        heights[curr] = height
        for next_node in adjl[curr]:
            if next_node not in heights:
                stack.append((next_node, curr, height + 1))

    # Compute ancestors
    for power in range(1, MAX_POWER):
        for node in range(1, N + 1):
            if ancestors[node][power - 1] != -1:
                ancestors[node][power] = ancestors[ancestors[node][power - 1]][power - 1]

    results: list[bool] = []
    for h1, h2, s, e, k in queries:
        # Precompute distances
        SE, SH1, SH2, H1E, H2E = compute_distance(s, e), compute_distance(s, h1), compute_distance(s, h2), compute_distance(h1, e), compute_distance(h2, e)
        SH1H2E = SH1 + 1 + H2E
        SH2H1E = SH2 + 1 + H1E
        # Direct path
        if SE % 2 == k % 2 and SE <= k:
            results.append(True)
        # Indirect path, via helper1
        elif SH1H2E % 2 == k % 2 and SH1H2E <= k:
            results.append(True)
        # Indirect path, via helper2
        elif SH2H1E % 2 == k % 2 and SH2H1E <= k:
            results.append(True)
        else:
            results.append(False)

    return results

# Testing the solution
assert one_tree_queries(5, [(1,2), (2,3), (3,4), (4,5)], 5, [(1,3,1,1,1), (1,3,1,2,2), (1,4,1,3,2), (1,4,1,3,3), (4,2,3,3,9), (5,2,3,3,9)]) == [False, True, True, False, True, False]
assert one_tree_queries(3, [(1,2), (2,3)], 2, [(1,3,1,1,1), (1,3,1,1,2), (1,3,1,1,3), (1,3,1,1,4),(3,1,1,1,1)]) == [False, True, True, True, False]
```

</div>

<div id="42f01a27" class="cell code" execution_count="35"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:10.103793Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:10.103476Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:10.113819Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:10.113272Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.9194e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:10.114974&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:10.095780&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def blood_cousins(N: int, parents: list[int], Q: int, queries: list[tuple[int, int]]) -> list[int]:
    """
    Note that for this problem, there can be multiple components

    For each query (v, p)
    1. Find the pth ancestor of v: u (Using LCA)
    2. Compute the number of nodes of subtree with `u` as root at depth[v] (Using TIN, TOUT times and binary search)

    On second part, store the tin, tout times and store the tin times into a vector depth wise.
    Count of nodes of subtree 'u' and depth 'd' is UB_index(depth[v] - tout[u]) - LB_index(depth[v], tin[u])
    """

    def get_kth_ancestor(curr: int, K: int) -> int:
        while curr != 0 and K > 0:
            jump = int(math.log2(K))
            curr, K = ancestors[curr][jump], K - (1 << jump)
        return curr

    # Initialize variables
    MAX_POWER = int(math.log2(N)) + 1
    TIME: int = 0
    ancestors: list[list[int]] = [[0] * MAX_POWER for i in range(N + 1)]
    TIN: list[int] = [-1 for i in range(N + 1)]
    TOUT: list[int] = [-1 for i in range(N + 1)]
    heights: dict[int, int] = {}
    depth_map: collections.defaultdict[int, list] = collections.defaultdict(list)
    adjl: collections.defaultdict[int, list] = collections.defaultdict(list)

    # Parents to Adj List
    for i, p in enumerate(parents, start=1):
        adjl[p].append(i)

    # DFS search to compute ancestors, tin, tout times and the heights
    stack: list[tuple[int, int, int, int]] = [(i, 0, 0, 0) for i in adjl[0][::-1]]
    while stack:
        curr, prev, height, idx = stack[-1]
        if idx == 0:
            TIN[curr] = TIME
            depth_map[height].append(TIME)
            heights[curr] = height
            ancestors[curr][0] = prev
            TIME += 1
        if idx == len(adjl[curr]):
            stack.pop()
            TOUT[curr] = TIME
            TIME += 1
        else:
            stack[-1] = curr, prev, height, idx + 1
            stack.append((adjl[curr][idx], curr, height + 1, 0))

    # Compute ancestors
    for power in range(1, MAX_POWER):
        for node in range(1, N + 1):
            if ancestors[node][power - 1] != -1:
                ancestors[node][power] = ancestors[ancestors[node][power - 1]][power - 1]

    # Process the queries
    results: list[int] = []
    for V, P in queries:
        U = get_kth_ancestor(V, P)
        if U == 0:
            results.append(0)
        else:
            UB = bisect.bisect_right(depth_map[heights[V]], TOUT[U])
            LB = bisect.bisect_left(depth_map[heights[V]], TIN[U])
            results.append(UB - LB - 1)

    return results

# Testing the solution
assert blood_cousins(6, [0,1,1,0,4,4], 7, [(1,1), (1,2), (2,1), (2,2), (4,1), (5,1), (6,1)]) == [0, 0, 1, 0, 0, 1, 1]
```

</div>

<div id="8a1c7b23" class="cell code" execution_count="36"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:10.130176Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:10.129714Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:10.134022Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:10.133498Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.3221e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:10.135192&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:10.121971&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def two_buttons(N: int, M: int, steps: int = 0) -> int:
    if M == N:
        return steps
    elif M < N:
        return steps + N - M
    else:
        return two_buttons(N, M // 2, steps + 1) if M % 2 == 0 else two_buttons(N, (M + 1) // 2, steps + 2)

# Testing the solution
assert two_buttons(7, 12) == 2
assert two_buttons(9, 1) == 8
assert two_buttons(1, 9) == 7
```

</div>

<div id="6c55d24b" class="cell code" execution_count="37"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:10.149967Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:10.149709Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:10.154468Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:10.153948Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.3464e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:10.155578&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:10.142114&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def party(N: int, supervisor: list[int]) -> int:
    # Convert edges into adjl
    adjl: collections.defaultdict[int, list[int]] = collections.defaultdict(list)
    for emp, boss in enumerate(supervisor, start=1):
        adjl[boss].append(emp)

    # Compute the max height
    max_height = 0
    stack: list[tuple[int, int]] = [(i, 1) for i in adjl[-1]]
    while stack:
        curr, height = stack.pop()
        max_height = max(max_height, height)
        for next_node in adjl[curr]:
            stack.append((next_node, height + 1))

    return max_height

# Testing the solution
assert party(5, [-1, 1, 2, 1, -1]) == 3
```

</div>

<div id="fc1e8098" class="cell code" execution_count="38"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:10.171134Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:10.170579Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:10.176718Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:10.176191Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.5093e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:10.177793&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:10.162700&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def kefa_and_park(N: int, K: int, cats: list[int], edges: list[tuple[int, int]]) -> int:
    # Convert edges into adjacency list
    adjl: collections.defaultdict[int, list[int]] = collections.defaultdict(list)
    for n1, n2 in edges:
        adjl[n1].append(n2)
        adjl[n2].append(n1)

    # Do a DFS traversal until we reach the leaf node
    # If along a path we have more than K consequtive cats, break
    count = 0
    stack: list[tuple[int, int, int]] = [(1, 0, 0)]
    while stack:
        curr, prev, cat_count = stack.pop()
        is_leaf, safe_path = True, cats[curr - 1] + cat_count <= K
        if safe_path:
            for next_node in adjl[curr]:
                if next_node != prev:
                    is_leaf = False
                    stack.append((next_node, curr, cat_count + 1 if cats[curr - 1] else 0))

        count += int(is_leaf and safe_path)

    return count

# Testing the solution
assert kefa_and_park(7, 1, [1,0,1,1,0,0,0], [(1,2), (1,3), (2,4), (2,5), (3,6), (3,7)]) == 2
assert kefa_and_park(4, 1, [1,1,0,0], [(1,2), (1,3), (1,4)]) == 2
```

</div>

<div id="6854ca7d" class="cell code" execution_count="39"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-07-26T15:58:10.193004Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-07-26T15:58:10.192443Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-07-26T15:58:10.200259Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-07-26T15:58:10.199796Z&quot;}"
papermill="{&quot;duration&quot;:1.6545e-2,&quot;end_time&quot;:&quot;2024-07-26T15:58:10.201343&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-07-26T15:58:10.184798&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def cyclic_components(N: int, E: int, edges: list[tuple[int, int]]) -> int:
    # Convert edges into adjl
    adjl: collections.defaultdict[int, list[int]] = collections.defaultdict(list)
    for n1, n2 in edges:
        adjl[n1].append(n2)
        adjl[n2].append(n1)

    # Do a DFS traversal and colors components
    color: int = 0
    components_with_cycle: dict[int, int] = dict()
    node_colors: dict[int, int] = dict()
    for node in range(1, N + 1):
        if node not in node_colors:
            visit_count = len(node_colors)
            color, is_cyclic = color + 1, False
            stack: list[tuple[int, int]] = [(node, 0)]
            while stack:
                curr, prev = stack.pop()
                node_colors[curr] = color
                for next_node in adjl[curr]:
                    if next_node != prev:
                        if next_node in node_colors:
                            is_cyclic = True
                        else:
                            stack.append((next_node, curr))

            if is_cyclic:
                components_with_cycle[color] = len(node_colors) - visit_count

    # Compute the number of edges for a component
    edge_counts: dict[int, int] = dict()
    for n1, n2 in edges:
        if node_colors[n1] in components_with_cycle:
            edge_counts[node_colors[n1]] = edge_counts.get(node_colors[n1], 0) + 1

    # Count cyclic components: edge_count == node_count
    result = 0
    for color in components_with_cycle:
        if components_with_cycle[color] == edge_counts[color]:
            result += 1

    return result

# Testing the solution
assert cyclic_components(5, 4, [(1,2), (3,4), (5,4), (3,5)]) == 1
assert cyclic_components(17, 15, [(1,8), (1,12), (5,11), (11,9), (9,15), (15,5), (4,13), (3,13), (4,3), (10,16), (7,10), (16,7), (14,3), (14,4), (17,6)]) == 2
```

</div>
