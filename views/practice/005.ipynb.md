---
jupyter:
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
  language_info:
    codemirror_mode:
      name: ipython
      version: 3
    file_extension: .py
    mimetype: text/x-python
    name: python
    nbconvert_exporter: python
    pygments_lexer: ipython3
    version: 3.11.9
  nbformat: 4
  nbformat_minor: 5
  papermill:
    default_parameters: {}
    duration: 1.844913
    end_time: "2024-06-26T17:41:00.137269"
    environment_variables: {}
    input_path: practice/005.ipynb
    output_path: practice/005.ipynb
    parameters: {}
    start_time: "2024-06-26T17:40:58.292356"
    version: 2.6.0
---

<div id="fa51d761" class="cell code" execution_count="1"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-06-26T17:40:59.424243Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-06-26T17:40:59.423852Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-06-26T17:40:59.774306Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-06-26T17:40:59.773781Z&quot;}"
papermill="{&quot;duration&quot;:0.35601,&quot;end_time&quot;:&quot;2024-06-26T17:40:59.775754&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-06-26T17:40:59.419744&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
from typing import List, Optional, Generator
import pandas as pd
import numpy as np
import sqlite3
import re
import io
import math
import collections
import itertools
import functools
import random
import string
import tqdm
import bisect
import heapq

conn = sqlite3.connect(":memory:")

def regexp(expr, item):
    reg = re.compile(expr)
    return reg.search(item) is not None

def read_lc_df(s: str, dtypes: dict[str, str]=dict()) -> pd.DataFrame:
    temp = pd.read_csv(io.StringIO(s), sep="|", skiprows=2)
    temp = temp.iloc[1:-1, 1:-1]
    temp.columns = temp.columns.map(str.strip)
    temp = temp.map(lambda x: x if type(x) != str else None if x.strip() == 'null' else x.strip())
    temp = temp.astype(dtypes)
    return temp

conn.create_function("REGEXP", 2, regexp)
```

</div>

<div id="db473660" class="cell markdown"
papermill="{&quot;duration&quot;:2.281e-3,&quot;end_time&quot;:&quot;2024-06-26T17:40:59.780664&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-06-26T17:40:59.778383&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

#### Helper for Binary tree problems

</div>

<div id="6e8896c0" class="cell code" execution_count="2"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-06-26T17:40:59.786503Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-06-26T17:40:59.785930Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-06-26T17:40:59.793218Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-06-26T17:40:59.792758Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.1551e-2,&quot;end_time&quot;:&quot;2024-06-26T17:40:59.794370&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-06-26T17:40:59.782819&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
class BinaryTreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

    def to_list(self):
        to_visit = [self]
        visited = []
        while len(to_visit) > 0:
            curr = to_visit.pop(0)
            if curr:
                to_visit.append(curr.left)
                to_visit.append(curr.right)
                visited.append(curr.val)
            else:
                visited.append(curr)

        while visited and not visited[-1]:
            visited.pop()

        return visited

    def __str__(self):
        return str(self.val)

    @staticmethod
    def from_array(nums: list[int|None]):
        '''Create a Tree from a list of nums. Returns the root node.'''
        if len(nums) == 0:
            return None
        elif len(nums) == 1:
            return BinaryTreeNode(nums[0])
        else:
            forest = [BinaryTreeNode(nums[0])]
            parent_idx = -1
            for i in range(1, len(nums)):

                curr = None
                if nums[i] is not None:
                    curr = BinaryTreeNode(nums[i])
                    forest.append(curr)

                if i % 2 == 1:
                    parent_idx += 1
                    forest[parent_idx].left = curr
                else:
                    forest[parent_idx].right = curr

        return forest[0]
```

</div>

<div id="de5b1765" class="cell markdown"
papermill="{&quot;duration&quot;:2.169e-3,&quot;end_time&quot;:&quot;2024-06-26T17:40:59.798878&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-06-26T17:40:59.796709&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

#### Helper for Singly Linked lists

</div>

<div id="e736c8a5" class="cell code" execution_count="3"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-06-26T17:40:59.804477Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-06-26T17:40:59.804020Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-06-26T17:40:59.808691Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-06-26T17:40:59.808138Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:8.669e-3,&quot;end_time&quot;:&quot;2024-06-26T17:40:59.809823&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-06-26T17:40:59.801154&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

    def __str__(self):
        return str(self.val)

    @staticmethod
    def to_singly_linked_list(nums: list[int]):
        root = prev = None
        for n in nums:
            curr = ListNode(n)
            # Init once
            if not root:
                root = curr
            if prev:
                prev.next = curr
            prev = curr

        return root

    def to_list(self) -> list[int]:
        result = []
        curr = self
        while curr:
            result.append(curr.val)
            curr = curr.next
        return result
```

</div>

<div id="cd635853" class="cell markdown"
papermill="{&quot;duration&quot;:2.193e-3,&quot;end_time&quot;:&quot;2024-06-26T17:40:59.814266&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-06-26T17:40:59.812073&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Codeforces practice

</div>

<div id="df35356a" class="cell code" execution_count="4"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-06-26T17:40:59.819861Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-06-26T17:40:59.819396Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-06-26T17:40:59.824337Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-06-26T17:40:59.823749Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:8.895e-3,&quot;end_time&quot;:&quot;2024-06-26T17:40:59.825369&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-06-26T17:40:59.816474&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://codeforces.com/problemset/problem/1984/B
def large_addition(N: int) -> bool:
    if N < 10:
        return False
    else:
        N_str: str = str(N)
        length = len(N_str)
        for i in range(length):
            if i == 0 and N_str[i] != '1':
                return False
            elif i == length - 1 and N_str[i] == '9':
                return False
            elif i not in (0, length - 1) and N_str[i] == '0':
                return False

        return True

# Testing the solution
assert large_addition(1393938) == True
assert large_addition(200) == False
assert large_addition(10) == True
```

</div>

<div id="80b62de1" class="cell markdown"
papermill="{&quot;duration&quot;:3.031e-3,&quot;end_time&quot;:&quot;2024-06-26T17:40:59.830620&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-06-26T17:40:59.827589&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

LC Virtual: 25th June 2024
<https://leetcode.com/contest/smarking-algorithm-contest-3/>

</div>

<div id="ec2db856" class="cell code" execution_count="5"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-06-26T17:40:59.836114Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-06-26T17:40:59.835774Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-06-26T17:40:59.839942Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-06-26T17:40:59.839431Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:8.238e-3,&quot;end_time&quot;:&quot;2024-06-26T17:40:59.841094&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-06-26T17:40:59.832856&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Q1
# https://www.youtube.com/watch?v=x8T11yRLIyY
def minMoves(nums: list[int]) -> int:
    """
    Intution: Instead of increasing all n - 1 elements by 1 each time, try to decrement
    the max element to the smallest element. Relative distances between numbers are the same.
    """
    nums.sort()
    result = 0
    for i in range(len(nums) - 1, -1, -1):
        result += nums[i] - nums[0]
    return result

# Testing the solution
assert minMoves([1,2,3,4]) == 6
assert minMoves([1,2,3]) == 3
```

</div>

<div id="46f751bf" class="cell code" execution_count="6"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-06-26T17:40:59.846605Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-06-26T17:40:59.846274Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-06-26T17:40:59.851547Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-06-26T17:40:59.851109Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:9.356e-3,&quot;end_time&quot;:&quot;2024-06-26T17:40:59.852666&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-06-26T17:40:59.843310&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Q2
def numberOfBoomerangs(points: list[list[int]]) -> int:
    def distance(pt1: list[int], pt2: list[int]) -> float:
        return math.sqrt(((pt1[0] - pt2[0]) ** 2) + ((pt1[1] - pt2[1]) ** 2))

    boommerangs: int = 0
    N = len(points)
    for i in range(N):
        curr = points[i]
        distances: dict[float, int] = dict()
        for j in range(N):
            if j != i:
                dist = distance(points[i], points[j])
                distances[dist] = distances.get(dist, 0) + 1

        for count in distances.values():
            boommerangs += math.perm(count, 2)

    return boommerangs

# Testing the solution
assert numberOfBoomerangs([[0,0],[1,0],[2,0]]) == 2
assert numberOfBoomerangs([[1,1],[2,2],[3,3]]) == 2
assert numberOfBoomerangs([[1,1]]) == 0
```

</div>

<div id="06c17597" class="cell code" execution_count="7"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-06-26T17:40:59.858343Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-06-26T17:40:59.857889Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-06-26T17:40:59.863091Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-06-26T17:40:59.862660Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:9.116e-3,&quot;end_time&quot;:&quot;2024-06-26T17:40:59.864141&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-06-26T17:40:59.855025&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Q3
def findMinArrowShots(points: list[list[int]]) -> int:
    # Sort by end and merge the start, end
    points.sort(key=lambda x: (x[1], x[0]))

    # Merge the intervals
    merged_intervals: list[tuple[int, int]] = []
    for start, end in points:
        if merged_intervals and merged_intervals[-1][1] >= start:
            merged_intervals[-1] = max(merged_intervals[-1][0], start), min(merged_intervals[-1][1], end)
        else:
            merged_intervals.append((start, end))

    return len(merged_intervals)

# Testing the solution
assert findMinArrowShots([[10,16],[2,8],[1,6],[7,12]]) == 2
assert findMinArrowShots([[1,2],[3,4],[5,6],[7,8]]) == 4
assert findMinArrowShots([[1,2],[2,3],[3,4],[4,5]]) == 2
```

</div>

<div id="602ae596" class="cell code" execution_count="8"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-06-26T17:40:59.869842Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-06-26T17:40:59.869336Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-06-26T17:40:59.874145Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-06-26T17:40:59.873622Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:8.672e-3,&quot;end_time&quot;:&quot;2024-06-26T17:40:59.875145&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-06-26T17:40:59.866473&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Q4
def numberOfArithmeticSlicesBrute(nums: list[int]) -> int:
    def is_valid(sub: list[int]) -> bool:
        if len(sub) < 3:
            return False
        else:
            diff = sub[1] - sub[0]
            for i in range(len(sub) - 1):
                if sub[i + 1] - sub[i] != diff:
                    return False
            return True

    count = 0
    def backtrack(i: int, subseq: list[int]):
        if i == N:
            count += is_valid(subseq)
        else:
            subseq.append(nums[i])
            backtrack(i + 1, subseq)
            subseq.pop()
            backtrack(i + 1, subseq)

    N = len(nums)
    backtrack(0, [])
    return count
```

</div>

<div id="f1e64142" class="cell code" execution_count="9"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-06-26T17:40:59.880965Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-06-26T17:40:59.880513Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-06-26T17:40:59.885172Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-06-26T17:40:59.884715Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:8.785e-3,&quot;end_time&quot;:&quot;2024-06-26T17:40:59.886267&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-06-26T17:40:59.877482&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Upsolving
# https://www.youtube.com/watch?v=YIMwwT9JdIE
def numberOfArithmeticSlices(nums: list[int]) -> int:
    """
    Ending at index 'j' what is maximum number of arthimetic subsequences that I can form >= 2
    """
    N = len(nums)
    dp: list[collections.defaultdict[int, int]] = [collections.defaultdict(int) for _ in range(N)]
    sub_count = dp_sum = 0
    for j in range(N):
        for i in range(j):
            delta = nums[i] - nums[j]
            dp[j][delta] += dp[i][delta] + 1
            sub_count, dp_sum = sub_count + 1, dp_sum + dp[i][delta] + 1

    return dp_sum - sub_count

# Testing the solution
assert numberOfArithmeticSlices([2,4,6,8,10]) == 7
assert numberOfArithmeticSlices([7,7,7,7,7]) == 16
```

</div>

<div id="79053be1" class="cell markdown"
papermill="{&quot;duration&quot;:2.866e-3,&quot;end_time&quot;:&quot;2024-06-26T17:40:59.891595&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-06-26T17:40:59.888729&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

LC VC: June 26th 2024

</div>

<div id="2e438aa0" class="cell code" execution_count="10"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-06-26T17:40:59.896859Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-06-26T17:40:59.896642Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-06-26T17:40:59.901512Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-06-26T17:40:59.901068Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:8.732e-3,&quot;end_time&quot;:&quot;2024-06-26T17:40:59.902531&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-06-26T17:40:59.893799&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Q4: Pattern 132
# https://www.youtube.com/watch?v=q5ANAl8Z458
# https://leetcode.com/problems/132-pattern/submissions/1301126531/
def find132pattern(nums: list[int]) -> bool:
    N = len(nums)

    # Monotonic stack, storing min values till index - value, min pairs
    stack: list[tuple[int, int]] = []
    min_: int = nums[0]

    for n in nums:
        while stack and stack[-1][0] <= n:
            stack.pop()

        if stack and stack[-1][1] < n:
            return True

        stack.append((n, min_))
        min_ = min(min_, n)

    return False

# Testing the solution
assert find132pattern([1,2,3,4]) == False
assert find132pattern([3,1,4,2]) == True
assert find132pattern([-1,3,2,0]) == True
assert find132pattern([3,1,2]) == False
```

</div>

<div id="6afba366" class="cell markdown"
papermill="{&quot;duration&quot;:2.189e-3,&quot;end_time&quot;:&quot;2024-06-26T17:40:59.907079&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-06-26T17:40:59.904890&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Balance a Binary Search tree

</div>

<div id="47bab318" class="cell code" execution_count="11"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-06-26T17:40:59.912491Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-06-26T17:40:59.912254Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-06-26T17:40:59.918264Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-06-26T17:40:59.917788Z&quot;}"
papermill="{&quot;duration&quot;:1.0038e-2,&quot;end_time&quot;:&quot;2024-06-26T17:40:59.919364&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-06-26T17:40:59.909326&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/balance-a-binary-search-tree/submissions/1301150197
def balanceBST(root: BinaryTreeNode) -> BinaryTreeNode|None:
    def createBalancedBST(nodes_: list[int]) -> BinaryTreeNode|None:
        N = len(nodes_)
        if N == 0:
            return None
        else:
            mid = N // 2
            root_: BinaryTreeNode = BinaryTreeNode(nodes_[mid])
            root_.left = createBalancedBST(nodes_[:mid])
            root_.right = createBalancedBST(nodes_[mid + 1:])
            return root_

    # 1. Retrieve all elements in-order traversal (left, root, right), this returns an array in sorted order
    curr: BinaryTreeNode = root
    nodes: list[int] = []
    stack: list[BinaryTreeNode] = []
    while True:
        while curr:
            stack.append(curr)
            curr = curr.left
        if stack:
            curr = stack.pop()
            nodes.append(curr.val)
            curr = curr.right
        else:
            break

    # 2. Create a BST from the nodes: Take the middle element as the root, create left and right subtree recursively
    return createBalancedBST(nodes)

# Testing the solution
print(balanceBST(BinaryTreeNode.from_array([1,None,2,None,3,None,4,None,None])).to_list())
```

<div class="output stream stdout">

    [3, 2, 4, 1]

</div>

</div>
