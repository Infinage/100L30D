---
jupyter:
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
  language_info:
    codemirror_mode:
      name: ipython
      version: 3
    file_extension: .py
    mimetype: text/x-python
    name: python
    nbconvert_exporter: python
    pygments_lexer: ipython3
    version: 3.10.13
  nbformat: 4
  nbformat_minor: 5
---

<div id="9591ad26-417a-4dcc-9c52-8a9c5c99e332" class="cell markdown">

# 100L30D

![28%](https://progress-bar.dev/28?title=progress&width=100)

#### Description:

- Solving 100 Leetcode problems of varying difficulty in 30 days.<br>
- Languange of choice: `Python`, `SQL`<br>

#### Timelines:

- Start Date: 20th Dec 2023
- Challenge End Date: 19th Jan 2023

</div>

<div id="7e8f7725-fb43-4f4e-954a-299f2eacdc10" class="cell code"
execution_count="5">

``` python
from typing import List
import pandas as pd
import sqlite3
import re
import io
import math
import collections
import itertools
import functools
import random
import string
import tqdm

conn = sqlite3.connect(":memory:")

def regexp(expr, item):
    reg = re.compile(expr)
    return reg.search(item) is not None

def read_lc_df(s: str) -> pd.DataFrame:
    temp = pd.read_csv(io.StringIO(s), sep="|", skiprows=2)
    temp = temp.iloc[1:-1, 1:-1]
    temp.columns = temp.columns.map(str.strip)
    temp = temp.map(lambda x: x if type(x) != str else None if x.strip() == 'null' else x.strip())
    return temp
    
conn.create_function("REGEXP", 2, regexp)
```

</div>

<div id="248b4168-7822-4f9a-8a84-20cf00abd876" class="cell markdown">

# 1.

Date: 20th Dec 2023<br> Easy Leetcode: Unique Morse Words<br> Solution:
<https://leetcode.com/problems/unique-morse-code-words/submissions/1124312422/>

</div>

<div id="49ce7cff-38d1-473f-a574-6a061801eb73" class="cell code"
execution_count="6">

``` python
class Solution:

    morse = [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]
    alphabets = [chr(i + ord('a')) for i in range(26)]
    mapping = dict(zip(alphabets, morse))

    @staticmethod
    def map_to_morse(word):
        
        if word in Solution.mapping:
            return Solution.mapping[word]

        result = Solution.mapping[word[0]] + Solution.map_to_morse(word[1:])
        Solution.mapping[word] = result
        return result

    def uniqueMorseRepresentations(self, words: List[str]) -> int:
        return len(set(map(Solution.map_to_morse, words)))
```

</div>

<div id="9e9777fa-3395-4d7a-aedb-d4cc5c32c946" class="cell code"
execution_count="7">

``` python
Solution().uniqueMorseRepresentations(["gin","zen","gig","msg"])
```

<div class="output execute_result" execution_count="7">

    2

</div>

</div>

<div id="c59229e2-b95d-4bcf-a94c-1eab5fcf6604" class="cell markdown">

# 2.

Date: 20th Dec 2023<br> Easy Leetcode: Pascals Triangle II<br> Solution:
<https://leetcode.com/submissions/detail/1123808820/>

</div>

<div id="cbfad5bf-ac04-43b7-a300-f3c464fa6885" class="cell code"
execution_count="8">

``` python
class Solution:
    '''
    [1]
    [1, 1]
    [1, 2, 1]
    [1, 3, 3, 1]
    [1, 4, 6, 4, 1]
    [1, 5, 10, 10, 5, 1]
    [1, 6, 15, 20, 15, 6, 1]
    [1, 7, 21, 35, 35, 21, 7, 1]

    n_rows = index + 1

    '''

    def slideSum(lst: List[int]) -> List[int]:
        # Slide a window of size 2 over the list and return the list of sums
        assert len(lst) > 1, f"Minimum slide length is 2, got {len(lst)}"

        result = []
        for i in range(len(lst) - 1):
            result.append(lst[i] + lst[i + 1])
        return [1] + result + [1]

    def getRow(self, rowIndex: int) -> List[int]:
        
        assert rowIndex >= 0, f"Index cannot be negative, got {rowIndex}"

        if rowIndex == 0:
            return [1]
        elif rowIndex == 1:
            return [1, 1]
        else:
            prevRow = self.getRow(rowIndex - 1)
            return Solution.slideSum(prevRow)
```

</div>

<div id="d3dfc31e-818d-4ae4-a986-0f6eff700890" class="cell code"
execution_count="9">

``` python
Solution().getRow(10)
```

<div class="output execute_result" execution_count="9">

    [1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1]

</div>

</div>

<div id="f46fc724-9eac-496b-acb5-fd46b142a225" class="cell markdown">

# 3.

Date: 21th Dec 2023<br> Easy leetcode:
find-total-time-spent-by-each-employee<br> Solution:
<https://leetcode.com/problems/find-total-time-spent-by-each-employee/submissions/1124667523/>

``` sql
# Write your MySQL query statement below
with temp as (
    select 
        e.*, (e.out_time - e.in_time) total_time 
    from employees e
)

select 
    t.event_day as day, t.emp_id, sum(t.total_time) total_time 
from temp t
group by t.emp_id, t.event_day;
```

</div>

<div id="3b455303-7738-4e23-bafb-8b4a022c1890" class="cell markdown">

# 4.

Date: 21th Dec 2023<br> Easy Leetcode:
sum-of-all-odd-length-subarrays<br> Solution:
<https://leetcode.com/problems/sum-of-all-odd-length-subarrays/submissions/1124679524/>

</div>

<div id="5ab2fb01-1837-48aa-a8e8-3db631253c49" class="cell code"
execution_count="10">

``` python
class Solution:
    def slide(arr: list[int], window: int):
        assert window <= len(arr), "Window size must be less than the len of arr"
        result = curr_sum = sum(arr[:window])

        for i in range(len(arr) - window):
            start_idx_curr_window, end_idx_next_window = i, i + window
            curr_sum = curr_sum - arr[start_idx_curr_window] + arr[end_idx_next_window]
            result += curr_sum

        return result

    def sumOddLengthSubarrays(self, arr: list[int]) -> int:
        result = 0
        for i in range(1, len(arr) + 1, 2):
            result += Solution.slide(arr, window=i)

        return result
```

</div>

<div id="7559ac15-cb65-4a48-9a75-ea5ca2551588" class="cell code"
execution_count="11">

``` python
Solution().sumOddLengthSubarrays([1,4,2,5,3])
```

<div class="output execute_result" execution_count="11">

    58

</div>

</div>

<div id="a2ca17a7-f7f9-4838-b8af-7caf4b786274" class="cell code"
execution_count="12">

``` python
import math

class Solution:
    # https://leetcode.com/problems/sum-of-all-odd-length-subarrays/solutions/854184/java-c-python-o-n-time-o-1-space/
    
    def sumOddLengthSubarrays(self, arr: List[int]) -> int:
        result = 0
        n = len(arr)
        for i in range(0, n):
            k = (i + 1) * (n - i)
            result += arr[i] * math.ceil(k / 2)

        return result
```

</div>

<div id="364fa384-1c52-4588-b960-ad96272778bb" class="cell markdown">

# 5.

Date: 22th Dec 2023<br> Easy Leetcode:
maximum-score-after-splitting-a-string<br> Solution:
<https://leetcode.com/problems/maximum-score-after-splitting-a-string/submissions/1125483525/>

</div>

<div id="2b1e8f16-2fc2-48e7-b873-060cdcdcf167" class="cell code"
execution_count="13">

``` python
"""

Min possible score: 0 [10]
Max possible score: len(s) [01]

"""

class Solution:
    def maxScore(self, s: str) -> int:

        left_score, right_score  = 0, s.count("1")
        res = 0

        for ch in s[:-1]:
            if ch == "0":
                left_score += 1
            else:
                right_score -= 1

            curr = left_score + right_score
            if curr > res:
                res = curr

        return res
```

</div>

<div id="c64f41a3-ab1b-4d50-b39a-40091512460a" class="cell markdown">

# 6.

Date: 22th Dec 2023<br> Easy Leetcode:
kids-with-the-greatest-number-of-candies<br> Solution:
<https://leetcode.com/problems/kids-with-the-greatest-number-of-candies/submissions/1125486579/>

</div>

<div id="ec4bae1a-ab79-477b-acfe-4e7b5521b0c5" class="cell code"
execution_count="14">

``` python
class Solution:
    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:
        maxCandies = max(candies) 
        res = []
        for candies_with_kid_i in candies:
            if candies_with_kid_i + extraCandies >= maxCandies:
               res.append(True)
            else:
                res.append(False)
        return res
```

</div>

<div id="1fa49eec-d980-4405-a88e-30e1ce68fa94" class="cell markdown">

# 7.

Date: 22th Dec 2023<br> Easy Leetcode:
can-make-arithmetic-progression-from-sequence<br> Solution (can be
improved):
<https://leetcode.com/problems/can-make-arithmetic-progression-from-sequence/submissions/1125491514/>

</div>

<div id="42d718fd-dd4e-4db1-8e00-6fe31bf46be4" class="cell code"
execution_count="15">

``` python
class Solution:
    def canMakeArithmeticProgression(self, arr: List[int]) -> bool:

        # Sort the array
        arr.sort()       

        diff = None
        for i in range(len(arr) - 1):
            curr = arr[i + 1] - arr[i]
            if diff is None:
                diff = curr
            elif diff != curr:
                return False
        return True
```

</div>

<div id="4593be4e-eacb-4577-bfa7-35dd0eaa304e" class="cell markdown">

# 8.

Date: 22nd Dec 2023<br> Easy Leetcode: find-users-with-valid-e-mails<br>
Solution:
<https://leetcode.com/problems/find-users-with-valid-e-mails/submissions/1125507166/>

</div>

<div id="f273a626-27ec-4761-9ac1-92412cbd08d7" class="cell code"
execution_count="16">

``` python
temp = read_lc_df("""
+---------+-----------+-------------------------+
| user_id | name      | mail                    |
| ------- | --------- | ----------------------- |
| 1       | Winston   | winston@leetcode.com    |
| 2       | Jonathan  | jonathanisgreat         |
| 3       | Annabelle | bella-@leetcode.com     |
| 4       | Sally     | sally.come@leetcode.com |
| 5       | Marwan    | quarz#2020@leetcode.com |
| 6       | David     | david69@gmail.com       |
| 7       | Shapiro   | .shapo@leetcode.com     |
+---------+-----------+-------------------------+
""")

print(temp[temp['mail'].str.fullmatch('[A-Za-z][A-Za-z0-9\.\-\_]*\@leetcode\.com')])

# Write to DB & solve using SQL
temp.to_sql(name='temp', con=conn, index=False, if_exists='replace')
print(pd.read_sql("select * from temp u where u.mail REGEXP '^[a-zA-Z]+[a-zA-Z0-9-._]*\\@leetcode\\.com$'", con=conn))
```

<div class="output stream stdout">

      user_id       name                     mail
    1       1    Winston     winston@leetcode.com
    3       3  Annabelle      bella-@leetcode.com
    4       4      Sally  sally.come@leetcode.com
      user_id       name                     mail
    0       1    Winston     winston@leetcode.com
    1       3  Annabelle      bella-@leetcode.com
    2       4      Sally  sally.come@leetcode.com

</div>

</div>

<div id="ec93c48c-6c48-4f37-a20d-24bd829c53c9" class="cell markdown">

# 9.

Date: 22nd Dec 2023<br> Medium Leetcode: consecutive-numbers <br>
Solution:
<https://leetcode.com/problems/consecutive-numbers/submissions/1125892860/>

</div>

<div id="340e590f-b16e-4c05-b1a6-28687eff7493" class="cell code"
execution_count="17">

``` python
temp = read_lc_df("""
+----+-----+
| id | num |
+----+-----+
| 1  | 1   |
| 2  | 1   |
| 3  | 1   |
| 4  | 2   |
| 5  | 1   |
| 6  | 2   |
| 7  | 2   |
+----+-----+
""")

# Python iterative solution
def consecutive_numbers_py(logs: pd.DataFrame) -> pd.DataFrame:
    result = []
    resultSet = set()

    prev = None
    for num in logs['num'].values:
        if prev is None:
            prev = [num, 1]
        elif prev[0] == num:
            prev[1] += 1
        else:
            if prev[1] >= 3 and prev[0] not in resultSet:
                result.append(prev[0])
                resultSet.add(prev[0])
            prev = [num, 1]

    if prev is not None and prev[1] >= 3 and prev[0] not in resultSet:
        result.append(prev[0])
        resultSet.add(prev[0])

    return pd.DataFrame({"ConsecutiveNums": result})

# Pandas solution
def consecutive_numbers_df(logs: pd.DataFrame) -> pd.DataFrame:
    # Code starts here
    df = logs.copy()
    df['diff_1'] = df.groupby("num")["id"].diff()
    df['diff_2'] = df.groupby("num")["id"].diff(periods=2)
    df = df[(df['diff_1'] == 1) & (df['diff_2'] == 2)]['num'].rename("ConsecutiveNums").to_frame().drop_duplicates().reset_index(drop=True)
    return df

display(consecutive_numbers_py(temp))
display(consecutive_numbers_df(temp))

# SQL Solution
temp.to_sql("temp", con=conn, index=False, if_exists='replace')

pd.read_sql("""
with temp_1 as (
    select 
        t.id, 
        t.num, 
        t.id - lag(t.id, 1) over(partition by t.num order by t.id) as diff_1,
        t.id - lag(t.id, 2) over(partition by t.num order by t.id) as diff_2 
    from temp t
)

select distinct num ConsecutiveNums from temp_1 where diff_1 = 1 and diff_2 = 2
""", con=conn)
```

<div class="output display_data">

       ConsecutiveNums
    0              1.0

</div>

<div class="output display_data">

       ConsecutiveNums
    0              1.0

</div>

<div class="output execute_result" execution_count="17">

       ConsecutiveNums
    0              1.0

</div>

</div>

<div id="603a2c87-bc46-41e9-a312-d3e0304c7dfc" class="cell markdown">

# 10.

Date: 22nd Dec 2023<br> Medium Leetcode: customers-who-never-order<br>
Solution:
<https://leetcode.com/problems/customers-who-never-order/submissions/1125909085/>

#### SQL Solution:

``` sql
select c.name Customers
from Customers c 
left join Orders o on c.id = o.customerId 
where o.id is Null
```

#### Pandas Solution:

``` python
def find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:
    result = customers.loc[~customers['id'].isin(orders['customerId']), 'name'].to_frame()
    result = result.rename({"name": "Customers"}, axis=1)
    return result
```

</div>

<div id="cd3e1f11-0af5-4b55-ad19-abbd1805afea" class="cell markdown">

# 11.

Date: 22nd Dec 2023<br> Easy Leetcode: biggest-single-number<br>
Solution:
<https://leetcode.com/problems/biggest-single-number/submissions/1125925499/>

``` sql
with temp as (
    select num 
    from MyNumbers
    group by num 
    having count(num) = 1
)

select max(num) num from temp
```

</div>

<div id="1edd8fc1-1235-4ebe-9fdf-789e2ff3620d" class="cell code"
execution_count="18">

``` python
def biggest_single_number(my_numbers: pd.DataFrame) -> pd.DataFrame:
    df = my_numbers.value_counts().sort_index()
    df = df[df == 1].iloc[-1:].index
    return df.to_frame() if len(df) else pd.DataFrame({"num": [None]}) 
```

</div>

<div id="4b691b6a-b3a5-40fb-94c3-543dfefdb102" class="cell markdown">

# 12.

Date; 22nd Dec 2023<br> Easy Leetcode: summary-ranges<br> Solution:
<https://leetcode.com/problems/summary-ranges/submissions/1125948046/>

</div>

<div id="30514c87-c164-4aa5-8b03-9e8ddf2b3cfe" class="cell code"
execution_count="19">

``` python
class Solution:
    def summaryRanges(self, nums: List[int]) -> List[str]:
        
        result = []
        curr = []
        for num in nums:
                if not curr or curr[-1] == num - 1:
                    curr.append(num)
                else:
                    if len(curr) == 1:
                        result.append(str(curr[0]))
                    else:
                        result.append(f"{curr[0]}->{curr[-1]}")
                    curr = [num]

        # Residues remain
        if len(curr) > 0:
            if len(curr) == 1:
                result.append(str(curr[0]))
            else:
                result.append(f"{curr[0]}->{curr[-1]}")

        return result
```

</div>

<div id="ff4e6724-333d-4282-bd9f-77d4462fdb24" class="cell markdown">

# 13.

Date: 23rd Dec 2023<br> Easy Leetcode: number-of-good-pairs<br>
Solution:
<https://leetcode.com/problems/number-of-good-pairs/submissions/1126247596/>

</div>

<div id="26d57e44-6780-4cd4-b165-f03a9fabe0b6" class="cell code"
execution_count="20">

``` python
class Solution:
    def numIdenticalPairs(self, nums: List[int]) -> int:
        indices = dict()
        for i, num in enumerate(nums): 
            indices[num] = indices.get(num, 0) + 1

        result = 0
        for curr in indices.values():
            result += math.comb(curr, 2)
            
        return result

        # More concise solution from https://leetcode.com/problems/number-of-good-pairs/solutions/731561/java-c-python-count/
        return sum(math.comb(n, 2) for n in collections.Counter([1, 1, 1, 1]).values())
```

</div>

<div id="5b332f23-242b-4bff-b3d4-58ba2a6051d4" class="cell code"
execution_count="21">

``` python
Solution().numIdenticalPairs([1,1,1,1])
```

<div class="output execute_result" execution_count="21">

    6

</div>

</div>

<div id="a5d10ae4-c3df-49c1-afdf-2d569c24003f" class="cell markdown">

# 14.

Date: 23rd Dec 2023<br> Easy Leetcode: defanging-an-ip-address<br>
Solution:
<https://leetcode.com/problems/defanging-an-ip-address/submissions/1126251287/>

</div>

<div id="286dd298-9a6f-4f39-aee0-4d617fb23ef0" class="cell code"
execution_count="22">

``` python
class Solution:
    def defangIPaddr(self, address: str) -> str:
        # return address.replace(".", "[.]") 

        result = []
        for ch in address:
            if ch == ".":
                ch = "[.]"
            result.append(ch)

        result_str = ""
        for ch in result:
            result_str += ch

        return result_str
```

</div>

<div id="c446c937-ce54-42e2-b539-a770af47bf84" class="cell markdown">

# 15.

Date: 23rd Dec 2023<br> Medium Leetcode: encode-and-decode-tinyurl<br>
Solution:
<https://leetcode.com/problems/encode-and-decode-tinyurl/submissions/1126404991/>

</div>

<div id="3f7be11e-be86-4691-a613-443bf051c496" class="cell code"
execution_count="23">

``` python
class Codec:

    def __init__(self, code_length=6):
        self.forward_mappings = dict()
        self.backward_mappings = dict()
        self.code_length = code_length

    def generate_code(self):
        code = None
        while code is None or code in self.forward_mappings:
            code = ''.join(random.choices('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWZYZ', k=self.code_length))
        return code

    def encode(self, longUrl: str) -> str:
        """Encodes a URL to a shortened URL.
        """
        
        if longUrl not in self.backward_mappings:
            code = self.generate_code()
            self.forward_mappings[code] = longUrl
            self.backward_mappings[longUrl] = code
        else:
            code = self.backward_mappings[longUrl]
            
        return f"https://tinyurl.com/{code}"

    def decode(self, shortUrl: str) -> str:
        """Decodes a shortened URL to its original URL.
        """
        code = shortUrl[-self.code_length:]
        if code in self.forward_mappings:
            return self.forward_mappings[code]
        else:
            return None
        
codec = Codec()
url = "https://leetcode.com/problems/design-tinyurl"
code = codec.encode(url)
print (code)
assert codec.decode(code) == url, "Don't seem to match"
```

<div class="output stream stdout">

    https://tinyurl.com/AYonVq

</div>

</div>

<div id="c68e47aa-8d6f-4907-80b1-4aa1fc0ce5fe" class="cell markdown">

# 16.

Date: 23rd Dec 2023<br> Easy Leetcode:
subtract-the-product-and-sum-of-digits-of-an-integer<br> Solution:
<https://leetcode.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/submissions/1126416675/>

</div>

<div id="b6dc8842-89d4-431e-9385-7fdacd8f3953" class="cell code"
execution_count="24">

``` python
class Solution:
    def subtractProductAndSum(self, n: int) -> int:

        # Alternate solution
        nums = list(map(int, list(str(n))))
        s = functools.reduce(lambda x, y: x + y, nums, 0)
        p = functools.reduce(lambda x, y: x * y, nums, 1)
        return p - s

        # More efficient although has the same complexity
        s, p = 0, 1
        for ch in str(n):
            s += int(ch)
            p *= int(ch)
        return p - s
```

</div>

<div id="163f8a94-dbe1-4e99-89ca-543584ad4a25" class="cell markdown">

# 17.

Date: 23rd Dec 2023<br> Medium Leetcode:
remove-all-adjacent-duplicates-in-string-ii<br> Solution:
<https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/submissions/1126450574/>

</div>

<div id="9421e5a6-7300-4107-a601-e1f1b90fe761" class="cell code"
execution_count="25">

``` python
class Solution:
    """
    Example 1:
    "pbbcggttciiippooaais", k = 2
    "pcciis"
    "ps"
    
    Example 2:
    "deeedbbcccbdaa", k = 3
    "ddbbbdaa"
    "dddaa"
    "aa"
    """

    # Solution idea from: https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/solutions/392933/java-c-python-two-pointers-and-stack-solution/

    def removeDuplicates(self, s: str, k: int) -> str:
        result = [['', 1]]
        for ch in s:
            if result[-1][0] == ch:
                result[-1][1] += 1
            else:
                result.append([ch, 1])
            if result[-1][1] == k:
                result.pop()
                
        return ''.join(map(lambda x: x[0] * x[1], result))

# Testing the solution
assert Solution().removeDuplicates("abcd", k=2) == 'abcd'
assert Solution().removeDuplicates("deeedbbcccbdaa", k=3) == 'aa'
assert Solution().removeDuplicates("pbbcggttciiippooaais", k=2) == 'ps'
assert Solution().removeDuplicates("abccba", k=2) == ''
```

</div>

<div id="77153c5a-851f-445e-aef9-385272b727f3" class="cell markdown">

# 18.

Date: 23rd Dec 2023<br> Medium Leetcode: capital-gainloss<br> Solution:
<https://leetcode.com/problems/capital-gainloss/submissions/1126487033/>

</div>

<div id="72963fb2-fac0-402a-829e-f6b3ca13c202" class="cell code"
execution_count="26">

``` python
temp = read_lc_df("""
+---------------+-----------+---------------+--------+
| stock_name    | operation | operation_day | price  |
+---------------+-----------+---------------+--------+
| Leetcode      | Buy       | 1             | 1000   |
| Corona Masks  | Buy       | 2             | 10     |
| Leetcode      | Sell      | 5             | 9000   |
| Handbags      | Buy       | 17            | 30000  |
| Corona Masks  | Sell      | 3             | 1010   |
| Corona Masks  | Buy       | 4             | 1000   |
| Corona Masks  | Sell      | 5             | 500    |
| Corona Masks  | Buy       | 6             | 1000   |
| Handbags      | Sell      | 29            | 7000   |
| Corona Masks  | Sell      | 10            | 10000  |
+---------------+-----------+---------------+--------+
""")

# Actual code startes here
_ = temp.groupby(['stock_name', 'operation'], as_index=False)['price'].sum()
_ = _.groupby('stock_name').apply(lambda x: x.iloc[1, 2] - x.iloc[0, 2]).reset_index()
_ = _.rename({0: 'capital_gain_loss'}, axis=1)
display(_)

# Using SQL
temp.to_sql("temp", if_exists='replace', con=conn, index=False)
pd.read_sql("""
with trade_sum as (
    select 
        stock_name, 
        operation, 
        sum(price) price
    from temp 
    group by stock_name, operation
),

buy as (
    select * from trade_sum t 
    where t.operation = 'Buy'
),

sell as (
    select * from trade_sum t 
    where t.operation = 'Sell'
)

select 
    s.stock_name, 
    (s.price - b.price) capital_gain_loss 
from buy b, sell s 
where b.stock_name = s.stock_name
""", con=conn)
```

<div class="output display_data">

         stock_name  capital_gain_loss
    0  Corona Masks             9500.0
    1      Handbags           -23000.0
    2      Leetcode             8000.0

</div>

<div class="output execute_result" execution_count="26">

         stock_name  capital_gain_loss
    0  Corona Masks             9500.0
    1      Handbags           -23000.0
    2      Leetcode             8000.0

</div>

</div>

<div id="0c7765f9-274c-494f-86a2-dfb99e42b27a" class="cell markdown">

# 19.

Date: 23rd Dec 2023<br> Medium Leetcode: monthly-transactions-i<br>
Solution:

</div>

<div id="641e2693-f755-4b7c-8d45-15ded8fcdc7e" class="cell code"
execution_count="27">

``` python
temp = read_lc_df("""
+-----+---------+----------+--------+------------+
| id  | country | state    | amount | trans_date |
| --- | ------- | -------- | ------ | ---------- |
| 121 | US      | approved | 1000   | 2018-12-18 |
| 122 | US      | declined | 2000   | 2018-12-19 |
| 123 | US      | approved | 2000   | 2019-01-01 |
| 124 | null    | approved | 2000   | 2019-01-07 |
+-----+---------+----------+--------+------------+
""")

temp['amount'] = temp['amount'].astype(float)
temp['trans_date'] = pd.to_datetime(temp['trans_date'])

# Start with the actual code
_ = temp.copy()
_['month'] = _['trans_date'].dt.strftime("%Y-%m")
_ = _.groupby(['month', 'country', 'state'], as_index=False, dropna=False)['amount'].agg(['sum', 'count'])

_ = pd.merge(
    _.groupby(['month', 'country'], as_index=False, dropna=False)[['sum', 'count']].agg('sum'),
    _[_['state'] == 'approved'].groupby(['month', 'country'], as_index=False, dropna=False)[['sum', 'count']].agg('sum'),
    how='left',
    on=['month', 'country']
)

__ = _.select_dtypes('number').columns
_[__] = _[__].fillna(0)
_ = _.rename({"count_x": "trans_count", "sum_x": "trans_total_amount", "sum_y": "approved_total_amount", "count_y": "approved_count"}, axis=1)
display(_[['month', 'country', 'trans_count', 'approved_count', 'trans_total_amount', 'approved_total_amount']])

# Write to Database for SQL
temp.to_sql("temp", if_exists='replace', index=False, con=conn)

# Write SQL Query
pd.read_sql(
'''
select 
    SUBSTR(t.trans_date, 0, 8) month,
    
    t.country,
    
    count(t.amount) trans_count,
    
    sum(
        CASE 
            WHEN t.state = 'approved' THEN 1
            ELSE 0
        END
    ) approved_count,
    
    sum(t.amount) trans_total_amount,
    
    sum(
        CASE 
            WHEN t.state = 'approved' THEN t.amount
            ELSE 0
        END
    ) approved_total_amount
    
from temp t
group by 1, t.country
'''
, con=conn)
```

<div class="output display_data">

         month country  trans_count  approved_count  trans_total_amount  \
    0  2018-12      US            2               1              3000.0   
    1  2019-01      US            1               1              2000.0   
    2  2019-01     NaN            1               1              2000.0   

       approved_total_amount  
    0                 1000.0  
    1                 2000.0  
    2                 2000.0  

</div>

<div class="output execute_result" execution_count="27">

         month country  trans_count  approved_count  trans_total_amount  \
    0  2018-12      US            2               1              3000.0   
    1  2019-01    None            1               1              2000.0   
    2  2019-01      US            1               1              2000.0   

       approved_total_amount  
    0                 1000.0  
    1                 2000.0  
    2                 2000.0  

</div>

</div>

<div id="b0bde1a6-9ca7-4b82-83bd-c9ac82b0c00b" class="cell markdown">

# 20.

Date: 24th Dec 2023<br> Medium Leetcode:
partitioning-into-minimum-number-of-deci-binary-numbers<br> Solution:
<https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/submissions/1127002126/>

</div>

<div id="c3fe25ad-56eb-4b75-9846-9ea61669327b" class="cell code"
execution_count="28">

``` python
# Example
print("692115")

# Sample solution
print(
    functools.reduce(
        lambda x, y: int(x) + int(y), 
        ["111111", "111001", "110001", "110001", "110001", "110000", "10000", "10000", "10000"], # Len - 9
        0)
)
# We only need to return the max char from the list
class Solution:
    def minPartitions(self, n: str) -> int:
       return max(map(int, n)) 

Solution().minPartitions("692115")
```

<div class="output stream stdout">

    692115
    692115

</div>

<div class="output execute_result" execution_count="28">

    9

</div>

</div>

<div id="634472f3-17ce-49d0-ba98-e7225b0db7db" class="cell markdown">

# 21.

Date: 24th Dec 2023<br> Medium Leetcode:
widest-vertical-area-between-two-points-containing-no-points<br>
Solution:

</div>

<div id="707c6740-4f90-4dd2-b243-f782255239fd" class="cell code"
execution_count="29">

``` python
class Solution:
    def maxWidthOfVerticalArea(self, points: List[List[int]]) -> int:
        sorted_coords = sorted(points, key=lambda x: x[0])
        result = -math.inf
        for i in range(len(sorted_coords) - 1):
            curr = sorted_coords[i + 1][0] - sorted_coords[i][0]
            if curr > result:
                result = curr
        return result

assert Solution().maxWidthOfVerticalArea([[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]) == 3
assert Solution().maxWidthOfVerticalArea([[8,7],[9,9],[7,4],[9,7]]) == 1
```

</div>

<div id="46204d31-f6f8-4d06-8f8c-a06b1f487694" class="cell markdown">

# 22.

Date: 24th Dec 2023<br> Easy Leetcode:
final-value-of-variable-after-performing-operations<br> Solution:
<https://leetcode.com/problems/final-value-of-variable-after-performing-operations/submissions/1127073907/>

</div>

<div id="0865eeaf-f3c8-45a9-93f9-1b5b0b31dd18" class="cell code"
execution_count="30">

``` python
mappings = {"--X": -1, "X--": -1, "++X": 1, "X++": 1}
temp = ["--X","X++","X++"]
sum(map(lambda x: mappings[x], temp))
```

<div class="output execute_result" execution_count="30">

    1

</div>

</div>

<div id="b0480586-de48-4a55-b05d-a7a5a71413b6" class="cell markdown">

# 23.

Date: 24th Dec 2023<br> Medium Leetcode:
minimum-number-of-swaps-to-make-the-string-balanced<br> Solution:
<https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-string-balanced/submissions/1127130139/>

</div>

<div id="45ab5e5f-5821-47b0-9c7f-d0a14074d65e" class="cell code"
execution_count="31">

``` python
"""
Balanced possibilities
n - 1:
[ ]

n - 2:
[ [ ] ]
[ ] [ ]

n - 3:
[ ] [ ] [ ]
[ [ ] [ ] ]
[ [ [ ] ] ]


Intuition:
1. Remove all the balanced brackets first, we would be left with something like this: "][", "]][[", "]]][[[", "]]]][[[[", etc
2. Swapping 1 pair reduces mismatched pairs by 2. Therefore for n (number of bracket `pair`), the number of swaps required would be ceil(n / 2).
"""

class Solution:
    def remove_balanced_brackets(self, s: str) -> str:
        stack = []
        for ch in s:
            if ch == "]" and len(stack) > 0 and stack[-1] == "[":
                stack.pop()
            else:
                stack.append(ch)
        return stack

    def minSwaps(self, s: str) -> int:
        purely_unbalanced = self.remove_balanced_brackets(s)
        return math.ceil(len(purely_unbalanced) / 4)
    
    def generate_unbalanced_str(n = 2):
        def balanced(s: str) -> bool:
            stack = []
            for ch in s:
                if ch == "[":
                    stack.append(ch)
                else:
                    if len(stack) > 0 and stack[-1] == "[":
                        stack.pop()
                    else:
                        return False
            return True
        
        return set(filter(lambda x: not balanced(x), map(lambda x: "".join(x), itertools.permutations("[]" * n, r=2*n))))
```

</div>

<div id="4b07690d-579f-45bb-9d84-2b1f026d2e6b" class="cell markdown">

# 24.

Date: 24th Dec 2023<br> Medium Leetcode:
array-with-elements-not-equal-to-average-of-neighbors<br> Solution:
<https://leetcode.com/problems/array-with-elements-not-equal-to-average-of-neighbors/submissions/1127221598/>

</div>

<div id="940607bd-d4cd-4f6c-9453-64e0ef7de2e3" class="cell code"
execution_count="38">

``` python
"""
[1,2,3]
[1,3,2]

[1,3,5,6,9]
[1,5,3,6,9]
[1,5,3,9,6]

Intution:
1. Keep sliding through the array until an index is reached where the condition fails (arr[i] = ((arr[i - 1] + arr[i + 1]) / 2)
2. For such instances swap the middle element with the right element.
3. This consititues one pass. Keep repeating steps 1 and 2 until the arr stops changing. At that point we would have arrived at our solution.
4. This is similar to how sorting algorithms like bubble sorting works.
"""

def rearrange(nums: List[int]) -> List[int]:
    nums = list(nums)
    for i in range(1, len(nums) - 1):
        if (2 * nums[i]) == (nums[i - 1] + nums[i + 1]):
            nums[i + 1], nums[i] = nums[i], nums[i + 1]
    return nums

def validate(nums: List[int]) -> bool:
    for i in range(1, len(nums) - 1):
        if (2 * nums[i]) == (nums[i - 1] + nums[i + 1]):
            return False, i, nums
    return True, None, None

assert validate(rearrange([1,3,5,6,9]))
assert validate(rearrange([1,2,3,4,5]))
assert validate(rearrange([6,2,0,9,7]))
assert validate(rearrange([1,2,3,4,5,6]))

for arr in tqdm.tqdm(itertools.permutations(range(9), 9), total=math.perm(9, 9), ascii=True):
    prev = None
    curr = arr
    while prev is None or any(map(lambda x: x[0] != x[1], zip(prev, curr))):
        prev, curr = curr, rearrange(curr)
        
    result = validate(curr)
    assert result[0], f"Input: {arr} | Result: {result[2]} fails condition at Index: {result[1]}"
```

<div class="output stream stderr">

    100%|#######################################################################| 362880/362880 [00:01<00:00, 263237.24it/s]

</div>

</div>

<div id="dd8022ca-708d-4b24-a054-860c4b5ffac8" class="cell markdown">

# 25.

Date: 24th Dec 2023<br> Easy Leetcode:
remove-letter-to-equalize-frequency<br> Solution:
<https://leetcode.com/problems/remove-letter-to-equalize-frequency/submissions/1127427755/>

</div>

<div id="c2d9d9bb-efca-4eb2-9aff-46570528fdd6" class="cell code"
execution_count="33">

``` python
def remove_letter(word: str) -> bool:
    
    counts = collections.Counter(word)
    freq = list(counts.values())
    alphabets = list(counts.keys())
    unique_freq = set(freq)
    minFreq = min(freq)
    maxFreq = max(freq)

    if len(alphabets) == 1: # aaaaaaaa
        return True
    elif len(unique_freq) == 1 and minFreq == 1: # abcdef
        return True
    elif len(unique_freq) == 2:
        if minFreq == 1 and freq.count(minFreq) == 1: # cccd
            return True
        else:
            return maxFreq - minFreq == 1 and freq.count(maxFreq) == 1
    else: # abbccc (3), aazz (1)
        return False

# remove_letter("aaaaaabbbbcccc")
remove_letter("ddaccb")
```

<div class="output execute_result" execution_count="33">

    False

</div>

</div>

<div id="f77a4d20-a558-4b95-9d77-dcd4d0898002" class="cell markdown">

# 26.

Date: 24th Dec 2023<br> Medium Leetcode:
find-if-path-exists-in-graph<br> Solution:
<https://leetcode.com/problems/find-if-path-exists-in-graph/submissions/1127439592/>

</div>

<div id="ca1fc8c6-3e7d-4c7e-bc07-630d1e08ed9b" class="cell code"
execution_count="34">

``` python
class Solution:
    def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:

        if source == destination:
            return True
        
        self.paths = dict()
        for start, end in edges:
            start_path = self.paths.get(start, [])
            end_path = self.paths.get(end, [])
            start_path.append(end)
            end_path.append(start)
            self.paths[start] = start_path
            self.paths[end] = end_path

        visited = set()
        to_visit = set([source])
        while to_visit:
            curr = to_visit.pop()
            if curr not in visited:
                visited.add(curr)
                to_visit = set([*to_visit, *self.paths[curr]])
            if destination in to_visit:
                return True
        return False

# Testing with samples from the q
assert Solution().validPath(6, [[0,1],[1,2],[2,0]], 0, 2) == True
assert Solution().validPath(6, [[0,1],[0,2],[3,5],[5,4],[4,3]], 0, 5) == False
```

</div>

<div id="9955f336-0371-4f54-aab1-03efd86029c3" class="cell markdown">

# 27.

Date: 24th Dec 2023<br> Medium Leetcode:
employees-whose-manager-left-the-company<br> Solution:

</div>

<div id="4c3b1862-bef3-40fd-b45c-41f41cf22ae3" class="cell code"
execution_count="36">

``` python
temp = read_lc_df("""
+-------------+-----------+------------+--------+
| employee_id | name      | manager_id | salary |
| ----------- | --------- | ---------- | ------ |
| 3           | Mila      | 9          | 60301  |
| 12          | Antonella | null       | 31000  |
| 13          | Emery     | null       | 67084  |
| 1           | Kalel     | 11         | 21241  |
| 9           | Mikaela   | null       | 50937  |
| 11          | Joziah    | 6          | 28485  |
+-------------+-----------+------------+--------+
""")

# Doing it the Pandas way
temp['salary'] = temp['salary'].astype(float)
missing_ids = set(temp['manager_id'].dropna()) - set(temp['employee_id'])

_ = temp.loc[
    (temp['salary'] < 30_000) & 
    (temp['manager_id'].isin(missing_ids)),
    ['employee_id']
]

display(_.sort_values('employee_id'))

# Let us do this with SQL
temp.to_sql("temp", index=False, con=conn, if_exists='replace')
pd.read_sql("""
    select t1.employee_id 
    from temp t1 
    
    left join temp t2 
    on t1.manager_id = t2.employee_id 
    
    where 
        t1.manager_id is not null and 
        t2.employee_id is null and
        t1.salary < 30000
        
    order by t1.employee_id
""", con=conn)
```

<div class="output display_data">

      employee_id
    6          11

</div>

<div class="output execute_result" execution_count="36">

      employee_id
    0          11

</div>

</div>

<div id="e66e0ff4-8a0a-4055-bf6b-601c8ab52804" class="cell markdown">

# 28.

Date: 25th Dec 2023<br> Easy Leetcode: min-cost-climbing-stairs<br>
Solution:
<https://leetcode.com/problems/min-cost-climbing-stairs/submissions/1127787644/>

</div>

<div id="2866337c-5fd0-4ee1-a828-bcaec7028651" class="cell code"
execution_count="37">

``` python
class Solution:
    def calcCost(self, cost: List[int], index: int, cache: dict[int, int]) -> int:

        if index in cache:
            return cache[index]
        
        else:

            if index >= len(cost) - 1:
                res = sum(cost[index:])

            else:
                res = min(
                    cost[index] + self.calcCost(cost, index + 1, cache),
                    cost[index] + self.calcCost(cost, index + 2, cache)
                )

            cache[index] = res
            return res

    def minCostClimbingStairs(self, cost: List[int]) -> int:

        # DP - setting a cache
        cache = dict()

        return min(
            self.calcCost(cost, index=0, cache=cache),
            self.calcCost(cost, index=1, cache=cache)
        )

# Testing out solution with sample testcases
assert Solution().minCostClimbingStairs([1,100,1,1,1,100,1,1,100,1]) == 6
assert Solution().minCostClimbingStairs([10,15,20]) == 15
```

</div>

<div id="616f8ae9-c500-4558-8e02-259d5d52efe0" class="cell code">

``` python
```

</div>

<div id="677c9ef7-e581-4655-bad8-25e30b30e5b4" class="cell code">

``` python
```

</div>

<div id="da86aa82-0a5f-49d1-9767-87a27042107d" class="cell code">

``` python
```

</div>

<div id="b4661f78-25cf-4f8b-808d-14c348569d39" class="cell code">

``` python
```

</div>

<div id="d129a355-6af3-485f-8238-fc48eaae5bb7" class="cell code">

``` python
```

</div>

<div id="09b611a5-96ae-4271-b48a-7ae272d76a63" class="cell code">

``` python
```

</div>

<div id="7b47b399-92dc-44aa-a1bd-6b29dc330f14" class="cell code">

``` python
```

</div>
