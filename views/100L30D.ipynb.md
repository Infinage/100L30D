---
jupyter:
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
  language_info:
    codemirror_mode:
      name: ipython
      version: 3
    file_extension: .py
    mimetype: text/x-python
    name: python
    nbconvert_exporter: python
    pygments_lexer: ipython3
    version: 3.10.13
  nbformat: 4
  nbformat_minor: 5
---

<div id="9591ad26-417a-4dcc-9c52-8a9c5c99e332" class="cell markdown">

# 100L30D

![100%](https://progress-bar.dev/100?title=progress&width=100)

#### Description:

- Solving 100 Leetcode problems of varying difficulty in 30 days.<br>
- Languange of choice: `Python`, `SQL`<br>

#### Timelines:

- Start Date: 20th Dec 2023
- Challenge End Date: 19th Jan 2024
- Completed on: 8th Jan 2023

</div>

<div id="7e8f7725-fb43-4f4e-954a-299f2eacdc10" class="cell code"
execution_count="1">

``` python
from typing import List
import pandas as pd
import numpy as np
import sqlite3
import re
import io
import math
import collections
import itertools
import functools
import random
import string
import tqdm
import bisect

conn = sqlite3.connect(":memory:")

def regexp(expr, item):
    reg = re.compile(expr)
    return reg.search(item) is not None

def read_lc_df(s: str) -> pd.DataFrame:
    temp = pd.read_csv(io.StringIO(s), sep="|", skiprows=2)
    temp = temp.iloc[1:-1, 1:-1]
    temp.columns = temp.columns.map(str.strip)
    temp = temp.map(lambda x: x if type(x) != str else None if x.strip() == 'null' else x.strip())
    return temp
    
conn.create_function("REGEXP", 2, regexp)
```

</div>

<div id="cd9f356a-ec8d-4cc7-8f8e-767594f87770" class="cell markdown">

#### Helper for Binary tree problems

</div>

<div id="bc81f97b-9163-4aa7-bf70-4030e78541a9" class="cell code"
execution_count="2">

``` python
class BinaryTreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

    def to_list(self):
        to_visit = [self]
        visited = []
        while len(to_visit) > 0:
            curr = to_visit.pop(0)
            if curr:
                to_visit.append(curr.left)
                to_visit.append(curr.right)
                visited.append(curr.val)
            else:
                visited.append(curr)
        return visited

    def __str__(self):
        return str(self.val)

    def from_array(nums: List[int]):
        '''Create a Tree from a list of nums. Returns the root node.'''
        if len(nums) == 0:
            return None
        elif len(nums) == 1:
            return BinaryTreeNode(nums[0])
        else:
            forest = [BinaryTreeNode(nums[0])]
            parent_idx = -1
            for i in range(1, len(nums)):

                curr = None
                if nums[i] is not None:
                    curr = BinaryTreeNode(nums[i])
                    forest.append(curr)
                
                if i % 2 == 1:
                    parent_idx += 1
                    forest[parent_idx].left = curr
                else:
                    forest[parent_idx].right = curr

        return forest[0]

temp = BinaryTreeNode.from_array([1,2,3,4,5,6,None,None,None,7,8])
temp.to_list()
```

<div class="output execute_result" execution_count="2">

    [1, 2, 3, 4, 5, 6, None, None, None, 7, 8, None, None, None, None, None, None]

</div>

</div>

<div id="e71c1647-5919-4779-b02a-acf5422946e4" class="cell markdown">

#### Helper for Singly Linked lists

</div>

<div id="dd983b16-b389-4aca-abbd-321b4bda6a80" class="cell code"
execution_count="3">

``` python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

    def __str__(self):
        return str(self.val)

    def to_singly_linked_list(nums: list[int]):
        root = prev = None
        for n in nums:
            curr = ListNode(n)
            # Init once
            if not root:
                root = curr
            if prev:
                prev.next = curr
            prev = curr
            
        return root

    def to_list(self) -> list[int]:
        result = []
        curr = self
        while curr:
            result.append(curr.val)
            curr = curr.next
        return result
```

</div>

<div id="248b4168-7822-4f9a-8a84-20cf00abd876" class="cell markdown">

# 1.

Date: 20th Dec 2023<br> Easy Leetcode: Unique Morse Words<br> Solution:
<https://leetcode.com/problems/unique-morse-code-words/submissions/1124312422/>

</div>

<div id="49ce7cff-38d1-473f-a574-6a061801eb73" class="cell code"
execution_count="4">

``` python
class Solution:

    morse = [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]
    alphabets = [chr(i + ord('a')) for i in range(26)]
    mapping = dict(zip(alphabets, morse))

    @staticmethod
    def map_to_morse(word):
        
        if word in Solution.mapping:
            return Solution.mapping[word]

        result = Solution.mapping[word[0]] + Solution.map_to_morse(word[1:])
        Solution.mapping[word] = result
        return result

    def uniqueMorseRepresentations(self, words: List[str]) -> int:
        return len(set(map(Solution.map_to_morse, words)))
```

</div>

<div id="9e9777fa-3395-4d7a-aedb-d4cc5c32c946" class="cell code"
execution_count="5">

``` python
Solution().uniqueMorseRepresentations(["gin","zen","gig","msg"])
```

<div class="output execute_result" execution_count="5">

    2

</div>

</div>

<div id="c59229e2-b95d-4bcf-a94c-1eab5fcf6604" class="cell markdown">

# 2.

Date: 20th Dec 2023<br> Easy Leetcode: Pascals Triangle II<br> Solution:
<https://leetcode.com/submissions/detail/1123808820/>

</div>

<div id="cbfad5bf-ac04-43b7-a300-f3c464fa6885" class="cell code"
execution_count="6">

``` python
class Solution:
    '''
    [1]
    [1, 1]
    [1, 2, 1]
    [1, 3, 3, 1]
    [1, 4, 6, 4, 1]
    [1, 5, 10, 10, 5, 1]
    [1, 6, 15, 20, 15, 6, 1]
    [1, 7, 21, 35, 35, 21, 7, 1]

    n_rows = index + 1

    '''

    def slideSum(lst: List[int]) -> List[int]:
        # Slide a window of size 2 over the list and return the list of sums
        assert len(lst) > 1, f"Minimum slide length is 2, got {len(lst)}"

        result = []
        for i in range(len(lst) - 1):
            result.append(lst[i] + lst[i + 1])
        return [1] + result + [1]

    def getRow(self, rowIndex: int) -> List[int]:
        
        assert rowIndex >= 0, f"Index cannot be negative, got {rowIndex}"

        if rowIndex == 0:
            return [1]
        elif rowIndex == 1:
            return [1, 1]
        else:
            prevRow = self.getRow(rowIndex - 1)
            return Solution.slideSum(prevRow)
```

</div>

<div id="d3dfc31e-818d-4ae4-a986-0f6eff700890" class="cell code"
execution_count="7">

``` python
Solution().getRow(10)
```

<div class="output execute_result" execution_count="7">

    [1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1]

</div>

</div>

<div id="f46fc724-9eac-496b-acb5-fd46b142a225" class="cell markdown">

# 3.

Date: 21th Dec 2023<br> Easy leetcode:
find-total-time-spent-by-each-employee<br> Solution:
<https://leetcode.com/problems/find-total-time-spent-by-each-employee/submissions/1124667523/>

``` sql
# Write your MySQL query statement below
with temp as (
    select 
        e.*, (e.out_time - e.in_time) total_time 
    from employees e
)

select 
    t.event_day as day, t.emp_id, sum(t.total_time) total_time 
from temp t
group by t.emp_id, t.event_day;
```

</div>

<div id="3b455303-7738-4e23-bafb-8b4a022c1890" class="cell markdown">

# 4.

Date: 21th Dec 2023<br> Easy Leetcode:
sum-of-all-odd-length-subarrays<br> Solution:
<https://leetcode.com/problems/sum-of-all-odd-length-subarrays/submissions/1124679524/>

</div>

<div id="5ab2fb01-1837-48aa-a8e8-3db631253c49" class="cell code"
execution_count="8">

``` python
class Solution:
    def slide(arr: list[int], window: int):
        assert window <= len(arr), "Window size must be less than the len of arr"
        result = curr_sum = sum(arr[:window])

        for i in range(len(arr) - window):
            start_idx_curr_window, end_idx_next_window = i, i + window
            curr_sum = curr_sum - arr[start_idx_curr_window] + arr[end_idx_next_window]
            result += curr_sum

        return result

    def sumOddLengthSubarrays(self, arr: list[int]) -> int:
        result = 0
        for i in range(1, len(arr) + 1, 2):
            result += Solution.slide(arr, window=i)

        return result
```

</div>

<div id="7559ac15-cb65-4a48-9a75-ea5ca2551588" class="cell code"
execution_count="9">

``` python
Solution().sumOddLengthSubarrays([1,4,2,5,3])
```

<div class="output execute_result" execution_count="9">

    58

</div>

</div>

<div id="a2ca17a7-f7f9-4838-b8af-7caf4b786274" class="cell code"
execution_count="10">

``` python
import math

class Solution:
    # https://leetcode.com/problems/sum-of-all-odd-length-subarrays/solutions/854184/java-c-python-o-n-time-o-1-space/
    
    def sumOddLengthSubarrays(self, arr: List[int]) -> int:
        result = 0
        n = len(arr)
        for i in range(0, n):
            k = (i + 1) * (n - i)
            result += arr[i] * math.ceil(k / 2)

        return result
```

</div>

<div id="364fa384-1c52-4588-b960-ad96272778bb" class="cell markdown">

# 5.

Date: 22th Dec 2023<br> Easy Leetcode:
maximum-score-after-splitting-a-string<br> Solution:
<https://leetcode.com/problems/maximum-score-after-splitting-a-string/submissions/1125483525/>

</div>

<div id="2b1e8f16-2fc2-48e7-b873-060cdcdcf167" class="cell code"
execution_count="11">

``` python
"""

Min possible score: 0 [10]
Max possible score: len(s) [01]

"""

class Solution:
    def maxScore(self, s: str) -> int:

        left_score, right_score  = 0, s.count("1")
        res = 0

        for ch in s[:-1]:
            if ch == "0":
                left_score += 1
            else:
                right_score -= 1

            curr = left_score + right_score
            if curr > res:
                res = curr

        return res
```

</div>

<div id="c64f41a3-ab1b-4d50-b39a-40091512460a" class="cell markdown">

# 6.

Date: 22th Dec 2023<br> Easy Leetcode:
kids-with-the-greatest-number-of-candies<br> Solution:
<https://leetcode.com/problems/kids-with-the-greatest-number-of-candies/submissions/1125486579/>

</div>

<div id="ec4bae1a-ab79-477b-acfe-4e7b5521b0c5" class="cell code"
execution_count="12">

``` python
class Solution:
    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:
        maxCandies = max(candies) 
        res = []
        for candies_with_kid_i in candies:
            if candies_with_kid_i + extraCandies >= maxCandies:
               res.append(True)
            else:
                res.append(False)
        return res
```

</div>

<div id="1fa49eec-d980-4405-a88e-30e1ce68fa94" class="cell markdown">

# 7.

Date: 22th Dec 2023<br> Easy Leetcode:
can-make-arithmetic-progression-from-sequence<br> Solution (can be
improved):
<https://leetcode.com/problems/can-make-arithmetic-progression-from-sequence/submissions/1125491514/>

</div>

<div id="42d718fd-dd4e-4db1-8e00-6fe31bf46be4" class="cell code"
execution_count="13">

``` python
class Solution:
    def canMakeArithmeticProgression(self, arr: List[int]) -> bool:

        # Sort the array
        arr.sort()       

        diff = None
        for i in range(len(arr) - 1):
            curr = arr[i + 1] - arr[i]
            if diff is None:
                diff = curr
            elif diff != curr:
                return False
        return True
```

</div>

<div id="4593be4e-eacb-4577-bfa7-35dd0eaa304e" class="cell markdown">

# 8.

Date: 22nd Dec 2023<br> Easy Leetcode: find-users-with-valid-e-mails<br>
Solution:
<https://leetcode.com/problems/find-users-with-valid-e-mails/submissions/1125507166/>

</div>

<div id="f273a626-27ec-4761-9ac1-92412cbd08d7" class="cell code"
execution_count="14">

``` python
temp = read_lc_df("""
+---------+-----------+-------------------------+
| user_id | name      | mail                    |
| ------- | --------- | ----------------------- |
| 1       | Winston   | winston@leetcode.com    |
| 2       | Jonathan  | jonathanisgreat         |
| 3       | Annabelle | bella-@leetcode.com     |
| 4       | Sally     | sally.come@leetcode.com |
| 5       | Marwan    | quarz#2020@leetcode.com |
| 6       | David     | david69@gmail.com       |
| 7       | Shapiro   | .shapo@leetcode.com     |
+---------+-----------+-------------------------+
""")

print(temp[temp['mail'].str.fullmatch('[A-Za-z][A-Za-z0-9\.\-\_]*\@leetcode\.com')])

# Write to DB & solve using SQL
temp.to_sql(name='temp', con=conn, index=False, if_exists='replace')
print(pd.read_sql("select * from temp u where u.mail REGEXP '^[a-zA-Z]+[a-zA-Z0-9-._]*\\@leetcode\\.com$'", con=conn))
```

<div class="output stream stdout">

      user_id       name                     mail
    1       1    Winston     winston@leetcode.com
    3       3  Annabelle      bella-@leetcode.com
    4       4      Sally  sally.come@leetcode.com
      user_id       name                     mail
    0       1    Winston     winston@leetcode.com
    1       3  Annabelle      bella-@leetcode.com
    2       4      Sally  sally.come@leetcode.com

</div>

</div>

<div id="ec93c48c-6c48-4f37-a20d-24bd829c53c9" class="cell markdown">

# 9.

Date: 22nd Dec 2023<br> Medium Leetcode: consecutive-numbers <br>
Solution:
<https://leetcode.com/problems/consecutive-numbers/submissions/1125892860/>

</div>

<div id="340e590f-b16e-4c05-b1a6-28687eff7493" class="cell code"
execution_count="15">

``` python
temp = read_lc_df("""
+----+-----+
| id | num |
+----+-----+
| 1  | 1   |
| 2  | 1   |
| 3  | 1   |
| 4  | 2   |
| 5  | 1   |
| 6  | 2   |
| 7  | 2   |
+----+-----+
""")

# Python iterative solution
def consecutive_numbers_py(logs: pd.DataFrame) -> pd.DataFrame:
    result = []
    resultSet = set()

    prev = None
    for num in logs['num'].values:
        if prev is None:
            prev = [num, 1]
        elif prev[0] == num:
            prev[1] += 1
        else:
            if prev[1] >= 3 and prev[0] not in resultSet:
                result.append(prev[0])
                resultSet.add(prev[0])
            prev = [num, 1]

    if prev is not None and prev[1] >= 3 and prev[0] not in resultSet:
        result.append(prev[0])
        resultSet.add(prev[0])

    return pd.DataFrame({"ConsecutiveNums": result})

# Pandas solution
def consecutive_numbers_df(logs: pd.DataFrame) -> pd.DataFrame:
    # Code starts here
    df = logs.copy()
    df['diff_1'] = df.groupby("num")["id"].diff()
    df['diff_2'] = df.groupby("num")["id"].diff(periods=2)
    df = df[(df['diff_1'] == 1) & (df['diff_2'] == 2)]['num'].rename("ConsecutiveNums").to_frame().drop_duplicates().reset_index(drop=True)
    return df

display(consecutive_numbers_py(temp))
display(consecutive_numbers_df(temp))

# SQL Solution
temp.to_sql("temp", con=conn, index=False, if_exists='replace')

pd.read_sql("""
with temp_1 as (
    select 
        t.id, 
        t.num, 
        t.id - lag(t.id, 1) over(partition by t.num order by t.id) as diff_1,
        t.id - lag(t.id, 2) over(partition by t.num order by t.id) as diff_2 
    from temp t
)

select distinct num ConsecutiveNums from temp_1 where diff_1 = 1 and diff_2 = 2
""", con=conn)
```

<div class="output display_data">

       ConsecutiveNums
    0              1.0

</div>

<div class="output display_data">

       ConsecutiveNums
    0              1.0

</div>

<div class="output execute_result" execution_count="15">

       ConsecutiveNums
    0              1.0

</div>

</div>

<div id="603a2c87-bc46-41e9-a312-d3e0304c7dfc" class="cell markdown">

# 10.

Date: 22nd Dec 2023<br> Medium Leetcode: customers-who-never-order<br>
Solution:
<https://leetcode.com/problems/customers-who-never-order/submissions/1125909085/>

#### SQL Solution:

``` sql
select c.name Customers
from Customers c 
left join Orders o on c.id = o.customerId 
where o.id is Null
```

#### Pandas Solution:

``` python
def find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:
    result = customers.loc[~customers['id'].isin(orders['customerId']), 'name'].to_frame()
    result = result.rename({"name": "Customers"}, axis=1)
    return result
```

</div>

<div id="cd3e1f11-0af5-4b55-ad19-abbd1805afea" class="cell markdown">

# 11.

Date: 22nd Dec 2023<br> Easy Leetcode: biggest-single-number<br>
Solution:
<https://leetcode.com/problems/biggest-single-number/submissions/1125925499/>

``` sql
with temp as (
    select num 
    from MyNumbers
    group by num 
    having count(num) = 1
)

select max(num) num from temp
```

</div>

<div id="1edd8fc1-1235-4ebe-9fdf-789e2ff3620d" class="cell code"
execution_count="16">

``` python
def biggest_single_number(my_numbers: pd.DataFrame) -> pd.DataFrame:
    df = my_numbers.value_counts().sort_index()
    df = df[df == 1].iloc[-1:].index
    return df.to_frame() if len(df) else pd.DataFrame({"num": [None]}) 
```

</div>

<div id="4b691b6a-b3a5-40fb-94c3-543dfefdb102" class="cell markdown">

# 12.

Date; 22nd Dec 2023<br> Easy Leetcode: summary-ranges<br> Solution:
<https://leetcode.com/problems/summary-ranges/submissions/1125948046/>

</div>

<div id="30514c87-c164-4aa5-8b03-9e8ddf2b3cfe" class="cell code"
execution_count="17">

``` python
class Solution:
    def summaryRanges(self, nums: List[int]) -> List[str]:
        
        result = []
        curr = []
        for num in nums:
                if not curr or curr[-1] == num - 1:
                    curr.append(num)
                else:
                    if len(curr) == 1:
                        result.append(str(curr[0]))
                    else:
                        result.append(f"{curr[0]}->{curr[-1]}")
                    curr = [num]

        # Residues remain
        if len(curr) > 0:
            if len(curr) == 1:
                result.append(str(curr[0]))
            else:
                result.append(f"{curr[0]}->{curr[-1]}")

        return result
```

</div>

<div id="ff4e6724-333d-4282-bd9f-77d4462fdb24" class="cell markdown">

# 13.

Date: 23rd Dec 2023<br> Easy Leetcode: number-of-good-pairs<br>
Solution:
<https://leetcode.com/problems/number-of-good-pairs/submissions/1126247596/>

</div>

<div id="26d57e44-6780-4cd4-b165-f03a9fabe0b6" class="cell code"
execution_count="18">

``` python
class Solution:
    def numIdenticalPairs(self, nums: List[int]) -> int:
        indices = dict()
        for i, num in enumerate(nums): 
            indices[num] = indices.get(num, 0) + 1

        result = 0
        for curr in indices.values():
            result += math.comb(curr, 2)
            
        return result

        # More concise solution from https://leetcode.com/problems/number-of-good-pairs/solutions/731561/java-c-python-count/
        return sum(math.comb(n, 2) for n in collections.Counter([1, 1, 1, 1]).values())
```

</div>

<div id="5b332f23-242b-4bff-b3d4-58ba2a6051d4" class="cell code"
execution_count="19">

``` python
Solution().numIdenticalPairs([1,1,1,1])
```

<div class="output execute_result" execution_count="19">

    6

</div>

</div>

<div id="a5d10ae4-c3df-49c1-afdf-2d569c24003f" class="cell markdown">

# 14.

Date: 23rd Dec 2023<br> Easy Leetcode: defanging-an-ip-address<br>
Solution:
<https://leetcode.com/problems/defanging-an-ip-address/submissions/1126251287/>

</div>

<div id="286dd298-9a6f-4f39-aee0-4d617fb23ef0" class="cell code"
execution_count="20">

``` python
class Solution:
    def defangIPaddr(self, address: str) -> str:
        # return address.replace(".", "[.]") 

        result = []
        for ch in address:
            if ch == ".":
                ch = "[.]"
            result.append(ch)

        result_str = ""
        for ch in result:
            result_str += ch

        return result_str
```

</div>

<div id="c446c937-ce54-42e2-b539-a770af47bf84" class="cell markdown">

# 15.

Date: 23rd Dec 2023<br> Medium Leetcode: encode-and-decode-tinyurl<br>
Solution:
<https://leetcode.com/problems/encode-and-decode-tinyurl/submissions/1126404991/>

</div>

<div id="3f7be11e-be86-4691-a613-443bf051c496" class="cell code"
execution_count="21">

``` python
class Codec:

    def __init__(self, code_length=6):
        self.forward_mappings = dict()
        self.backward_mappings = dict()
        self.code_length = code_length

    def generate_code(self):
        code = None
        while code is None or code in self.forward_mappings:
            code = ''.join(random.choices('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWZYZ', k=self.code_length))
        return code

    def encode(self, longUrl: str) -> str:
        """Encodes a URL to a shortened URL.
        """
        
        if longUrl not in self.backward_mappings:
            code = self.generate_code()
            self.forward_mappings[code] = longUrl
            self.backward_mappings[longUrl] = code
        else:
            code = self.backward_mappings[longUrl]
            
        return f"https://tinyurl.com/{code}"

    def decode(self, shortUrl: str) -> str:
        """Decodes a shortened URL to its original URL.
        """
        code = shortUrl[-self.code_length:]
        if code in self.forward_mappings:
            return self.forward_mappings[code]
        else:
            return None
        
codec = Codec()
url = "https://leetcode.com/problems/design-tinyurl"
code = codec.encode(url)
print (code)
assert codec.decode(code) == url, "Don't seem to match"
```

<div class="output stream stdout">

    https://tinyurl.com/KMUAjj

</div>

</div>

<div id="c68e47aa-8d6f-4907-80b1-4aa1fc0ce5fe" class="cell markdown">

# 16.

Date: 23rd Dec 2023<br> Easy Leetcode:
subtract-the-product-and-sum-of-digits-of-an-integer<br> Solution:
<https://leetcode.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/submissions/1126416675/>

</div>

<div id="b6dc8842-89d4-431e-9385-7fdacd8f3953" class="cell code"
execution_count="22">

``` python
class Solution:
    def subtractProductAndSum(self, n: int) -> int:

        # Alternate solution
        nums = list(map(int, list(str(n))))
        s = functools.reduce(lambda x, y: x + y, nums, 0)
        p = functools.reduce(lambda x, y: x * y, nums, 1)
        return p - s

        # More efficient although has the same complexity
        s, p = 0, 1
        for ch in str(n):
            s += int(ch)
            p *= int(ch)
        return p - s
```

</div>

<div id="163f8a94-dbe1-4e99-89ca-543584ad4a25" class="cell markdown">

# 17.

Date: 23rd Dec 2023<br> Medium Leetcode:
remove-all-adjacent-duplicates-in-string-ii<br> Solution:
<https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/submissions/1126450574/>

</div>

<div id="9421e5a6-7300-4107-a601-e1f1b90fe761" class="cell code"
execution_count="23">

``` python
class Solution:
    """
    Example 1:
    "pbbcggttciiippooaais", k = 2
    "pcciis"
    "ps"
    
    Example 2:
    "deeedbbcccbdaa", k = 3
    "ddbbbdaa"
    "dddaa"
    "aa"
    """

    # Solution idea from: https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/solutions/392933/java-c-python-two-pointers-and-stack-solution/

    def removeDuplicates(self, s: str, k: int) -> str:
        result = [['', 1]]
        for ch in s:
            if result[-1][0] == ch:
                result[-1][1] += 1
            else:
                result.append([ch, 1])
            if result[-1][1] == k:
                result.pop()
                
        return ''.join(map(lambda x: x[0] * x[1], result))

# Testing the solution
assert Solution().removeDuplicates("abcd", k=2) == 'abcd'
assert Solution().removeDuplicates("deeedbbcccbdaa", k=3) == 'aa'
assert Solution().removeDuplicates("pbbcggttciiippooaais", k=2) == 'ps'
assert Solution().removeDuplicates("abccba", k=2) == ''
```

</div>

<div id="77153c5a-851f-445e-aef9-385272b727f3" class="cell markdown">

# 18.

Date: 23rd Dec 2023<br> Medium Leetcode: capital-gainloss<br> Solution:
<https://leetcode.com/problems/capital-gainloss/submissions/1126487033/>

</div>

<div id="72963fb2-fac0-402a-829e-f6b3ca13c202" class="cell code"
execution_count="24">

``` python
temp = read_lc_df("""
+---------------+-----------+---------------+--------+
| stock_name    | operation | operation_day | price  |
+---------------+-----------+---------------+--------+
| Leetcode      | Buy       | 1             | 1000   |
| Corona Masks  | Buy       | 2             | 10     |
| Leetcode      | Sell      | 5             | 9000   |
| Handbags      | Buy       | 17            | 30000  |
| Corona Masks  | Sell      | 3             | 1010   |
| Corona Masks  | Buy       | 4             | 1000   |
| Corona Masks  | Sell      | 5             | 500    |
| Corona Masks  | Buy       | 6             | 1000   |
| Handbags      | Sell      | 29            | 7000   |
| Corona Masks  | Sell      | 10            | 10000  |
+---------------+-----------+---------------+--------+
""")

# Actual code startes here
_ = temp.groupby(['stock_name', 'operation'], as_index=False)['price'].sum()
_ = _.groupby('stock_name').apply(lambda x: x.iloc[1, 2] - x.iloc[0, 2]).reset_index()
_ = _.rename({0: 'capital_gain_loss'}, axis=1)
display(_)

# Using SQL
temp.to_sql("temp", if_exists='replace', con=conn, index=False)
pd.read_sql("""
with trade_sum as (
    select 
        stock_name, 
        operation, 
        sum(price) price
    from temp 
    group by stock_name, operation
),

buy as (
    select * from trade_sum t 
    where t.operation = 'Buy'
),

sell as (
    select * from trade_sum t 
    where t.operation = 'Sell'
)

select 
    s.stock_name, 
    (s.price - b.price) capital_gain_loss 
from buy b, sell s 
where b.stock_name = s.stock_name
""", con=conn)
```

<div class="output display_data">

         stock_name  capital_gain_loss
    0  Corona Masks             9500.0
    1      Handbags           -23000.0
    2      Leetcode             8000.0

</div>

<div class="output execute_result" execution_count="24">

         stock_name  capital_gain_loss
    0  Corona Masks             9500.0
    1      Handbags           -23000.0
    2      Leetcode             8000.0

</div>

</div>

<div id="0c7765f9-274c-494f-86a2-dfb99e42b27a" class="cell markdown">

# 19.

Date: 23rd Dec 2023<br> Medium Leetcode: monthly-transactions-i<br>
Solution:

</div>

<div id="641e2693-f755-4b7c-8d45-15ded8fcdc7e" class="cell code"
execution_count="25">

``` python
temp = read_lc_df("""
+-----+---------+----------+--------+------------+
| id  | country | state    | amount | trans_date |
| --- | ------- | -------- | ------ | ---------- |
| 121 | US      | approved | 1000   | 2018-12-18 |
| 122 | US      | declined | 2000   | 2018-12-19 |
| 123 | US      | approved | 2000   | 2019-01-01 |
| 124 | null    | approved | 2000   | 2019-01-07 |
+-----+---------+----------+--------+------------+
""")

temp['amount'] = temp['amount'].astype(float)
temp['trans_date'] = pd.to_datetime(temp['trans_date'])

# Start with the actual code
_ = temp.copy()
_['month'] = _['trans_date'].dt.strftime("%Y-%m")
_ = _.groupby(['month', 'country', 'state'], as_index=False, dropna=False)['amount'].agg(['sum', 'count'])

_ = pd.merge(
    _.groupby(['month', 'country'], as_index=False, dropna=False)[['sum', 'count']].agg('sum'),
    _[_['state'] == 'approved'].groupby(['month', 'country'], as_index=False, dropna=False)[['sum', 'count']].agg('sum'),
    how='left',
    on=['month', 'country']
)

__ = _.select_dtypes('number').columns
_[__] = _[__].fillna(0)
_ = _.rename({"count_x": "trans_count", "sum_x": "trans_total_amount", "sum_y": "approved_total_amount", "count_y": "approved_count"}, axis=1)
display(_[['month', 'country', 'trans_count', 'approved_count', 'trans_total_amount', 'approved_total_amount']])

# Write to Database for SQL
temp.to_sql("temp", if_exists='replace', index=False, con=conn)

# Write SQL Query
pd.read_sql(
'''
select 
    SUBSTR(t.trans_date, 0, 8) month,
    
    t.country,
    
    count(t.amount) trans_count,
    
    sum(
        CASE 
            WHEN t.state = 'approved' THEN 1
            ELSE 0
        END
    ) approved_count,
    
    sum(t.amount) trans_total_amount,
    
    sum(
        CASE 
            WHEN t.state = 'approved' THEN t.amount
            ELSE 0
        END
    ) approved_total_amount
    
from temp t
group by 1, t.country
'''
, con=conn)
```

<div class="output display_data">

         month country  trans_count  approved_count  trans_total_amount  \
    0  2018-12      US            2               1              3000.0   
    1  2019-01      US            1               1              2000.0   
    2  2019-01     NaN            1               1              2000.0   

       approved_total_amount  
    0                 1000.0  
    1                 2000.0  
    2                 2000.0  

</div>

<div class="output execute_result" execution_count="25">

         month country  trans_count  approved_count  trans_total_amount  \
    0  2018-12      US            2               1              3000.0   
    1  2019-01    None            1               1              2000.0   
    2  2019-01      US            1               1              2000.0   

       approved_total_amount  
    0                 1000.0  
    1                 2000.0  
    2                 2000.0  

</div>

</div>

<div id="b0bde1a6-9ca7-4b82-83bd-c9ac82b0c00b" class="cell markdown">

# 20.

Date: 24th Dec 2023<br> Medium Leetcode:
partitioning-into-minimum-number-of-deci-binary-numbers<br> Solution:
<https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/submissions/1127002126/>

</div>

<div id="c3fe25ad-56eb-4b75-9846-9ea61669327b" class="cell code"
execution_count="26">

``` python
# Example
print("692115")

# Sample solution
print(
    functools.reduce(
        lambda x, y: int(x) + int(y), 
        ["111111", "111001", "110001", "110001", "110001", "110000", "10000", "10000", "10000"], # Len - 9
        0)
)
# We only need to return the max char from the list
class Solution:
    def minPartitions(self, n: str) -> int:
       return max(map(int, n)) 

Solution().minPartitions("692115")
```

<div class="output stream stdout">

    692115
    692115

</div>

<div class="output execute_result" execution_count="26">

    9

</div>

</div>

<div id="634472f3-17ce-49d0-ba98-e7225b0db7db" class="cell markdown">

# 21.

Date: 24th Dec 2023<br> Medium Leetcode:
widest-vertical-area-between-two-points-containing-no-points<br>
Solution:

</div>

<div id="707c6740-4f90-4dd2-b243-f782255239fd" class="cell code"
execution_count="27">

``` python
class Solution:
    def maxWidthOfVerticalArea(self, points: List[List[int]]) -> int:
        sorted_coords = sorted(points, key=lambda x: x[0])
        result = -math.inf
        for i in range(len(sorted_coords) - 1):
            curr = sorted_coords[i + 1][0] - sorted_coords[i][0]
            if curr > result:
                result = curr
        return result

assert Solution().maxWidthOfVerticalArea([[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]) == 3
assert Solution().maxWidthOfVerticalArea([[8,7],[9,9],[7,4],[9,7]]) == 1
```

</div>

<div id="46204d31-f6f8-4d06-8f8c-a06b1f487694" class="cell markdown">

# 22.

Date: 24th Dec 2023<br> Easy Leetcode:
final-value-of-variable-after-performing-operations<br> Solution:
<https://leetcode.com/problems/final-value-of-variable-after-performing-operations/submissions/1127073907/>

</div>

<div id="0865eeaf-f3c8-45a9-93f9-1b5b0b31dd18" class="cell code"
execution_count="28">

``` python
mappings = {"--X": -1, "X--": -1, "++X": 1, "X++": 1}
temp = ["--X","X++","X++"]
sum(map(lambda x: mappings[x], temp))
```

<div class="output execute_result" execution_count="28">

    1

</div>

</div>

<div id="b0480586-de48-4a55-b05d-a7a5a71413b6" class="cell markdown">

# 23.

Date: 24th Dec 2023<br> Medium Leetcode:
minimum-number-of-swaps-to-make-the-string-balanced<br> Solution:
<https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-string-balanced/submissions/1127130139/>

</div>

<div id="45ab5e5f-5821-47b0-9c7f-d0a14074d65e" class="cell code"
execution_count="29">

``` python
"""
Balanced possibilities
n - 1:
[ ]

n - 2:
[ [ ] ]
[ ] [ ]

n - 3:
[ ] [ ] [ ]
[ [ ] [ ] ]
[ [ [ ] ] ]


Intuition:
1. Remove all the balanced brackets first, we would be left with something like this: "][", "]][[", "]]][[[", "]]]][[[[", etc
2. Swapping 1 pair reduces mismatched pairs by 2. Therefore for n (number of bracket `pair`), the number of swaps required would be ceil(n / 2).
"""

class Solution:
    def remove_balanced_brackets(self, s: str) -> str:
        stack = []
        for ch in s:
            if ch == "]" and len(stack) > 0 and stack[-1] == "[":
                stack.pop()
            else:
                stack.append(ch)
        return stack

    def minSwaps(self, s: str) -> int:
        purely_unbalanced = self.remove_balanced_brackets(s)
        return math.ceil(len(purely_unbalanced) / 4)
    
    def generate_unbalanced_str(n = 2):
        def balanced(s: str) -> bool:
            stack = []
            for ch in s:
                if ch == "[":
                    stack.append(ch)
                else:
                    if len(stack) > 0 and stack[-1] == "[":
                        stack.pop()
                    else:
                        return False
            return True
        
        return set(filter(lambda x: not balanced(x), map(lambda x: "".join(x), itertools.permutations("[]" * n, r=2*n))))
```

</div>

<div id="4b07690d-579f-45bb-9d84-2b1f026d2e6b" class="cell markdown">

# 24.

Date: 24th Dec 2023<br> Medium Leetcode:
array-with-elements-not-equal-to-average-of-neighbors<br> Solution:
<https://leetcode.com/problems/array-with-elements-not-equal-to-average-of-neighbors/submissions/1127221598/>

</div>

<div id="940607bd-d4cd-4f6c-9453-64e0ef7de2e3" class="cell code"
execution_count="30">

``` python
"""
[1,2,3]
[1,3,2]

[1,3,5,6,9]
[1,5,3,6,9]
[1,5,3,9,6]

Intution:
1. Keep sliding through the array until an index is reached where the condition fails (arr[i] = ((arr[i - 1] + arr[i + 1]) / 2)
2. For such instances swap the middle element with the right element.
3. This consititues one pass. Keep repeating steps 1 and 2 until the arr stops changing. At that point we would have arrived at our solution.
4. This is similar to how sorting algorithms like bubble sorting works.
"""

def rearrange(nums: List[int]) -> List[int]:
    nums = list(nums)
    for i in range(1, len(nums) - 1):
        if (2 * nums[i]) == (nums[i - 1] + nums[i + 1]):
            nums[i + 1], nums[i] = nums[i], nums[i + 1]
    return nums

def validate(nums: List[int]) -> bool:
    for i in range(1, len(nums) - 1):
        if (2 * nums[i]) == (nums[i - 1] + nums[i + 1]):
            return False, i, nums
    return True, None, None

assert validate(rearrange([1,3,5,6,9]))
assert validate(rearrange([1,2,3,4,5]))
assert validate(rearrange([6,2,0,9,7]))
assert validate(rearrange([1,2,3,4,5,6]))

for arr in tqdm.tqdm(itertools.permutations(range(9), 9), total=math.perm(9, 9), ascii=True):
    prev = None
    curr = arr
    while prev is None or any(map(lambda x: x[0] != x[1], zip(prev, curr))):
        prev, curr = curr, rearrange(curr)
        
    result = validate(curr)
    assert result[0], f"Input: {arr} | Result: {result[2]} fails condition at Index: {result[1]}"
```

<div class="output stream stderr">

    100%|#######################################################################| 362880/362880 [00:02<00:00, 136510.49it/s]

</div>

</div>

<div id="dd8022ca-708d-4b24-a054-860c4b5ffac8" class="cell markdown">

# 25.

Date: 24th Dec 2023<br> Easy Leetcode:
remove-letter-to-equalize-frequency<br> Solution:
<https://leetcode.com/problems/remove-letter-to-equalize-frequency/submissions/1127427755/>

</div>

<div id="c2d9d9bb-efca-4eb2-9aff-46570528fdd6" class="cell code"
execution_count="31">

``` python
def remove_letter(word: str) -> bool:
    
    counts = collections.Counter(word)
    freq = list(counts.values())
    alphabets = list(counts.keys())
    unique_freq = set(freq)
    minFreq = min(freq)
    maxFreq = max(freq)

    if len(alphabets) == 1: # aaaaaaaa
        return True
    elif len(unique_freq) == 1 and minFreq == 1: # abcdef
        return True
    elif len(unique_freq) == 2:
        if minFreq == 1 and freq.count(minFreq) == 1: # cccd
            return True
        else:
            return maxFreq - minFreq == 1 and freq.count(maxFreq) == 1
    else: # abbccc (3), aazz (1)
        return False

# remove_letter("aaaaaabbbbcccc")
remove_letter("ddaccb")
```

<div class="output execute_result" execution_count="31">

    False

</div>

</div>

<div id="f77a4d20-a558-4b95-9d77-dcd4d0898002" class="cell markdown">

# 26.

Date: 24th Dec 2023<br> Easy Leetcode: find-if-path-exists-in-graph<br>
Solution:
<https://leetcode.com/problems/find-if-path-exists-in-graph/submissions/1127439592/>

</div>

<div id="ca1fc8c6-3e7d-4c7e-bc07-630d1e08ed9b" class="cell code"
execution_count="32">

``` python
class Solution:
    def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:

        if source == destination:
            return True
        
        self.paths = dict()
        for start, end in edges:
            start_path = self.paths.get(start, [])
            end_path = self.paths.get(end, [])
            start_path.append(end)
            end_path.append(start)
            self.paths[start] = start_path
            self.paths[end] = end_path

        visited = set()
        to_visit = set([source])
        while to_visit:
            curr = to_visit.pop()
            if curr not in visited:
                visited.add(curr)
                to_visit = set([*to_visit, *self.paths[curr]])
            if destination in to_visit:
                return True
        return False

# Testing with samples from the q
assert Solution().validPath(6, [[0,1],[1,2],[2,0]], 0, 2) == True
assert Solution().validPath(6, [[0,1],[0,2],[3,5],[5,4],[4,3]], 0, 5) == False
```

</div>

<div id="9955f336-0371-4f54-aab1-03efd86029c3" class="cell markdown">

# 27.

Date: 24th Dec 2023<br> Medium Leetcode:
employees-whose-manager-left-the-company<br> Solution:
<https://leetcode.com/problems/employees-whose-manager-left-the-company/submissions/1127506611/>

</div>

<div id="4c3b1862-bef3-40fd-b45c-41f41cf22ae3" class="cell code"
execution_count="33">

``` python
temp = read_lc_df("""
+-------------+-----------+------------+--------+
| employee_id | name      | manager_id | salary |
| ----------- | --------- | ---------- | ------ |
| 3           | Mila      | 9          | 60301  |
| 12          | Antonella | null       | 31000  |
| 13          | Emery     | null       | 67084  |
| 1           | Kalel     | 11         | 21241  |
| 9           | Mikaela   | null       | 50937  |
| 11          | Joziah    | 6          | 28485  |
+-------------+-----------+------------+--------+
""")

# Doing it the Pandas way
temp['salary'] = temp['salary'].astype(float)
missing_ids = set(temp['manager_id'].dropna()) - set(temp['employee_id'])

_ = temp.loc[
    (temp['salary'] < 30_000) & 
    (temp['manager_id'].isin(missing_ids)),
    ['employee_id']
]

display(_.sort_values('employee_id'))

# Let us do this with SQL
temp.to_sql("temp", index=False, con=conn, if_exists='replace')
pd.read_sql("""
    select t1.employee_id 
    from temp t1 
    
    left join temp t2 
    on t1.manager_id = t2.employee_id 
    
    where 
        t1.manager_id is not null and 
        t2.employee_id is null and
        t1.salary < 30000
        
    order by t1.employee_id
""", con=conn)
```

<div class="output display_data">

      employee_id
    6          11

</div>

<div class="output execute_result" execution_count="33">

      employee_id
    0          11

</div>

</div>

<div id="e66e0ff4-8a0a-4055-bf6b-601c8ab52804" class="cell markdown">

# 28.

Date: 25th Dec 2023<br> Easy Leetcode: min-cost-climbing-stairs<br>
Solution:
<https://leetcode.com/problems/min-cost-climbing-stairs/submissions/1127787644/>

</div>

<div id="2866337c-5fd0-4ee1-a828-bcaec7028651" class="cell code"
execution_count="34">

``` python
class Solution:
    def calcCost(self, cost: List[int], index: int, cache: dict[int, int]) -> int:

        if index in cache:
            return cache[index]
        
        else:

            if index >= len(cost) - 1:
                res = sum(cost[index:])

            else:
                res = min(
                    cost[index] + self.calcCost(cost, index + 1, cache),
                    cost[index] + self.calcCost(cost, index + 2, cache)
                )

            cache[index] = res
            return res

    def minCostClimbingStairs(self, cost: List[int]) -> int:

        # DP - setting a cache
        cache = dict()

        return min(
            self.calcCost(cost, index=0, cache=cache),
            self.calcCost(cost, index=1, cache=cache)
        )

# Testing out solution with sample testcases
assert Solution().minCostClimbingStairs([1,100,1,1,1,100,1,1,100,1]) == 6
assert Solution().minCostClimbingStairs([10,15,20]) == 15
```

</div>

<div id="2b285329-9ff6-468a-8cd5-13f9b035701d" class="cell markdown">

# 29.

Date: 25th Dec 2023<br> Medium Leetcode: nth-highest-salary<br>
Solution:
<https://leetcode.com/problems/nth-highest-salary/submissions/1128029354>

</div>

<div id="677c9ef7-e581-4655-bad8-25e30b30e5b4" class="cell code"
execution_count="35">

``` python
temp = read_lc_df("""
+----+--------+
| id | salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+
""")

def nlargest_salary(df: pd.DataFrame, n: int) -> pd.DataFrame:
    result = np.sort(df['salary'].unique())[::-1]
    result = None if len(result) < n else result[n - 1]
    return pd.DataFrame({f"getNthHighestSalary({n})": [result]})

display(nlargest_salary(temp, 5))

# With SQL - highly inefficient but this is what I submitted
"""
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN

  DECLARE result INT;

  WITH TEMP1 AS (
      SELECT DISTINCT SALARY FROM EMPLOYEE
  ),

  TEMP2 AS (
      SELECT SALARY, RANK() OVER(ORDER BY SALARY DESC) RNK FROM TEMP1
  )

  SELECT T.SALARY INTO result FROM TEMP2 T WHERE T.RNK = N;

  RETURN result;
END
""";
```

<div class="output display_data">

      getNthHighestSalary(5)
    0                   None

</div>

</div>

<div id="4922ff9b-9bbb-4cc0-92a7-fa4748131e5f" class="cell markdown">

# 30.

Date: 25th Dec 2023<br> Easy Leetcode: game-play-analysis-i <br>
Solution:
<https://leetcode.com/problems/game-play-analysis-i/submissions/1128051660/>

1.  Pandas Solution

``` python
def game_analysis(activity: pd.DataFrame) -> pd.DataFrame:
    res = activity.groupby("player_id", as_index=False)['event_date'].min()
    return res.rename({"event_date": "first_login"}, axis=1)
```

1.  MYSQL Solution

``` sql
select 
    a.player_id, min(event_date) first_login 
from activity a 
group by a.player_id
```

</div>

<div id="0a0f25ea-98dd-43d2-89de-273834ffa9eb" class="cell markdown">

# 31.

Date: 25th Dec 2023<br> Medium Leetcode:
friend-requests-ii-who-has-the-most-friends<br> Solution:
<https://leetcode.com/problems/friend-requests-ii-who-has-the-most-friends/submissions/1128058275/>

</div>

<div id="b4661f78-25cf-4f8b-808d-14c348569d39" class="cell code"
execution_count="36">

``` python
temp = read_lc_df("""
+--------------+-------------+-------------+
| requester_id | accepter_id | accept_date |
| ------------ | ----------- | ----------- |
| 4            | 10          | 2016/08/11  |
| 10           | 13          | 2016/02/01  |
| 10           | 17          | 2016/07/17  |
| 10           | 21          | 2016/02/15  |
| 23           | 10          | 2016/12/14  |
| 10           | 25          | 2016/02/23  |
| 10           | 29          | 2016/06/12  |
| 10           | 30          | 2016/07/28  |
| 10           | 34          | 2016/04/24  |
| 14           | 17          | 2016/06/28  |
| 22           | 17          | 2016/04/28  |
| 23           | 17          | 2016/03/21  |
| 17           | 24          | 2016/01/21  |
| 17           | 28          | 2016/02/18  |
| 31           | 17          | 2016/03/30  |
| 17           | 34          | 2016/06/17  |
+--------------+-------------+-------------+
""")

def most_friends(request_accepted: pd.DataFrame) -> pd.DataFrame:
    accepts = request_accepted['accepter_id'].values
    sends = request_accepted['requester_id'].values
    res = collections.Counter([*accepts, *sends]).most_common(1)
    return pd.DataFrame(res, columns=['id', 'num'])

display(most_friends(temp))
temp.to_sql("temp", if_exists='replace', con=conn, index=False)
pd.read_sql("""
with connections as (
    select t.accepter_id id from temp t 
    UNION ALL
    select t.requester_id id from temp t
)

select 
    c.id, count(*) as num 
from connections c 
group by c.id 
order by num desc limit 1
""", con=conn)
```

<div class="output display_data">

       id  num
    0  10    9

</div>

<div class="output execute_result" execution_count="36">

       id  num
    0  10    9

</div>

</div>

<div id="bbcd6b5e-c2f3-42d5-a8ca-6c3960c8f0d1" class="cell markdown">

# 32.

Date: 25th Dec 2023<br> Hard Leetcode: trips-and-users<br> Solution:
<https://leetcode.com/problems/trips-and-users/submissions/1128146666>

</div>

<div id="d129a355-6af3-485f-8238-fc48eaae5bb7" class="cell code"
execution_count="37">

``` python
trips = read_lc_df("""
+----+-----------+-----------+---------+---------------------+------------+
| id | client_id | driver_id | city_id | status              | request_at |
+----+-----------+-----------+---------+---------------------+------------+
| 1  | 1         | 10        | 1       | completed           | 2013-10-01 |
| 2  | 2         | 11        | 1       | cancelled_by_driver | 2013-10-01 |
| 3  | 3         | 12        | 6       | completed           | 2013-10-01 |
| 4  | 4         | 13        | 6       | cancelled_by_client | 2013-10-01 |
| 5  | 1         | 10        | 1       | completed           | 2013-10-02 |
| 6  | 2         | 11        | 6       | completed           | 2013-10-02 |
| 7  | 3         | 12        | 6       | completed           | 2013-10-02 |
| 8  | 2         | 12        | 12      | completed           | 2013-10-03 |
| 9  | 3         | 10        | 12      | completed           | 2013-10-03 |
| 10 | 4         | 13        | 12      | cancelled_by_driver | 2013-10-03 |
+----+-----------+-----------+---------+---------------------+------------+
""")

# Little bit o
trips['request_at'] = pd.to_datetime(trips['request_at'])

users = read_lc_df("""
+----------+--------+--------+
| users_id | banned | role   |
+----------+--------+--------+
| 1        | No     | client |
| 2        | Yes    | client |
| 3        | No     | client |
| 4        | No     | client |
| 10       | No     | driver |
| 11       | No     | driver |
| 12       | No     | driver |
| 13       | No     | driver |
+----------+--------+--------+
""")

def calculate_cancellation_rate(trips: pd.DataFrame, users: pd.DataFrame) -> pd.DataFrame:

    def calc_rate(df_):
        _ = df_.value_counts()
        if 'cancelled' in _.index:
            return round(_.loc['cancelled'] / _.sum(), 2)
        else:
            return 0

    trips_filtered = trips[('2013-10-01' <= trips['request_at']) & (trips['request_at'] <= '2013-10-03')]
    
    trip_clients = pd.merge(
        trips_filtered, 
        users[['users_id', 'banned']].add_prefix('CLIENT_'), 
        left_on='client_id', right_on='CLIENT_users_id', 
    )
    
    trip_merged = pd.merge(
        trip_clients,
        users[['users_id', 'banned']].add_prefix('DRIVER_'), 
        left_on='driver_id', right_on='DRIVER_users_id'
    )

    # Edge case
    if len(trip_merged) == 0:
        return pd.DataFrame(columns=['Day', 'Cancellation Rate'], data=[])

    else:
        trip_merged = trip_merged[(trip_merged['CLIENT_banned'] == 'No') & (trip_merged['DRIVER_banned'] == 'No')]
        trip_merged = trip_merged[['request_at', 'status']]
        trip_merged['status'] = trip_merged['status'].str.replace('\_by\_.*', '', regex=True)
        trip_merged = trip_merged.groupby('request_at', as_index=False)['status'].agg(calc_rate)
        trip_merged.columns = ['Day', 'Cancellation Rate']
        return trip_merged if type(trip_merged) == pd.DataFrame else trip_merged.reset_index()
    
display(calculate_cancellation_rate(trips, users))

# SQL Code
users.to_sql("users", con=conn, index=False, if_exists='replace')
trips.to_sql("trips", con=conn, index=False, if_exists='replace')
pd.read_sql("""

    with temp as (
        select 
            t.request_at,
            t.status
        from trips t, users c, users d
        where 
            t.client_id = c.users_id and
            t.driver_id = d.users_id and
            t.request_at >= '2013-10-01' and
            t.request_at < '2013-10-04' and
            d.banned = 'No' and
            c.banned = 'No'
    )

    select 
        t.request_at Day,
        ROUND(AVG(
            CASE 
                WHEN t.status != 'completed' THEN 1
                ELSE 0
            END 
        ), 2) "Cancellation Rate"
        
    from temp t 
    group by t.request_at
    order by 1
    
""", con=conn)
```

<div class="output display_data">

             Day  Cancellation Rate
    0 2013-10-01               0.33
    1 2013-10-02               0.00
    2 2013-10-03               0.50

</div>

<div class="output execute_result" execution_count="37">

                       Day  Cancellation Rate
    0  2013-10-01T00:00:00               0.33
    1  2013-10-02T00:00:00               0.00
    2  2013-10-03T00:00:00               0.50

</div>

</div>

<div id="cc8cebb4-1d43-4935-bfa5-3f485a279423" class="cell markdown">

# 32.

Date: 26th Dec 2023<br> Medium Leetcode: subrectangle-queries<br>
Solution:
<https://leetcode.com/problems/subrectangle-queries/submissions/1128517749/>

</div>

<div id="8557565c-8517-48aa-bb83-3e86315dd80b" class="cell code"
execution_count="38">

``` python
class SubrectangleQueries:

    def __init__(self, rectangle: List[List[int]]):
        self.rectangle = rectangle
        self.rows = len(self.rectangle)
        self.cols = len(self.rectangle[0])
        self.ops = []

    def updateSubrectangle(self, row1: int, col1: int, row2: int, col2: int, newValue: int) -> None:
        self.ops.append([row1, col1, row2, col2, newValue])

    def getValue(self, row: int, col: int) -> int:
        for op in self.ops[::-1]:
            if SubrectangleQueries.is_point_inside_subrectangle(row, col, *op[:-1]):
                return op[-1]
        return self.rectangle[row][col]

    def is_point_inside_subrectangle(p_row, p_col, row_1, col_1, row_2, col_2) -> bool:
        return row_1 <= p_row <= row_2 and col_1 <= p_col <= col_2

    def __str__(self):
        res = ""
        for row in self.rectangle:
            res += f'{", ".join(map(lambda x: str(x).rjust(3), row))}\n'
        return res

# Sample calls
temp = SubrectangleQueries([[1,2,1],[4,3,4],[3,2,1],[1,1,1]])
assert temp.getValue(*[0,2]) == 1
temp.updateSubrectangle(*[0,0,3,2,5])
assert temp.getValue(*[0,2]) == 5
assert temp.getValue(*[3,1]) == 5
temp.updateSubrectangle(*[3,0,3,2,10])
assert temp.getValue(*[3,1]) == 10
assert temp.getValue(*[0,2]) == 5
```

</div>

<div id="702699f0-7281-4d25-a93f-470fef1e676c" class="cell markdown">

# 33.

Date: 26th Dec 2023<br> Medium Leetcode:
find-the-original-array-of-prefix-xor<br> Solution:
<https://leetcode.com/problems/find-the-original-array-of-prefix-xor/submissions/1128524993/>

</div>

<div id="916e601b-4b80-4852-94a5-3108d874ed69" class="cell code"
execution_count="39">

``` python
def get_original_arr(arr: list[list[int]]):
    accumulated_xor = 0
    res = []
    for n in arr:
        res.append(accumulated_xor ^ n)
        accumulated_xor = accumulated_xor ^ res[-1]
    return res

get_original_arr([5,2,0,3,1])
```

<div class="output execute_result" execution_count="39">

    [5, 7, 2, 3, 2]

</div>

</div>

<div id="117eb9b6-91cd-4c10-9fc8-a62c1046c28a" class="cell markdown">

# 34.

Date: 26th Dec 2023<br> Medium Leetcode:
insert-greatest-common-divisors-in-linked-list<br> Solution:
<https://leetcode.com/problems/insert-greatest-common-divisors-in-linked-list/submissions/1128528173/>

</div>

<div id="09e9f72f-f27c-4a70-a698-cac8a5472846" class="cell code"
execution_count="40">

``` python
class Solution:

    class ListNode:
         def __init__(self, val=0, next=None):
             self.val = val
             self.next = next
    
    def insertGreatestCommonDivisors(self, head):
        curr = head 
        while curr.next != None:
            to_insert = ListNode(val=math.gcd(curr.val, curr.next.val), next=curr.next)
            curr.next = to_insert
            curr = to_insert.next

        return head
```

</div>

<div id="0ed06e98-ee02-4df9-aef9-451feee791de" class="cell markdown">

# 35.

Date: 26th Dec 2023<br> Medium Leetcode:
maximum-number-of-coins-you-can-get<br> Solution:
<https://leetcode.com/problems/maximum-number-of-coins-you-can-get/submissions/1128578272/>

</div>

<div id="7b7ab538-7086-43aa-ba4b-275e8d89dce5" class="cell code"
execution_count="41">

``` python
def slide(arr: List[int]) -> int:
    arr.sort()
    res = 0
    n = len(arr)
    n_iters = len(arr) // 3
    for i in range(1, n_iters + 1):
        res += arr[-i * 2]
    return res

slide([2,4,1,2,7,8])
```

<div class="output execute_result" execution_count="41">

    9

</div>

</div>

<div id="21a8c5da-ae50-4dc6-8c29-ffca49c78d60" class="cell markdown">

# 36.

Date: 27th Dec 2023<br> Hard Leetcode: department-top-three-salaries<br>
Solution:
<https://leetcode.com/problems/department-top-three-salaries/submissions/1129285823/>

</div>

<div id="91fa7e76-e421-4781-b0e2-fd6e00cdbfb1" class="cell code"
execution_count="42">

``` python
employees = read_lc_df("""
+----+-------+--------+--------------+
| id | name  | salary | departmentId |
+----+-------+--------+--------------+
| 1  | Joe   | 85000  | 1            |
| 2  | Henry | 80000  | 2            |
| 3  | Sam   | 60000  | 2            |
| 4  | Max   | 90000  | 1            |
| 5  | Janet | 69000  | 1            |
| 6  | Randy | 85000  | 1            |
| 7  | Will  | 70000  | 1            |
+----+-------+--------+--------------+
""")

departments = read_lc_df("""
+----+-------+
| id | name  |
+----+-------+
| 1  | IT    |
| 2  | Sales |
+----+-------+
""")

def top_3_salaries(emp: pd.DataFrame, dept: pd.DataFrame) -> pd.DataFrame:
    temp = emp.merge(
        dept.rename({'name': 'Department', 'id': 'dept_id'}, axis=1), 
        left_on='departmentId', right_on='dept_id'
    )
    
    temp = temp.drop('departmentId', axis=1).rename({'name': 'Employee', 'salary': 'Salary'}, axis=1)
    temp['salary_rnk'] = temp.groupby('dept_id')['Salary'].rank(method='dense', ascending=False)
    temp = temp.loc[temp['salary_rnk'] <= 3, ['Department', 'Employee', 'Salary']]
    
    return temp

# Take the code for a test run
display(top_3_salaries(employees, departments))

# Repeat the same with SQL
employees.to_sql("employees", if_exists='replace', index=False, con=conn)
departments.to_sql("departments", if_exists='replace', index=False, con=conn)

pd.read_sql("""
    with temp as (
        select 
            e.id, 
            e.name Employee, 
            e.salary Salary,
            d.name Department, 
            DENSE_RANK() OVER(partition by e.departmentId order by salary desc) salary_rnk
        from employees e, departments d
        where e.departmentId = d.id 
    )

    select t.Department, t.Employee, t.Salary 
    from temp t where t.salary_rnk <= 3
""", con=conn)
```

<div class="output display_data">

      Department Employee   Salary
    0         IT      Joe  85000.0
    1         IT      Max  90000.0
    3         IT    Randy  85000.0
    4         IT     Will  70000.0
    5      Sales    Henry  80000.0
    6      Sales      Sam  60000.0

</div>

<div class="output execute_result" execution_count="42">

      Department Employee   Salary
    0         IT      Max  90000.0
    1         IT      Joe  85000.0
    2         IT    Randy  85000.0
    3         IT     Will  70000.0
    4      Sales    Henry  80000.0
    5      Sales      Sam  60000.0

</div>

</div>

<div id="5f63c32e-f179-4857-a8c0-3627f7e86225" class="cell markdown">

# 37.

Date: 27th Dec 2023<br> Hard Leetcode: unique-paths-iii<br> Solution:
<https://leetcode.com/problems/unique-paths-iii/submissions/1129413397/>

</div>

<div id="fbcb7962-3b4f-4e0e-933f-26897ada8d45" class="cell code"
execution_count="43" scrolled="true">

``` python
class Solution:
    def walk(self, curr, visited):

        # Base case
        if curr == self.end_pos:
            return 1 if len(visited) + 1 == self.rows * self.cols else 0
            
        # Nowhere to go
        paths = 0

        # Walk up
        next = (curr[0] - 1, curr[1])
        if curr[0] > 0 and next not in visited:
            paths += self.walk(next, visited={*visited, curr})

        # Walk down
        next = (curr[0] + 1, curr[1])
        if curr[0] < self.rows - 1 and next not in visited:
            paths += self.walk(next, visited={*visited, curr})

        # Walk left
        next = (curr[0], curr[1] - 1)
        if curr[1] > 0 and next not in visited:
            paths += self.walk(next, visited={*visited, curr})

        # Walk right
        next = (curr[0], curr[1] + 1)
        if curr[1] < self.cols - 1 and next not in visited:
            paths += self.walk(next, visited={*visited, curr})

        return paths
    
    def uniquePathsIII(self, grid: List[List[int]]) -> int:

        self.start_pos = None
        self.end_pos = None
        self.obstacles = set()
        self.rows = len(grid)
        self.cols = len(grid[0])
        self.grid = grid

        # Walk through and find the starting, ending and obstacle cells
        for i in range(self.rows):
            for j in range(self.cols):
                curr = self.grid[i][j]
                if curr == 1:
                    self.start_pos = (i, j)
                elif curr == 2:
                    self.end_pos = (i, j)
                elif curr == -1:
                    self.obstacles.add((i, j))

        return self.walk(curr=self.start_pos, visited=self.obstacles)

# Test the solution
assert Solution().uniquePathsIII([[1,0,0,0],[0,0,0,0],[0,0,2,-1]]) == 2
assert Solution().uniquePathsIII([[1,0,0,0],[0,0,0,0],[0,0,0,2]]) == 4
assert Solution().uniquePathsIII([[0,1],[2,0]]) == 0
```

</div>

<div id="9f92bb65-1b33-4ab7-86d1-03d80e2ef6f7" class="cell markdown">

# 38.

Date: 27th Dec 2023<br> Medium Leetcode: sort-the-matrix-diagonally<br>
Solution:
<https://leetcode.com/problems/sort-the-matrix-diagonally/submissions/1129438122/>

</div>

<div id="46a47d59-e567-4d3e-bc08-0bfe3e07e991" class="cell code"
execution_count="44">

``` python
class Solution:
    def getDiagnolIndices(iteration: int, rows: int, cols: int) -> List[int]:
        '''
        0 - top-right
        .
        .
        n - bottom-left
        '''
        
        curr_x = max(0, iteration - cols + 1)
        curr_y = max(0, cols - iteration - 1)

        diagnol = []
        while curr_x < rows and curr_y < cols:
            diagnol.append((curr_x, curr_y))
            curr_x += 1
            curr_y += 1

        return diagnol
    
    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:
        
        self.mat = mat
        self.rows = len(mat)
        self.cols = len(mat[0])
        self.diagnol_counts = self.rows + self.cols - 1

        for i in range(self.diagnol_counts):
            diagnol_indices = Solution.getDiagnolIndices(i, self.rows, self.cols)
            
            diagnol = []
            for x, y in diagnol_indices:
                diagnol.append(self.mat[x][y])
                
            diagnol.sort()
            
            for j, (x, y) in enumerate(diagnol_indices):
                self.mat[x][y] = diagnol[j]
                
        return mat

# Test the solution
assert Solution().diagonalSort([[3,3,1,1],[2,2,1,2],[1,1,1,2]]) ==  [[1,1,1,1],[1,2,2,2],[1,2,3,3]]        
assert Solution().diagonalSort([[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]) == [[5,17,4,1,52,7],[11,11,25,45,8,69],[14,23,25,44,58,15],[22,27,31,36,50,66],[84,28,75,33,55,68]]
```

</div>

<div id="f6984db4-d9e4-48d2-9936-cb7b35e89ed3" class="cell markdown">

# 39.

Date: 27th Dec 2023<br> Medium Leetcode: sort-vowels-in-a-string<br>
Solution:
<https://leetcode.com/problems/sort-vowels-in-a-string/submissions/1129459170/>

</div>

<div id="e91e0bad-9525-4235-897c-ad5760ce47c7" class="cell code"
execution_count="45">

``` python
class Solution:
    def sortVowels(self, s: str) -> str:
        
        buckets = {ch: [] for ch in "AEIOUaeiou"}
        vowel_indices = []
        res = []
        
        for i, ch in enumerate(s):
            res.append(ch)
            if ch in buckets.keys():
                vowel_indices.append(i)
                buckets[ch].append(ch)

        vowels_sorted = ''.join([''.join(buckets[vowel]) for vowel in 'AEIOUaeiou'])
        for i, ch in zip(vowel_indices, vowels_sorted):
            res[i] = ch

        return ''.join(res)

# Test the solution
assert Solution().sortVowels("lEetcOde") == 'lEOtcede'
assert Solution().sortVowels("lYmpH") == 'lYmpH'
```

</div>

<div id="aafa61b9-f8ab-4999-bfbb-1d4cdc47b99c" class="cell markdown">

# 40.

Date: 27th Dec 2023<br> Medium Leetcode:
finding-the-users-active-minutes<br> Solution:
<https://leetcode.com/problems/finding-the-users-active-minutes/submissions/1129469068/>

</div>

<div id="1fb6ef02-7169-474d-b3a4-6ac1e320d262" class="cell code"
execution_count="46">

``` python
class Solution:
    def findingUsersActiveMinutes(self, logs: List[List[int]], k: int) -> List[int]:
        UAM_dict = dict()
        for uid, time in logs:
            UAM = UAM_dict.get(uid, set())
            UAM.add(time)
            UAM_dict[uid] = UAM

        res = [0] * k
        for UAM in UAM_dict.values():
            res[len(UAM) - 1] += 1

        return res

# Test the solution
assert Solution().findingUsersActiveMinutes([[0,5],[1,2],[0,2],[0,5],[1,3]], 5) == [0,2,0,0,0]
assert Solution().findingUsersActiveMinutes([[1,1],[2,2],[2,3]], 4) == [1,1,0,0]
```

</div>

<div id="1cfadc55-e871-4898-8f8a-24adcd59548e" class="cell markdown">

# 41.

Date: 28th Dec 2023<br> Medium Leetcode: combination-sum<br> Solution:
<https://leetcode.com/problems/combination-sum/submissions/1130137369/>

</div>

<div id="009307c8-392c-41dd-9328-819820855537" class="cell code"
execution_count="47">

``` python
class Solution:
    def solve(self, candidates: List[int], target: int, combination: List[int] = []) -> None:
        if target == 0:
            self.solutions.append(combination)
        elif target < 0 or len(candidates) == 0:
            pass
        else:
            pick = self.solve(candidates, target - candidates[0], combination=[*combination, candidates[0]]) 
            
            if target > candidates[0]:
                no_pick = self.solve(candidates[1:], target, combination=[*combination])
        
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        self.solutions = []

        # Sort for optimization - if candidates[0] > currTarget discard the no pick
        candidates.sort()
        
        self.solve(candidates, target)
        return self.solutions

# Testing the solution
print(Solution().combinationSum([2,3,6,7], 7))
print(Solution().combinationSum([2,3,5], 5))
```

<div class="output stream stdout">

    [[2, 2, 3], [7]]
    [[2, 3], [5]]

</div>

</div>

<div id="4e42b8cb-2bf2-4ff5-bcbb-1f968b6cf648" class="cell markdown">

# 42.

Date: 28th Dec 2023<br> Medium Leetcode:
number-of-subsequences-that-satisfy-the-given-sum-condition<br>
Solution:

</div>

<div id="df20c4bc-70ae-442e-8098-795723469771" class="cell code"
execution_count="48">

``` python
class Solution:
    def all_possible_combination_count(n):
        return sum(math.comb(n, _) for _ in range(1, n + 1))
        
    def numSubseq(self, nums: List[int], target: int) -> int:
        '''https://www.youtube.com/watch?v=xCsIkPLS4Ls'''
        # Sort the array - order doesn't matter since we are computing the min and max of the resultant subsequences
        nums.sort()

        # Note that we are only initializing j once, if for a smaller number nums[i], nums[j] is the maximum number possible 
        # then for a larger number nums[i+1], we can only have values nums[j] or lesser
        # Reason behind using `pow`: https://stackoverflow.com/a/59143871
        res = 0
        j = len(nums) - 1
        mod = 10 ** 9 + 7
        for i in range(len(nums)):
            while nums[i] + nums[j] > target and i <= j:
                j -= 1
            if i <= j:
                res += pow(2, j - i, mod)
                
        return res % mod

    def num_sub_seq_brute(self, nums: List[int], target: int) -> int:
        res = 0
        for k in range(1, len(nums) + 1):
            for combination in itertools.combinations(nums, k):
                if max(combination) + min(combination) <= target:
                    res += 1
        return res
    
# Testing the solution
assert Solution().numSubseq([3,5,6,7], 9) == 4
assert Solution().numSubseq([3,3,6,8], 10) == 6
assert Solution().numSubseq([2,3,3,4,6,7], 12) == 61
```

</div>

<div id="b618d43d-b4b7-4da1-936a-7fc34d2918ac" class="cell markdown">

# 43.

Date: 28th Dec 2023<br> Easy Leetcode: number-of-1-bits<br> Solution:
<https://leetcode.com/problems/number-of-1-bits/submissions/1130603960/>

</div>

<div id="f142b664-b62b-4c66-b742-6c942aa86451" class="cell code"
execution_count="49">

``` python
class Solution:
    def hammingWeight(self, n: int) -> int:
        res = 0
        while n >= 2:
            res += n % 2
            n = n // 2
        return res + n

    def hammingWeightBitOps(self, n:int) -> int:
        # 1000 & 1 in python is treated literally as 1000 & 0001 
        # 1001 & 1 in python would be treated as 1001 & 0001 
        res = 0
        while n > 0:
            res += n & 1
            n >>= 1
            
        return res

# Test the solution
temp = ''.join(random.choices('01', k=32))
assert Solution().hammingWeight(int(temp, 2)) == temp.count('1')
assert Solution().hammingWeightBitOps(int(temp, 2)) == temp.count('1')
```

</div>

<div id="24c77394-b6b2-4356-8681-e3489654fe1c" class="cell markdown">

# 44.

Date: 28th Dec 2023<br> Easy Leetcode: contains-duplicate<br> Solution:
<https://leetcode.com/problems/contains-duplicate/submissions/1130609829/>

</div>

<div id="4195d403-f135-4317-80f0-9a70b9f9e094" class="cell code"
execution_count="50">

``` python
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        hashset = set()
        for n in nums:
            if n in hashset:
                return True
            hashset.add(n) 

        return False
```

</div>

<div id="b1ddd5ea-828c-48a0-b68d-43e75e37a0ca" class="cell markdown">

# 45.

Date: 28th Dec 2023<br> Easy Leetcode: minimum-depth-of-binary-tree<br>
Solution:
<https://leetcode.com/problems/minimum-depth-of-binary-tree/submissions/1130616664/>

</div>

<div id="93dc53c9-b453-461c-b103-e32a1fc5cfe1" class="cell code"
execution_count="51">

``` python
class Solution:
    def walk(self, curr, depth):
        if curr.left is None and curr.right is None:
            return depth + 1
        elif curr.left is None:
            return self.walk(curr.right, depth + 1)
        elif curr.right is None:
            return self.walk(curr.left, depth + 1)
        else:
            return min(
                self.walk(curr.left, depth + 1),
                self.walk(curr.right, depth + 1)
            )

    def minDepth(self, root) -> int:
        if root is None:
            return 0
        return self.walk(root, 0)
```

</div>

<div id="db5376dc-de8f-4a48-9752-e74ac16614f0" class="cell markdown">

# 46.

Date: 28th Dec 2023<br> Easy Leetcode:
binary-tree-postorder-traversal<br> Solution:
<https://leetcode.com/problems/binary-tree-postorder-traversal/submissions/1130621232/>

</div>

<div id="e59ca57e-9abf-422b-852f-6d07cdad3ae0" class="cell code"
execution_count="52">

``` python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def traverse(self, curr):
        if curr is None:
            return

        self.traverse(curr.left)
        self.traverse(curr.right)
        self.solution.append(curr.val)

    def postorderTraversal(self, root) -> List[int]: 
        self.solution = []
        self.traverse(root)
        return self.solution
```

</div>

<div id="ba89bc43-c2f0-477b-9b14-71f876b2e9e6" class="cell markdown">

# 47.

Date: 29th Dec 2023<br> Medium Leetcode: subsets<br> Solution:
<https://leetcode.com/problems/subsets/submissions/1130994377/>

</div>

<div id="97c6f879-7840-46fa-a7cc-039035158110" class="cell code"
execution_count="53">

``` python
class Solution:
    def combinations(self, nums, curr = []):
        if len(nums) == 0:
            self.solutions.append(curr)
        else:
            # Don't pick the current one
            self.combinations(nums[1:], curr)

            # Pick the current one
            self.combinations(nums[1:], [*curr, nums[0]])

    def subsets(self, nums: List[int]) -> List[List[int]]:
        self.solutions = []
        # self.combinations(nums)
        self.solutions = self.BFS(nums)
        return self.solutions

    def BFS(self, nums):
        res = [[]]
        for n in nums:
            res += [comb + [n] for comb in res]
            
        return res

# Test the soltion
Solution().subsets([1, 2, 3])
```

<div class="output execute_result" execution_count="53">

    [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]

</div>

</div>

<div id="37e2798e-83d7-4070-97c3-03eb8f140e1f" class="cell markdown">

# 48.

Date: 29th Dec 2023<br> Medium Leetcode:
remove-duplicates-from-sorted-array-ii<br> Solution:
<https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/submissions/1131023813/>

</div>

<div id="47d79d5d-3756-4e06-b70f-61173d18e48f" class="cell code"
execution_count="54">

``` python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums) <= 2:
            return len(nums)
        
        # Mark the indices for deletion: O(n)
        cnt = 1
        curr = nums[0]
        for i in range(1, len(nums)):
            if nums[i] == curr:
                cnt += 1
                if cnt > 2:
                    nums[i] = None
            else:
                curr = nums[i]
                cnt = 1

        # Shift all None to the right
        i, j = 0, 1
        while j < len(nums):
            if nums[i] is None:
                if nums[j] is None:
                    j += 1
                else:
                    nums[i], nums[j] = nums[j], nums[i]
                    i, j = i + 1, j + 1
            else:
                i, j = i + 1, j + 1

        return len(nums) - nums.count(None)

    def assertSolution(nums, sol):
        assert Solution().removeDuplicates(nums) == len(sol)
        assert all(n1 == n2 for n1, n2 in zip(nums, sol))

# Test the solution
Solution.assertSolution([0,0,1,1,1,1,2,3,3], [0,0,1,1,2,3,3])
Solution.assertSolution([0,0,1,1,1,1,1,1,2,3,3,3], [0,0,1,1,2,3,3])
Solution.assertSolution([], [])
Solution.assertSolution([1,1], [1,1])
Solution.assertSolution([1,2], [1,2])
Solution.assertSolution([1,1,1], [1,1])
Solution.assertSolution([1,1,1,2,2,3], [1,1,2,2,3])
```

</div>

<div id="7a22a9f0-b201-41d9-acfd-af15b656c144" class="cell markdown">

# 49.

Date: 30th Dec 2023<br> Medium Leetcode: interleaving-string<br>
Solution:
<https://leetcode.com/problems/interleaving-string/submissions/1131849169/>

</div>

<div id="995a2aa5-dd4a-4191-8c27-6d609a5f88fe" class="cell code"
execution_count="55">

``` python
class Solution:

    @functools.cache
    def backtrack(self, i: int = 0, j: int = 0) -> bool:

        if (self.n - i) + (self.m - j) != (self.k - i - j):
            return False
        elif self.n - 1 == i and self.m - 1 == j and self.k - 1 == i + j:
            return True
        elif i >= self.n:
            return self.s3[i + j:] == self.s2[j:]
        elif j >= self.m:
            return self.s3[i + j:] == self.s1[i:]
        elif i + j >= self.k:
            return False
        elif self.s1[i] != self.s3[i + j] and self.s2[j] != self.s3[i + j]:
            return False
        elif self.s1[i] == self.s3[i + j] and self.s2[j] == self.s3[i + j]:
            return self.backtrack(i + 1, j) or self.backtrack(i, j + 1)
        elif self.s1[i] == self.s3[i + j]:
            return self.backtrack(i + 1, j)
        elif self.s2[j] == self.s3[i + j]:
            return self.backtrack(i, j + 1)
        else:
            assert False, f"Branch shouldn't execute here - {i}, {j}"

    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:
        self.s1 = s1
        self.n = len(s1)

        self.s2 = s2
        self.m = len(s2)

        self.s3 = s3
        self.k = len(s3)

        ans = self.backtrack()
        return ans

# Test our solution
assert Solution().isInterleave("aabcc", "dbbca", "aadbbcbcac") == True
assert Solution().isInterleave("aabcc", "dbbca", "aadbbbaccc") == False
assert Solution().isInterleave("", "", "") == True
assert Solution().isInterleave("a", "b", "a") == False
```

</div>

<div id="878211bf-7e94-4f30-9db7-eed5233272d5" class="cell markdown">

# 50.

Date: 30th Dec 2023<br> Medium Leetcode:
flip-equivalent-binary-trees<br> Solution:
<https://leetcode.com/problems/flip-equivalent-binary-trees/submissions/1132021517/>

</div>

<div id="64f660d9-15c6-4846-8729-ace20bbc74b4" class="cell code"
execution_count="56">

``` python
class Solution:
    def flipEquiv(self, root1: BinaryTreeNode, root2: BinaryTreeNode) -> bool:

        if root1 is None or root2 is None:
            return root1 == root2

        else:
            # Check root value equivality
            root_equality = root1.val == root2.val
            if not root_equality:
                return False

            # Check flip equivalent
            flip_equivalent = (
                self.flipEquiv(root1.left, root2.right) and 
                self.flipEquiv(root1.right, root2.left)
            )
            
            if flip_equivalent:
                return True

            # Check non flip equivalent
            non_flip_equivalent = (
                self.flipEquiv(root1.left, root2.left) and 
               self.flipEquiv(root1.right, root2.right)
            )
            
            if non_flip_equivalent:
                return True

            return False
            
# Test the solutions
assert Solution().flipEquiv(
    BinaryTreeNode.from_array([1,2,3,4,5,6,None,None,None,7,8]),
    BinaryTreeNode.from_array([1,3,2,None,6,4,5,None,None,None,None,8,7])
)

assert Solution().flipEquiv(
    BinaryTreeNode.from_array([]),
    BinaryTreeNode.from_array([])
)

assert Solution().flipEquiv(
    BinaryTreeNode.from_array([]),
    BinaryTreeNode.from_array([1])
) == False
```

</div>

<div id="013515b9-e5a6-42d8-8f6f-ad0f043405ea" class="cell markdown">

# 51.

Date: 30th Dec 2023<br> Medium Leetcode: flatten-nested-list-iterator
<br> Solution:
<https://leetcode.com/problems/flatten-nested-list-iterator/submissions/1132269388/>

</div>

<div id="f23ffd20-982f-458f-8a73-7294d28ef67c" class="cell code"
execution_count="57">

``` python
class NestedInteger:
    def __init__(self, val):
        self.value = val
    
    def isInteger(self) -> bool:
        return isinstance(self.value, int)
        
    def getInteger(self) -> int:
        return self.value

    def getList(self):
        return self.value

class NestedIterator:
    def __init__(self, nestedList: [NestedInteger]):
        self.flattened = NestedIterator.flatten(nestedList)
        self.idx = 0
        self.length = len(self.flattened)

    def flatten(nested: [NestedInteger]):
        result = []
        for n in nested:
            if n.isInteger():
                result.append(n.getInteger())
            else:
                result.extend(NestedIterator.flatten(n.getList()))
        return result
    
    def next(self) -> int:
        self.idx += 1
        return self.flattened[self.idx - 1]
        
    def hasNext(self) -> bool:
        return self.idx < self.length
```

</div>

<div id="a74cea2a-9ac4-41e7-b039-63d29fc11bb4" class="cell code"
execution_count="58">

``` python
# Test the solution
NI = NestedInteger
_ = []
temp = NestedIterator([
    NI(1), 
    NI(2), 
    NI([
        NI(3), 
        NI([
            NI([
                NI(4)
            ]),
            NI(5)
        ]), 
        NI(6)
    ]),
    NI([
        NI(7),
        NI(8)
    ])
])
while temp.hasNext(): 
    _.append(temp.next())
_ == list(range(1, 9))
```

<div class="output execute_result" execution_count="58">

    True

</div>

</div>

<div id="3844faf6-cfa0-401a-89b1-d7488d7d610e" class="cell markdown">

# 52.

Date: 30th Dec 2023<br> Easy Leetcode: excel-sheet-column-number<br>
Solution:
<https://leetcode.com/problems/excel-sheet-column-number/submissions/1132277905/>

</div>

<div id="dcd8dd5b-c276-494b-9dc8-8f8840987f84" class="cell code"
execution_count="59">

``` python
class Solution:
    def titleToNumber(self, columnTitle: str) -> int:
        chars = list(columnTitle)[::-1]
        res = 0
        for i, ch in enumerate(chars):
            res += (26 ** i) * (ord(ch) - ord("A") + 1)

        return res

# Test the solution
assert Solution().titleToNumber("A") == 1
assert Solution().titleToNumber("AB") == 28
assert Solution().titleToNumber("ZY") == 701
assert Solution().titleToNumber("FXSHRXW") == 2147483647
```

</div>

<div id="9842302f-c629-405d-b4cb-f0fab9a27dc6" class="cell markdown">

# 53.

Date: 30th Dec 2023<br> Easy Leetcode:
cells-in-a-range-on-an-excel-sheet<br> Solution:
<https://leetcode.com/problems/cells-in-a-range-on-an-excel-sheet/submissions/1132284128/>

</div>

<div id="109b95c0-4a4f-49e3-a08a-4bc984ee4cd8" class="cell code"
execution_count="60">

``` python
class Solution:
    def cellsInRange(self, s: str) -> List[str]:
        # Max range: A1:Z9
        start_col, start_row, _, end_col, end_row = list(s)
        result = []
        for ch in range(ord(start_col), ord(end_col) + 1):
            for n in range(int(start_row), int(end_row) + 1):
                result.append(f"{chr(ch)}{n}")
        return result

# Test the solution
Solution().cellsInRange("A2:B5")
```

<div class="output execute_result" execution_count="60">

    ['A2', 'A3', 'A4', 'A5', 'B2', 'B3', 'B4', 'B5']

</div>

</div>

<div id="83e72c1b-93e2-489e-8710-58121c766c8b" class="cell markdown">

# 54.

Date: 30th Dec 2023<br> Easy Leetcode: arranging-coins<br> Solution:
<https://leetcode.com/problems/arranging-coins/submissions/1132307390/>

</div>

<div id="310a50ac-ad7d-4a94-a38e-ff0197658139" class="cell code"
execution_count="61">

``` python
class Solution:
    def arrangeCoins(self, n: int) -> int:
        nearest_k = int(math.sqrt(2 * n))
        expected_n = (nearest_k * (nearest_k + 1)) / 2
        if n > expected_n:
            return nearest_k
        if n == expected_n:
            return nearest_k
        else:
            return nearest_k - 1

# Test the solutions
assert Solution().arrangeCoins(15) == 5
assert Solution().arrangeCoins(100) == 13
assert Solution().arrangeCoins(15) == 5
```

</div>

<div id="be90f2d4-1812-4163-a888-122f4edf4894" class="cell markdown">

# 55.

Date: 30th Dec 2023<br> Easy Leetcode: valid-anagram<br> Solution:
<https://leetcode.com/problems/valid-anagram/submissions/1132334781/>

</div>

<div id="601b0118-a5cd-42d6-b190-8e083e090e93" class="cell code"
execution_count="62">

``` python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        freq = [0 for i in range(26)]

        for ch in s:
            freq[ord(ch) - ord('a')] += 1
        
        for ch in t:
            freq[ord(ch) - ord('a')] -= 1

        return all(freq[i] == 0 for i in range(26))

# Testing the solution
assert Solution().isAnagram("anagram", "nagaram")
```

</div>

<div id="858cad94-4ab3-4408-a509-648dfe535c66" class="cell markdown">

# 56.

Date: 31th Dec 2023<br> Easy Leetcode: count-complete-tree-nodes<br>
Solution:
<https://leetcode.com/problems/count-complete-tree-nodes/submissions/1132678858/>

</div>

<div id="c897b6c5-c650-475a-a99b-5ac094926993" class="cell code"
execution_count="63">

``` python
class Solution:
    def pathAvailable(root: BinaryTreeNode, pathStr: str) -> bool:
        'Given a path string such as 010, translates it to left, right, left and checks if it is available' 
        curr = root
        for direction in pathStr:
            if direction == '0':
                curr = curr.left
            else:
                curr = curr.right

        return curr is not None

    def getStringPath(n: int, maxLength: int) -> str:
        'Translate the index to binary tree path given a max length of paths'
        pathStr = bin(n)[2:].zfill(maxLength)
        return pathStr
    
    def countNodes(self, root: BinaryTreeNode) -> int:

        # No nodes, return 0
        if root is None:
            return 0

        # If only 1 node
        if root.left is None and root.right is None:
            return 1

        # Find the height
        height, curr = 0, root
        while curr.left:
            height += 1
            curr = curr.left

        # Nodes till second last depth
        nodes_till_second_last = 2 ** height - 1

        # Max possible nodes in last level
        nodes_possible_in_last = 2 ** height

        # Perform binary search to find the pt till which the last level has been filled
        # imagine height = 2, last level has the following indices that could be filled [_, _, _, _, _, _, _, _] 2 ^ (height + 1) = 8
        # We can simply perform binary search to find the point uptil which the elements have been filled
        # Translation between these indices and actual tree can be a simple binary to decimal conversion
        # For eg: [1, 1, 1, 0, 0, 0, 0, 0] (index = 2) = bin(2) = '010' (left, right, left)
        low = 0
        high = nodes_possible_in_last - 1
        while low <= high:
            mid = int((low + high) / 2)
            currPathStr = Solution.getStringPath(mid, height)
            nextPathStr = Solution.getStringPath(mid + 1, height)
            if Solution.pathAvailable(root, currPathStr):
                if mid + 1 <= nodes_possible_in_last - 1 and not Solution.pathAvailable(root, nextPathStr):
                    break
                else:
                    low = mid + 1
            else:
                high = mid - 1

        return nodes_till_second_last + mid + 1

# Test the solution
for _ in range(0, 100):
    assert Solution().countNodes(BinaryTreeNode.from_array(list(range(_)))) == _
```

</div>

<div id="2bfd4ba3-a430-4d25-bb61-c25e050fa01c" class="cell markdown">

# 57.

Date: 31th Dec 2023<br> Medium Leetcode: factorial-trailing-zeroes<br>
Solution:
<https://leetcode.com/problems/factorial-trailing-zeroes/submissions/1132706071/>

</div>

<div id="3e6bc355-155d-4980-9171-4fa9d95a471b" class="cell code"
execution_count="64">

``` python
class Solution:
    @functools.cache
    def factorial(n: int):
        if n <= 2:
            return n
        return n * Solution.factorial(n - 1)
        
    def trailingZeroes(self, n: int) -> int:
        # return the no of 5's available since 5 * 2 gives one 0
        # Even though both 5 and 2 are imp, 5 is available in lesser 
        # qty so just counting 5s should be sufficient
        if n == 0:
            return 0
            
        result = n // 5
        if result >= 5:
            result = result + self.trailingZeroes(result)
            
        return result

# Testing the solution
for _ in range(1, 101):
    temp = Solution.factorial(_)
    assert re.sub("0+$", lambda x: "*" * len(x.group()), str(temp)).count("*") == Solution().trailingZeroes(_), f"Failed for {_}"
```

</div>

<div id="1a37ad9b-afe1-4702-b08f-91e76095f129" class="cell markdown">

# 58.

Date: 31th Dec 2023<br> Hard Leetcode: merge-k-sorted-lists<br>
Solution:
<https://leetcode.com/problems/merge-k-sorted-lists/submissions/1132736891/>

</div>

<div id="d1875e73-53b1-49b3-b33f-253049e98c62" class="cell code"
execution_count="65">

``` python
class Solution:
    def mergeKLists(self, lists: list[ListNode]):
        # Flatten the nested list
        root = None
        prev = None
        for curr in lists:
            if prev:
                prev.next = curr
            if curr:
                # Set the root to the first valid Node
                if not root:
                    root = curr
                while curr.next:
                    curr = curr.next
                prev = curr

        # Edge case
        if len(lists) == 0:
            return None

        # Sort the linked list (Bubble sort, sorry not very strong with sorting linked lists)
        end = None
        while end != root:
            curr = root
            while curr.next != end:
                if curr.val > curr.next.val:
                    curr.val, curr.next.val = curr.next.val, curr.val
                curr = curr.next
            end = curr

        return root

# Test the solution
assert Solution().mergeKLists([
    None,
    ListNode.to_singly_linked_list([1, 2, 5, 6]),
    ListNode.to_singly_linked_list([1,3,3,9]),
    ListNode.to_singly_linked_list([1,1,1]),
    ListNode.to_singly_linked_list([7,8,9]),
    None
]).to_list() == sorted([1, 2, 5, 6, 1, 3, 3, 9, 1, 1, 1, 7, 8, 9])
```

</div>

<div id="b3cf0617-d8da-46db-8552-e10dfa41326d" class="cell markdown">

# 59.

Date: 31th Dec 2023<br> Easy Leetcode:
largest-substring-between-two-equal-character?<br> Solution:
<https://leetcode.com/problems/largest-substring-between-two-equal-characters/submissions/1133125742>

</div>

<div id="e6af5311-074e-4e34-9352-bc4ee8c892d4" class="cell code"
execution_count="66">

``` python
class Solution:
    def maxLengthBetweenEqualCharacters(self, s: str) -> int:
        """
        aabcdefgadefab - 11
        """
        maximum = -1
        for k, v in collections.Counter(s).items():
            if v >= 2:
                maximum = max(maximum, s.rfind(k) - s.find(k) - 1)
        return maximum

# Testing our solution
assert Solution().maxLengthBetweenEqualCharacters("aabcdefgadefab") == 11
assert Solution().maxLengthBetweenEqualCharacters("cbzxy") == -1
assert Solution().maxLengthBetweenEqualCharacters("abca") == 2
assert Solution().maxLengthBetweenEqualCharacters("aa") == 0
```

</div>

<div id="c3758cea-de02-4245-87a6-7f8aa1230ac1" class="cell markdown">

# 60.

Date: 31th Dec 2023<br> Easy Leetcode: three-consecutive-odds<br>
Solution:
<https://leetcode.com/problems/three-consecutive-odds/submissions/1133130405/>

</div>

<div id="d1044a78-eb59-4dd3-8efb-8000c0896c29" class="cell code"
execution_count="67">

``` python
class Solution:
    def threeConsecutiveOdds(self, arr: List[int]) -> bool:
        if len(arr) < 3:
            return False
            
        for i in range(0, len(arr) - 2):
            if arr[i] % 2 and arr[i + 1] % 2 and arr[i + 2] % 2:
                return True
        else:
            return False

# Testing our solution
assert Solution().threeConsecutiveOdds([1]) == False
assert Solution().threeConsecutiveOdds([1,2]) == False
assert Solution().threeConsecutiveOdds([1,2,3]) == False
assert Solution().threeConsecutiveOdds([1,1,1]) == True
```

</div>

<div id="227cea99-5804-4627-974f-3f8ba27110ff" class="cell markdown">

# 61.

Date: 1st Jan 2024<br> Medium Leetcode: valid-sudoku<br> Solution:
<https://leetcode.com/problems/valid-sudoku/submissions/1133324344/>

</div>

<div id="2e19019f-8955-4aa3-b348-833b5afa9bff" class="cell code"
execution_count="68">

``` python
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:

        # Save all the cells for validations 
        # defaultdict is better than dict comprehensions
        columns = collections.defaultdict(set)
        rows = collections.defaultdict(set)
        grids = collections.defaultdict(set)

        for i in range(9):
            for j in range(9):
                cell = board[i][j]
                if cell != '.':

                    columnIdx = j
                    rowIdx = i
                    gridIdx = (3 * (j // 3)) + (i // 3)

                    if cell in columns[columnIdx] or cell in rows[rowIdx] or cell in grids[gridIdx]:
                        return False
                    else:
                        columns[columnIdx].add(cell)
                        rows[rowIdx].add(cell)
                        grids[gridIdx].add(cell)
        
        return True

# Test the solution
Solution().isValidSudoku(
    [
        ["5","3",".",".","7",".",".",".","."],
        ["6",".",".","1","9","5",".",".","."],
        [".","9","8",".",".",".",".","6","."],
        ["8",".",".",".","6",".",".",".","3"],
        ["4",".",".","8",".","3",".",".","1"],
        ["7",".",".",".","2",".",".",".","6"],
        [".","6",".",".",".",".","2","8","."],
        [".",".",".","4","1","9",".",".","5"],
        [".",".",".",".","8",".",".","7","9"]
    ]
)
```

<div class="output execute_result" execution_count="68">

    True

</div>

</div>

<div id="04f48075-f685-4c00-877f-7dce510423e8" class="cell markdown">

# 62.

Date: 1st Jan 2024<br> Easy Leetcode: linked-list-cycle<br> Solution:
<https://leetcode.com/problems/linked-list-cycle/submissions/1133437430/>

</div>

<div id="406cacc9-aa3b-4518-9704-b5761674e859" class="cell code"
execution_count="69">

``` python
class Solution:
    def hasCycle(self, head: ListNode) -> bool:

        if not head or not head.next:
            return False

        slow = fast = head 
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if fast == slow:
                return True
        else:
            return False

# Test the solution
temp = [ListNode(val=1), ListNode(val=2)]
temp[0].next = temp[1]
temp[1].next = temp[0]
temp = temp[0]
assert Solution().hasCycle(temp)

temp = [ListNode(val=1), ListNode(val=2), ListNode(val=3)]
temp[0].next = temp[1]
temp[1].next = temp[2]
temp[2].next = temp[1]
temp = temp[0]
assert Solution().hasCycle(temp)

temp = [ListNode(val=1), ListNode(val=2), ListNode(val=3)]
temp[0].next = temp[1]
temp[1].next = temp[2]
temp = temp[0]
assert Solution().hasCycle(temp) == False
```

</div>

<div id="eef1c544-83df-499c-8a67-451484359715" class="cell markdown">

# 63.

Date: 1st Jan 2024<br> Easy Leetcode: reverse-linked-list<br> Solution:
<https://leetcode.com/problems/reverse-linked-list/submissions/1133465358/>

</div>

<div id="3ba85354-39e6-42f1-af08-4c7107fb144e" class="cell code"
execution_count="70">

``` python
class Solution:
    
    root = None
    
    def reverseListRecurse(self, head: ListNode):
        def reverse(curr):
            if curr.next is None:
                self.root = curr 
                return curr

            next_node = reverse(curr.next)
            next_node.next = curr
            return curr
        
        if head is None or head.next is None:
            return head
        else:
            tail = reverse(head)
            tail.next = None
            return self.root

    def reverseListIterate(self, head):
        prev, curr = None, head
        while curr:
            curr.next, curr, prev = prev, curr.next, curr
        return prev

# Test the solution
temp = [1, 2, 3, 4, 5]
assert Solution().reverseListIterate(ListNode.to_singly_linked_list(temp)).to_list() == Solution().reverseListRecurse(ListNode.to_singly_linked_list(temp)).to_list()
temp = [1]
assert Solution().reverseListIterate(ListNode.to_singly_linked_list(temp)).to_list() == Solution().reverseListRecurse(ListNode.to_singly_linked_list(temp)).to_list()
temp = [1, 2]
assert Solution().reverseListIterate(ListNode.to_singly_linked_list(temp)).to_list() == Solution().reverseListRecurse(ListNode.to_singly_linked_list(temp)).to_list()
```

</div>

<div id="2a4808f2-7e65-49e3-8e3c-f96cff69d803" class="cell markdown">

# 64.

Date: 1st Jan 2024<br> Easy Leetcode: remove-linked-list-elements<br>
Solution:
<https://leetcode.com/problems/remove-linked-list-elements/submissions/1133510023/>

</div>

<div id="ad59a694-3857-4b3d-8161-a018935927b3" class="cell code"
execution_count="71">

``` python
class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:
        prev, curr = None, head
        while curr:
            
            # Delete the node
            if curr.val == val:
                if prev:
                    prev.next = prev.next.next
                    curr.next = None
                    curr = prev.next
                else:
                    head = head.next
                    curr.next = None
                    curr = head

            # Skip the element
            else:
                prev, curr = curr, curr.next

        return head

# Test the solution
assert Solution().removeElements(ListNode.to_singly_linked_list([1,1,2,2,3,4]), 1).to_list() == [2, 2, 3, 4]
assert Solution().removeElements(ListNode.to_singly_linked_list([1,1,1,1]), 1) is None
```

</div>

<div id="e5405943-1fb1-4857-976c-254e9f871215" class="cell markdown">

# 65.

Date: 1st Jan 2024<br> Medium Leetcode:
flatten-binary-tree-to-linked-list<br> Solution:
<https://leetcode.com/problems/flatten-binary-tree-to-linked-list/submissions/1133605449/>

</div>

<div id="6ed5c870-530c-43b9-b62f-7e23b97ed187" class="cell code"
execution_count="72">

``` python
class Solution:
    def DFS1(root):
        if not root:
            return []

        return [root] + Solution.DFS1(root.left) + Solution.DFS1(root.right)

    def flatten1(self, root: BinaryTreeNode) -> None:
        """
        Do not return anything, modify root in-place instead.
        pre-order traversal: root, left, right
        """  

        # Edge case
        if root is None or (root.left is None and root.right is None):
            return root

        flattened = Solution.DFS1(root)
        prev = None
        for node in flattened[::-1]:
            node.left = None
            node.right = prev
            prev = node
            
        return flattened[0]
        
    def DFS2(self, root: BinaryTreeNode) -> None:
        if not root.left and not root.right:
            return root, root
            
        else:

            # Only right subtree exists
            if not root.left:
                right_begin, right_end = self.DFS2(root.right)
                root.right = right_begin
                end = right_end

            # Only left subtree exists
            elif not root.right:
                left_begin, left_end = self.DFS2(root.left)
                root.right = left_begin
                end = left_end

            # Both subtrees exists, we need to link them both
            else:
                right_begin, right_end = self.DFS2(root.right)
                left_begin, left_end = self.DFS2(root.left)
                root.right = left_begin
                left_end.right = right_begin
                end = right_end
            
            root.left = None 
            return root, end
        
    def flatten2(self, root: BinaryTreeNode) -> None:
        
        # Edge case
        if root is None or (root.left is None and root.right is None):
            return root
            
        return self.DFS2(root)[0]

    # https://www.youtube.com/watch?v=sWf7k1x9XR4
    prev = None
    def flatten(self, root: BinaryTreeNode) -> None:
        if not root:
            return

        # change the traversal order to right, left and root (inverse of pre order traversal)
        self.flatten(root.right)
        self.flatten(root.left)
        root.right = self.prev
        root.left = None
        self.prev = root
        return root
    
# Test the solution
temp = Solution().flatten(BinaryTreeNode.from_array([1,2,5,3,4,None,6])).to_list()
assert all(map(lambda x: x[0] == x[1], zip(temp, [1,None,2,None,3,None,4,None,5,None,6])))
```

</div>

<div id="a467034f-4a5d-4799-9ecb-5d370d2eb17b" class="cell markdown">

# 66.

Date: 1st Jan 2024<br> Medium Leetcode: odd-even-linked-list<br>
Solution:
<https://leetcode.com/problems/odd-even-linked-list/submissions/1133644559/>

</div>

<div id="de12904b-f474-4082-b621-2877766b00f3" class="cell code"
execution_count="73">

``` python
class Solution:
    def oddEvenList(self, head: ListNode) -> ListNode:

        if not head or not head.next:
            return head

        oddHead = head
        evenHead = head.next

        even, odd = None, head

        while odd.next and odd.next.next:
            if even:
                even.next = odd.next
            even = odd.next
            odd.next = odd.next.next
            odd = odd.next

        if odd.next:
            if even:
                even.next = odd.next
            even = odd.next

        even.next = None
        odd.next = evenHead
        return oddHead

# Test the solution
assert Solution().oddEvenList(ListNode.to_singly_linked_list([1])).to_list() == [1]
assert Solution().oddEvenList(ListNode.to_singly_linked_list([1,2])).to_list() == [1,2]
assert Solution().oddEvenList(ListNode.to_singly_linked_list([1,2,3])).to_list() == [1,3,2]
assert Solution().oddEvenList(ListNode.to_singly_linked_list([1,2,3,4])).to_list() == [1,3,2,4]
assert Solution().oddEvenList(ListNode.to_singly_linked_list([1,2,3,4,5])).to_list() == [1,3,5,2,4]
assert Solution().oddEvenList(ListNode.to_singly_linked_list([2,1,3,5,6,4])).to_list() == [2,3,6,1,5,4]
```

</div>

<div id="f294d6f9-d1ac-4033-84cb-bbb1f48e92f3" class="cell markdown">

# 67.

Date: 1st Jan 2024<br> Medium Leetcode: integer-break<br> Solution:
<https://leetcode.com/problems/integer-break/submissions/1133696721/>

</div>

<div id="f681c77b-1972-4e0e-bcbc-f18d77019d8b" class="cell code"
execution_count="74">

``` python
class Solution:

    def maxProduct(n, k):
        minimum = n // k
        remainder = n - (minimum * k)
    
        # Equally split remainder between the splits
        extra_each = math.ceil(remainder / k)
    
        result = 1
        for i in range(k - 1):
            if remainder > 0:
                result *= minimum + extra_each
                remainder -= extra_each
            else:
                result *= minimum
    
        result *= minimum + remainder
        return result

    def integerBreak(self, n: int) -> int:
        result = 0
        for k in range(2, n + 1):
            result = max(Solution.maxProduct(n, k), result)
        return result
    
    def generatePossibleCombinations(self, n: int) -> int:
        '''
        5:  ans = 6
        5 - [1, 1, 1, 1, 1]
        4 - [2, 1, 1, 1]
        3 - [2, 2, 1] or [3, 1, 1]
        2* - [4, 1] or [3, 2]

        6: ans = 9
        6 - [1, 1, 1, 1, 1, 1]
        5 - [2, 1, 1, 1, 1]
        4 - [2, 2, 1, 1] or [3, 1, 1, 1]
        3 - [4, 1, 1] or [3, 2, 1] or [2, 2, 2]
        2* - [5, 1] or [4, 2] or [3, 3]
        '''

        if n == 0:
            return []
        elif n == 1:
            return [[1]]
        else:
            result = []
            for i in range(1, n):
                if i <= n:
                    for comb in self.integerBreak(n - i):
                        result.append([i, *comb])
                else:
                    break
            return result

# Test the solution
assert Solution().integerBreak(2) == 1
assert Solution().integerBreak(10) == 36
assert Solution().integerBreak(5) == 6
assert Solution().integerBreak(6) == 9
```

</div>

<div id="99dd5272-9538-4ad0-a22d-63738faa8ec2" class="cell markdown">

# 68.

Date: 2nd Jan 2024<br> Medium Leetcode:
find-first-and-last-position-of-element-in-sorted-array<br> Solution:
<https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/submissions/1134183074/>

</div>

<div id="806da48e-fdf6-4a60-8e3f-741c3bc8dd63" class="cell code"
execution_count="75">

``` python
class Solution:
    def searchRange(self, nums: list[int], target: int) -> list[int]:
        # Find the first position
        low, high = 0, len(nums) - 1
        while low <= high:
            mid = (low + high) // 2
            if nums[mid] == target and (mid == 0 or nums[mid - 1] < target):
                start = mid
                break
            elif nums[mid] >= target:
                high = mid - 1
            else:
                low = mid + 1
        else:
            start = -1

        # Find the last position
        low, high = 0, len(nums) - 1
        while low <= high:
            mid = (low + high) // 2
            if nums[mid] == target and (mid == len(nums) - 1 or nums[mid + 1] > target):
                end = mid
                break
            elif nums[mid] > target:
                high = mid - 1
            else:
                low = mid + 1
        else:
            end = -1

        return [start, end]

# Testing the solution
assert Solution().searchRange([0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2], 1) == [3, 12]
assert Solution().searchRange([0, 0, 0, 1, 1, 1, 1], 1) == [3, 6]
```

</div>

<div id="c5db993a-7eb2-4ee8-a5b3-bd2a247d8f9f" class="cell markdown">

# 69.

Date: 2nd Jan 2024<br> Medium Leetcode:
convert-an-array-into-a-2d-array-with-conditions<br> Solution:
<https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/submissions/1134191522>

</div>

<div id="a4e47af3-db52-4886-b1ec-0a8e33ccc0ab" class="cell code"
execution_count="76">

``` python
class Solution:
    def findMatrix(self, nums: List[int]) -> List[List[int]]:
        positions = collections.defaultdict(lambda: -1)
        result = [[]]
        for n in nums:
            currIndex = positions[n] + 1
            positions[n] = currIndex
            if len(result) == currIndex:
                result.append([])
            result[positions[n]].append(n)
        return result

# Testing the solution
print(Solution().findMatrix([1,3,4,1,2,3,1]))
print(Solution().findMatrix([3,4,1,2,3,1]))
```

<div class="output stream stdout">

    [[1, 3, 4, 2], [1, 3], [1]]
    [[3, 4, 1, 2], [3, 1]]

</div>

</div>

<div id="5913ceb3-f545-43c9-afdc-129da0e35d9e" class="cell markdown">

# 70.

Date: 2nd Jan 2024<br> Easy Leetcode: binary-tree-preorder-traversal
<br> Solution:
<https://leetcode.com/problems/binary-tree-preorder-traversal/submissions/1134217061/>

</div>

<div id="d1e7a338-a8e5-4536-9c82-ec2d0a84a4af" class="cell code"
execution_count="77">

``` python
class Solution:
    def __init__(self):
        self.result = []
        
    def DFS(self, root):

        if not root:
            return

        self.result.append(root.val)
        self.DFS(root.left)
        self.DFS(root.right)

    def preorderTraversal(self, root: BinaryTreeNode) -> List[int]:
        self.DFS(root)
        return self.result

# Test the solution
assert Solution().preorderTraversal(BinaryTreeNode.from_array([1,None,2,3])) == [1, 2, 3]
assert Solution().preorderTraversal(BinaryTreeNode.from_array([1])) == [1]
```

</div>

<div id="32a5aeb8-1d3e-4ea3-9cd6-8ccb5ecf06bc" class="cell markdown">

# 71.

Date: 2nd Jan 2024<br> Medium Leetcode: Coin Change - II<br> Solution:
<https://leetcode.com/problems/coin-change-ii/submissions/1134349857/>

</div>

<div id="773cc3f7-a7f5-4b34-86a9-273f733301c3" class="cell code"
execution_count="78">

``` python
class Solution:
    def get_possibilities(self, amount: int, coins: List[int], memo: dict[int, list[list[int]]] = dict()) -> int:
        if amount in memo:
            results = memo[amount]
            
        elif amount == 0:
            results = [[]]
            
        else:
            results = []
            for coin in coins:
                if coin <= amount:
                    for result in self.get_possibilities(amount - coin, coins):
                        if len(result) == 0 or result[-1] <= coin:
                            results.append(result + [coin])

        memo[amount] = results
        return results

    def change(self, amount: int, coins: List[int]): 
        @functools.cache
        def solve(idx, amount):
            if amount == 0:
                return 1    
            elif amount < 0 or idx >= len(coins):
                return 0
            else:
                return solve(idx, amount - coins[idx]) + solve(idx + 1, amount)
        
        return solve(0, amount)

# Testing the solution
temp = Solution().get_possibilities(50, [1, 2, 3])
assert len(temp), Solution().change(50, [1, 2, 3])
```

</div>

<div id="c15c6d4a-691a-42b2-a0a0-958d3e86ca9a" class="cell markdown">

# 72.

Date: 3rd Jan 2024<br> Easy Leetcode: n-th-tribonacci-number<br>
Solution:
<https://leetcode.com/problems/n-th-tribonacci-number/submissions/1135120293/>

</div>

<div id="d19c06f6-98c6-49ca-a243-fc3b13833ffd" class="cell code"
execution_count="79">

``` python
class Solution:
    @functools.cache
    def tribonacci_(self, n: int) -> int:
        if n == 0:
            return 0
        elif n <= 2:
            return 1
        else:
            return self.tribonacci(n - 1) +  self.tribonacci(n - 2) + self.tribonacci(n - 3)

    def tribonacci(self, n: int) -> int:
        minus1, minus2, minus3 = 0, 1, 1

        if n == 0:
            return 0
        elif n <= 2:
            return 1
        else:
            for _ in range(n - 2):
                res = minus1 + minus2 + minus3
                minus1, minus2, minus3 = minus2, minus3, res
            return res

# Testing the solution
assert Solution().tribonacci(10) == Solution().tribonacci_(10)
assert Solution().tribonacci(11) == Solution().tribonacci_(11)
assert Solution().tribonacci(1) == Solution().tribonacci_(1)
```

</div>

<div id="bae9642f-d916-476e-888a-bf532cd77294" class="cell markdown">

## 73.

Date: 3rd Jan 2024<br> Medium Leetcode:
number-of-laser-beams-in-a-bank<br> Solution:
<https://leetcode.com/problems/number-of-laser-beams-in-a-bank/submissions/1135129178>

</div>

<div id="ff34ea31-25ee-4c9a-a187-472a7605262b" class="cell code"
execution_count="80">

``` python
class Solution:
    def numberOfBeams(self, bank: List[str]) -> int:
        prev = 0
        laser_count = 0
        for floor in bank:
            camera_count = floor.count('1')
            if camera_count:
                laser_count += prev * camera_count
                prev = camera_count
        return laser_count

# Testing the solution
assert Solution().numberOfBeams(["011001","000000","010100","001000"]) == 8
assert Solution().numberOfBeams(["000","111","000"]) == 0
```

</div>

<div id="178bce78-77e0-4abc-894d-4ffa4a428f1f" class="cell markdown">

## 74.

Date: 3rd Jan 2024<br> Medium Leetcode: count-sorted-vowel-strings<br>
Solution:
<https://leetcode.com/problems/count-sorted-vowel-strings/submissions/1135202864/>

</div>

<div id="a42756ad-08a2-4b4d-a5cb-2d62c7ef7ff2" class="cell code"
execution_count="81">

``` python
class Solution:
    @functools.cache
    def countVowelStrings(self, n: int, i: int = 0) -> int:
        vowels = ["a", "e", "i", "o", "u"]
        if n == 0:
            return 1
        elif n < 0 or i > 4:
            return 0
        else:
            return self.countVowelStrings(n - 1, i) + self.countVowelStrings(n, i + 1)

# Test the solution
Solution().countVowelStrings(33)
```

<div class="output execute_result" execution_count="81">

    66045

</div>

</div>

<div id="b2b7ab5b-91c4-46b2-a67e-fc68a3329e19" class="cell markdown">

## 75.

Date: 3rd Jan 2024<br> Medium Leetcode: jump-game-ii<br> Solution:
<https://leetcode.com/problems/jump-game-ii/submissions/1135695965/>

</div>

<div id="dcbc8250-f0a0-4c12-8ca4-33ee024cbeed" class="cell code"
execution_count="82">

``` python
class Solution:
    def jump(self, nums: List[int]) -> int:
        for i in range(len(nums) - 1, -1, -1):

            if i == len(nums) - 1:
                nums[i] = 0

            else:
                res = math.inf
                for j in range(1, nums[i] + 1):
                    if i + j < len(nums):
                        res = min(res, 1 + nums[i + j])
                    else:
                        res = 1
                        break
                nums[i] = res

        return nums[0]

# Test the solution
assert Solution().jump([2,3,0,1,4]) == 2
assert Solution().jump([1,2,3]) == 2
assert Solution().jump([3,2,1]) == 1
assert Solution().jump([0]) == 0
```

</div>

<div id="e13588ad-1667-4ceb-90b0-b697aedd1094" class="cell markdown">

## 76.

Date: 3rd Jan 2024<br> Medium Leetcode:
letter-combinations-of-a-phone-number<br> Solution:
<https://leetcode.com/problems/letter-combinations-of-a-phone-number/submissions/1135713597/>

</div>

<div id="6cef31b0-030f-4528-affa-d716bfff169b" class="cell code"
execution_count="83">

``` python
class Solution:

    mapping = {
        "2": "abc",
        "3": "def",
        "4": "ghi",
        "5": "jkl",
        "6": "mno",
        "7": "pqrs",
        "8": "tuv",
        "9": "wxyz",
    }

    def letterCombinations(self, digits: str) -> List[str]:
        if len(digits) == 0:
            return []
        elif len(digits) == 1:
            return list(self.mapping[digits[0]])
        else:
            right_ = self.letterCombinations(digits[1:])
            result = []
            for l in self.mapping[digits[0]]:
                for r in right_:
                    result.append(l + r)
            return result

# Test the solution
print(Solution().letterCombinations("79"))
```

<div class="output stream stdout">

    ['pw', 'px', 'py', 'pz', 'qw', 'qx', 'qy', 'qz', 'rw', 'rx', 'ry', 'rz', 'sw', 'sx', 'sy', 'sz']

</div>

</div>

<div id="aa81a5d9-bdf0-49f9-a986-4e6580f67552" class="cell markdown">

## 77.

Date: 3rd Jan 2024<br> Medium Leetcode: triangle<br> Solution:
<https://leetcode.com/problems/triangle/submissions/1135732715/>

</div>

<div id="5a69507a-6c50-4724-a319-5ec806da8afe" class="cell code"
execution_count="84">

``` python
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        for i in range(len(triangle) - 2, -1, -1):
            for j in range(len(triangle[i])):
                triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1])
                
        return triangle[0][0]

# Testing the solution
assert Solution().minimumTotal([[2],[3,4],[6,5,7],[4,1,8,3]]) == 11
assert Solution().minimumTotal([[-10]]) == -10
assert Solution().minimumTotal([[-1000]]) == -1000
assert Solution().minimumTotal([[0]]) == 0
assert Solution().minimumTotal([[-10],[10,0],[10,20,-10]]) == -20
```

</div>

<div id="b77aca59-95dd-46f8-b02a-2082d9b991f1" class="cell markdown">

## 78.

Date: 4th Jan 2024<br> Medium Leetcode: perfect-squares<br> Solution:
<https://leetcode.com/problems/perfect-squares/submissions/1136120395/>

</div>

<div id="07bcd71e-631f-4bda-9cb3-dec91b83ed80" class="cell code"
execution_count="85">

``` python
class Solution:
    def numSquares(self, n: int) -> int:

        # Time complexity: O(N*M)
        # Space complexity: O(N*M)
        # N - num of perfect squares
        # M - amount

        # Get possible values that can 
        perfect_squares = [_ * _ for _ in range(1, int(math.sqrt(n)) + 1)]

        # Assign a DP Grid
        dp = [[0 for i in range(n + 1)] for j in range(len(perfect_squares))]

        for i, square in enumerate(perfect_squares):
            for amt in range(1, n + 1):
                if i == 0:
                    dp[i][amt] = 1 + dp[i][amt - square]
                elif amt < square:
                    dp[i][amt] = dp[i - 1][amt]
                else:
                    dp[i][amt] = min(dp[i - 1][amt], 1 + dp[i][amt - square])

        return dp[-1][-1]

# Test the solution
assert Solution().numSquares(10000) == 1
assert Solution().numSquares(9999) == 4
assert Solution().numSquares(13) == 2
assert Solution().numSquares(1) == 1
```

</div>

<div id="22107c93-f2ee-4fc9-bf5e-2c694734685f" class="cell markdown">

## 79.

Date: 4th Jan 2024<br> Medium Leetcode:
minimum-number-of-operations-to-make-array-empty<br> Solution:
<https://leetcode.com/problems/minimum-number-of-operations-to-make-array-empty/submissions/1136217904/>

</div>

<div id="2c7587fa-a7cb-41ed-b0ce-09c55535d444" class="cell code"
execution_count="86">

``` python
class Solution:

    @functools.cache
    def minOperationForN(self, n: int) -> int:
        if n == 1:
            return math.inf
        elif n == 2 or n == 3:
            return 1
        else:
            return min(1 + self.minOperationForN(n - 3), 1 + self.minOperationForN(n - 2))

    def minOperations(self, nums: List[int]) -> int:
        '''
        a - 10
        b - 25
        '''
        res = 0
        for freq in list(collections.Counter(nums).values()):
            res += self.minOperationForN(freq)
        return res if res != math.inf else -1

# Test the solution
assert Solution().minOperations([2,1,2,2,3,3]) == -1
assert Solution().minOperations([2,2]) == 1
assert Solution().minOperations([2,3]) == -1
assert Solution().minOperations([2,2,3]) == -1
assert Solution().minOperations([2,2,2]) == 1
assert Solution().minOperations([1,2,3,3]) == -1
assert Solution().minOperations([1,2,3]) == -1
```

</div>

<div id="e7bd49be-a5b7-402a-8e1c-a6f1062ea3d3" class="cell markdown">

## 80.

Date: 4th Jan 2024<br> Medium Leetcode: maximum-product-subarray<br>
Solution:
<https://leetcode.com/problems/maximum-product-subarray/submissions/1136745625/>

</div>

<div id="be9c4c53-e9c0-4da7-b019-925e34885939" class="cell code"
execution_count="87">

``` python
import itertools

class Solution:
    def maxProduct_n2_solution(self, nums: List[int]) -> int:
        n = len(nums)

        # Crucial for passing the TLE test case :(
        total_prod = functools.reduce(lambda x, y: x * y, nums, 1)
        if total_prod > 0:
            return total_prod

        for i in range(n):
            rolling_products = [1 for _ in range(n - i)]
            for j, num in enumerate(nums[i:]):
                rolling_products[j] = (num * rolling_products[j - 1]) if j > 0 else num
            nums[i] = max(rolling_products)

        return max(nums)

    def maxProduct(self, nums: List[int]) -> int:
        # https://www.youtube.com/watch?v=hnswaLJvr6g
        prefix = suffix = 1
        n = len(nums)
        res = -math.inf
        for i in range(len(nums)):
            j = n - i - 1

            prefix *= nums[i]
            suffix *= nums[j]
            
            res = max(res, prefix, suffix)
            
            if prefix == 0:
                prefix = 1
                
            if nums[j] == 0:
                suffix = 1
            
        return res

# Testing the solution
assert Solution().maxProduct([2,3,-2,4]) == 6
assert Solution().maxProduct([-2,0,-1]) == 0
assert Solution().maxProduct([0]) == 0
assert Solution().maxProduct([10]) == 10
assert Solution().maxProduct([-1,-10,0,5,-5]) == 10
assert Solution().maxProduct([-1,-2,-3,0]) == 6
assert Solution().maxProduct([0,2]) == 2
assert Solution().maxProduct([-3,0,1,-2]) == 1
```

</div>

<div id="7d23df28-c75e-40ad-82e1-83b4250b1d84" class="cell markdown">

## 81.

Date: 5th Jan 2024<br> Medium Leetcode:
longest-increasing-subsequence<br> Solution:
<https://leetcode.com/problems/longest-increasing-subsequence/submissions/1137173478>

</div>

<div id="87e073ad-3778-4fcc-b05c-37c4d7616e10" class="cell code"
execution_count="88">

``` python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:

        # Time complexity - O(n^2)
        # Space complexity - On(n)
        
        n = len(nums)
        dp = [1] * n

        for i in range(n - 2, -1, -1):
            curr = nums[i]
            maxLen = 0
            for j in range(i + 1, n):
                if nums[j] > curr:
                    maxLen = max(maxLen, dp[j])
            dp[i] = 1 + maxLen

        return max(dp)

# Test the solution
assert Solution().lengthOfLIS([10,9,2,5,3,7,101,18]) == 4
assert Solution().lengthOfLIS([0,1,0,3,2,3]) == 4
assert Solution().lengthOfLIS([7,7,7,7,7,7,7]) == 1
assert Solution().lengthOfLIS([1]) == 1
assert Solution().lengthOfLIS([2,1,3,1,4,1,5,1,6]) == 5
```

</div>

<div id="0a0dd579-e151-4ac1-8fd7-fee20b0a69e8" class="cell markdown">

## 82.

Date: 5th Jan 2024<br> Medium Leetcode:
count-square-submatrices-with-all-ones<br> Solution:
<https://leetcode.com/problems/count-square-submatrices-with-all-ones/submissions/1137771502/>

</div>

<div id="ce80c239-3db0-4cde-bd13-c3face192507" class="cell code"
execution_count="89">

``` python
class Solution:
    def countSquares(self, matrix: List[List[int]]) -> int:
        res = 0
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if matrix[i][j] != 0:
                    if i == 0 or j == 0:
                        res += 1
                    elif (matrix[i - 1][j] != 0 and matrix[i][j - 1] != 0 and matrix[i - 1][j - 1] != 0):
                        temp = min(matrix[i - 1][j], matrix[i][j - 1], matrix[i - 1][j - 1])
                        matrix[i][j] = temp + 1
                        res += temp + 1
                    else:
                        res += 1

        return res

# Testing the solution
assert Solution().countSquares([[0,1,1],[1,1,1],[1,1,1]]) == 11
assert Solution().countSquares([[1,0,1],[1,1,1],[1,1,1]]) == 10
assert Solution().countSquares([[1,1,0],[1,1,1],[1,1,1]]) == 11
assert Solution().countSquares([[1,1,1],[0,1,1],[1,1,1]]) == 10
assert Solution().countSquares([[1,1,1],[1,0,1],[1,1,1]]) == 8
assert Solution().countSquares([[1,1,1],[1,1,0],[1,1,1]]) == 10
assert Solution().countSquares([[1,1,1],[1,1,1],[0,1,1]]) == 11
assert Solution().countSquares([[1,1,1],[1,1,1],[1,0,1]]) == 10
assert Solution().countSquares([[1,1,1],[1,1,1],[1,1,0]]) == 11
```

</div>

<div id="e258af99-b0d9-43c7-b592-6351d4788975" class="cell markdown">

## 83.

Date: 6th Jan 2024<br> Easy Leetcode:
find-winner-on-a-tic-tac-toe-game<br> Solution:
<https://leetcode.com/problems/find-winner-on-a-tic-tac-toe-game/submissions/1138057652>

</div>

<div id="5facb77a-0c1b-4284-877b-81ffc60582af" class="cell code"
execution_count="90">

``` python
class Solution:
    def tictactoe(self, moves: List[List[int]]) -> str:
        a = dict.fromkeys(['x0', 'x1', 'x2', 'y0', 'y1', 'y2', 'ltr', 'rtl'], 0)
        b = dict.fromkeys(['x0', 'x1', 'x2', 'y0', 'y1', 'y2', 'ltr', 'rtl'], 0)
        rtl = set(((0, 0), (1, 1), (2, 2)))
        ltr = set(((0, 2), (1, 1), (2, 0)))

        for x, y in moves[::2]:

            a[f'x{x}'] += 1

            a[f'y{y}'] += 1

            if (x, y) in rtl:
                a['rtl'] += 1

            if (x, y) in ltr:
                a['ltr'] += 1
            
            if list(a.values()).count(3) >= 1:
                return "A"
        
        for x, y in moves[1::2]:

            b[f'x{x}'] += 1
            
            b[f'y{y}'] += 1

            if (x, y) in rtl:
                b['rtl'] += 1

            if (x, y) in ltr:
                b['ltr'] += 1
            
            if list(b.values()).count(3) >= 1:
                return "B"

        return "Pending" if len(moves) < 9 else "Draw"

# Test the solution
assert Solution().tictactoe([[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]) == "Draw"
assert Solution().tictactoe([[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]) == "B"
assert Solution().tictactoe([[0,0],[2,0],[1,1],[2,1],[2,2]]) == "A"
assert Solution().tictactoe([[0,0]]) == "Pending"
```

</div>

<div id="e84d1de6-dea3-40cd-bd22-4335bbfbea71" class="cell markdown">

## 84.

Date: 6th Jan 2024<br> Easy Leetcode: toeplitz-matrix<br> Solution:
<https://leetcode.com/problems/toeplitz-matrix/submissions/1138065561/>

</div>

<div id="c40274da-3970-486a-b85d-29b3f80b05ce" class="cell code"
execution_count="91">

``` python
class Solution:
    def isToeplitzMatrix_followup_1(self, matrix: List[List[int]]) -> bool:
        for i in range(len(matrix) - 1):
            row_i1 = matrix[i]
            row_i2 = matrix[i + 1]
            if row_i1[:-1] != row_i2[1:]:
                return False
        return True

    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:
        # Time complexity - O(MN), Space complexity - O(1)
        for i in range(len(matrix) - 1): 
            for j in range(len(matrix[0]) - 1):
                if matrix[i][j] != matrix[i + 1][j + 1]:
                    return False
        return True

# Test the solution
assert Solution().isToeplitzMatrix([[1,2,3,4],[5,1,2,3],[9,5,1,2]]) == True
assert Solution().isToeplitzMatrix([[1,2],[2,2]]) == False
assert Solution().isToeplitzMatrix([[0, 1, 2]]) == True
assert Solution().isToeplitzMatrix([[0]]) == True
```

</div>

<div id="4550f943-7376-47ed-bc61-0fc4232232b4" class="cell markdown">

## 85.

Date: 6th Jan 2024<br> Easy Leetcode: degree-of-an-array<br> Solution:
<https://leetcode.com/problems/degree-of-an-array/submissions/1138073203>

</div>

<div id="c1e10ce9-d8e5-4cc1-90b3-98b22a2a697b" class="cell code"
execution_count="92">

``` python
class Solution:
    def findShortestSubArray(self, nums: List[int]) -> int:

        # Append all the indices for each number into a dictionary
        indices = collections.defaultdict(list)
        for i, n in enumerate(nums):
            index = indices[n]
            index.append(i)
            indices[n] = index

        # Find the maxlen of indices - there can be more than 1
        maxLen = len(max(indices.values(), key=len))

        # Max Idx - Min idx would give the contingous block for that number
        res = math.inf
        for index in indices.values():
            if len(index) == maxLen:
                res = min(res, index[-1] - index[0] + 1)

        return res

# Test the solution
assert Solution().findShortestSubArray([1,2,2,3,1]) == 2
assert Solution().findShortestSubArray([1,2,2,3,1,4,2]) == 6
assert Solution().findShortestSubArray([0]) == 1
assert Solution().findShortestSubArray([1,1]) == 2
assert Solution().findShortestSubArray([1,1,1]) == 3
assert Solution().findShortestSubArray([1,0,1]) == 3
```

</div>

<div id="a11f6075-c0e8-4291-b8ad-36b8b72cdabf" class="cell markdown">

## 86.

Date: 6th Jan 2024<br> Medium Leetcode:
insert-into-a-binary-search-tree<br> Solution:
<https://leetcode.com/problems/insert-into-a-binary-search-tree/submissions/1138081682>

</div>

<div id="00c2c8cc-a93a-44e5-a599-ed003bb87e98" class="cell code"
execution_count="93">

``` python
class Solution:
    def insertIntoBST(self, root: BinaryTreeNode, val: int) -> BinaryTreeNode:

        if root is None:
            return BinaryTreeNode(val) 
        else:
            if root.val > val:
                root.left = self.insertIntoBST(root.left, val)
            else:
                root.right = self.insertIntoBST(root.right, val)

            return root

# Test the solution
temp = lambda x, y: all(map(lambda _: _[0] == _[1], zip(x, y)))
assert temp(Solution().insertIntoBST(BinaryTreeNode.from_array([4,2,7,1,3]), 5).to_list(), [4,2,7,1,3,5])
assert temp(Solution().insertIntoBST(BinaryTreeNode.from_array([40,20,60,10,30,50,70]), 25).to_list(), [40,20,60,10,30,50,70,None,None,25])
assert temp(Solution().insertIntoBST(BinaryTreeNode.from_array([4,2,7,1,3,None,None,None,None,None,None]), 5).to_list(), [4,2,7,1,3,5])
```

</div>

<div id="13810962-4bb9-4a35-9ad6-475e5906dce8" class="cell markdown">

## 87.

Date: 6th Jan 2024<br> Medium Leetcode: largest-plus-sign<br> Solution:
<https://leetcode.com/problems/largest-plus-sign/submissions/1138223334/>

</div>

<div id="627033ee-bc2f-4854-8a3d-3581210c4964" class="cell code"
execution_count="94">

``` python
class Solution:
    def maxPossibleExpansion(i, j, n) -> int:
        'How much a cell can expand outwards considering the bounds of the grid'
        return min(i - 0, j - 0, n - i - 1, n - j - 1) + 1
    
    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:
        '''
        Time complexity - O(N*2)
        Implementation can be improved instead of having 5 N^2 loops, as far as the overall
        complexity is concerned this is still O(N^2)
        '''
        
        # Assign a grid to keep track of cell proximity to mines
        grid = [[math.inf for i in range(n)] for j in range(n)]

        # Convert to hashset for O(1) lookup times
        mines_hashset = set()
        for x, y in mines:
            mines_hashset.add((x, y))

        # Traverse top to bottom
        for i in range(n):
            prev = math.inf
            for j in range(n):
                i_, j_ = i, j
                if (j_, i_) in mines_hashset:
                    prev = -1

                prev += 1
                grid[j_][i_] = min(grid[j_][i_], prev)
            
        # Traverse bottom to top
        for i in range(n):
            prev = math.inf
            for j in range(n):
                i_, j_ = n - i - 1, n - j - 1
                if (j_, i_) in mines_hashset:
                    prev = -1
                    
                prev += 1
                grid[j_][i_] = min(grid[j_][i_], prev)
                
        # Traverse left to right
        for i in range(n):
            prev = math.inf
            for j in range(n):
                i_, j_ = i, j
                if (i_, j_) in mines_hashset:
                    prev = -1
                    
                prev += 1
                grid[i_][j_] = min(grid[i_][j_], prev)
                
        # Traverse right to left
        for i in range(n):
            prev = math.inf
            for j in range(n):
                i_, j_ = n - i - 1, n - j - 1
                if (i_, j_) in mines_hashset:
                    prev = -1
                    
                prev += 1
                grid[i_][j_] = min(grid[i_][j_], prev)

        # Save the grid to self, incase we wish to see the proximity grid
        self.grid = grid

        # Iterate through grid and find the max length cross
        maxLen = 0
        for i in range(1, n - 1):
            for j in range(1, n - 1):
                mine_proximity = grid[i][j]
                max_possibile_expansion = Solution.maxPossibleExpansion(i, j, n)
                maxLen = max(maxLen, min(max_possibile_expansion, mine_proximity))
                
        return maxLen if maxLen else 0

    def showPossibleExpansions(n: int, k: int = 5):
        for i in range(n):
            for j in range(n):
                val = Solution.maxPossibleExpansion(i, j, n)
                print(str(val).ljust(k), end=' ')
            print()
    
    def showMineProximityGrid(self, raw=False, k: int = 5):
        for _ in self.grid:
            for __ in _:
                val = __ if not raw else 'X' if (__ == 0) else '0'
                print(str(val).ljust(k), end=' ')
            print()

# Test the solution
temp = Solution()
print(f"Max Cross Length: {temp.orderOfLargestPlusSign(4, [[1,0],[3,3]])}\n")
temp.showMineProximityGrid(raw=True)
```

<div class="output stream stdout">

    Max Cross Length: 2

    0     0     0     0     
    X     0     0     0     
    0     0     0     0     
    0     0     0     X     

</div>

</div>

<div id="c5d9b12a-3d0a-4783-a6e9-998545f20a8d" class="cell markdown">

## 88.

Date: 6th Jan 2024<br> Medium Leetcode: domino-and-tromino-tiling<br>
Solution:
<https://leetcode.com/problems/domino-and-tromino-tiling/submissions/1138501309/>

</div>

<div id="e3775b2d-32c9-4581-adcd-87159ca2a8b1" class="cell code"
execution_count="95">

``` python
class Solution:
    
    MODULO = 10 ** 9 + 7
    
    @functools.cache
    def numTilings_(self, n: int) -> int:
        # Pattern found out after a little bit of cheating - printed op 
        # of all n <= 8 and found the pattern
        # A(i) = 2 * A(i - 1) + A(i - 3)
        if n == 1 or n == 2:
            return n
        elif n == 3:
            return 5
        else:
            result = 2 * self.numTilings(n - 1) + self.numTilings(n - 3)
            return result % (Solution.MODULO)

    def numTilings(self, n: int) -> int:
        cache = [1, 2, 5]
        while n - 3 > 0:
            cache.append(2 * cache[2] + cache[0])
            cache.pop(0)
            n -= 1
        return cache[n - 1] % (Solution.MODULO)

# Test the solution
assert Solution().numTilings(4) == 11
assert Solution().numTilings(5) == 24
assert Solution().numTilings(6) == 53
assert Solution().numTilings(7) == 117
```

</div>

<div id="4ae6b604-c6c3-4a6e-9b41-9f010be3a150" class="cell markdown">

## 89.

Date: 6th Jan 2024<br> Medium Leetcode: delete-node-in-a-bst<br>
Solution:
<https://leetcode.com/problems/delete-node-in-a-bst/submissions/1138704919/>

</div>

<div id="88dfd9cc-a09d-4928-9242-1676da3bf826" class="cell code"
execution_count="96">

``` python
class Solution:
    def deleteNode(self, root: BinaryTreeNode, key: int) -> BinaryTreeNode:

        # Edge case
        if not root:
            return None

        if key == root.val:
            if root.right is None and root.left is None:
                return None

            elif root.right is None and root.left is not None:
                return root.left

            elif root.left is None and root.right is not None:
                return root.right

            # Both are not null, find max in left subtree or  min in right subtree, 
            # copy it and delete the node (would be reduced to case 1 or case 2)
            else: 
                # Find min in right sub
                prev = root
                curr = prev.right
                while curr.left:
                    prev, curr = curr, curr.left

                # Copy the next predecessor
                root.val = curr.val
            
                # Delete the node and update the prev node's pointer
                if prev.left == curr:
                   prev.left = self.deleteNode(curr, curr.val)
                else:
                    prev.right = self.deleteNode(curr, curr.val)

        if key < root.val:
            root.left = self.deleteNode(root.left, key)
            return root
        else:
            root.right = self.deleteNode(root.right, key)
            return root

# Test the solution
temp = lambda x, y: all(map(lambda _: _[0] == _[1], zip(x, y)))
assert temp(Solution().deleteNode(BinaryTreeNode.from_array([50,30,70,None,40,60,80]), 30).to_list(), [50,40,70,None,None,60,80])
assert temp(Solution().deleteNode(BinaryTreeNode.from_array([5,3,6,2,4,None,7]), 0).to_list(), [5,3,6,2,4,None,7])
```

</div>

<div id="fe20431d-d2a4-4252-ab53-db58a8e4b9fc" class="cell markdown">

## 90.

Date: 6th Jan 2024<br> Easy Leetcode: jewels-and-stones<br> Solution:
<https://leetcode.com/problems/jewels-and-stones/submissions/1138720128>

</div>

<div id="f40dc916-d4cc-40a1-bf46-0f3fc0890ee1" class="cell code"
execution_count="97">

``` python
class Solution:
    def numJewelsInStones(self, jewels: str, stones: str) -> int:
        stone_freq = collections.Counter(stones)
        jewel_hashset = set(jewels)

        jewel_count = 0
        for k, v in stone_freq.items():
            if k in jewel_hashset:
                jewel_count += v
                
        return jewel_count
        
# Test the solution
assert Solution().numJewelsInStones("aA", "aAAbbbb") == 3
assert Solution().numJewelsInStones("z", "zZ") == 1
```

</div>

<div id="c750f014-386b-4f32-882d-884b5c7b6e30" class="cell markdown">

## 91.

Date: 7th Jan 2024<br> Hard Leetcode:
maximum-profit-in-job-scheduling<br> Solution:
<https://leetcode.com/problems/maximum-profit-in-job-scheduling/submissions/1139032071/>

</div>

<div id="b6b570ee-983d-4bf3-8a27-6d2e826ac214" class="cell code"
execution_count="98">

``` python
class Solution:
    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:

        n = len(startTime)
        startTime, endTime, profit = zip(*sorted(zip(startTime, endTime, profit), key=lambda x: x[0]))

        @functools.lru_cache
        def backtrack(curr: int = 0, prev: int = None) -> int:
            # Base case
            if curr >= n:
                return 0

            else:
                # If we choose to pick the current job
                if prev is None or endTime[prev] <= startTime[curr]:
                    pick = profit[curr] + backtrack(curr + 1, curr)
                else:
                    pick = 0

                # If we choose not to pick the current job
                nopick = backtrack(curr + 1, prev)
                return max(pick, nopick)

        return backtrack()

    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:
        'https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/409009/java-c-python-dp-solution/'
        jobs = sorted(zip(startTime, endTime, profit), key=lambda v: v[1])
        dp = [[0, 0]]
        for s, e, p in jobs:
            i = bisect.bisect(dp, [s + 1]) - 1
            if dp[i][1] + p > dp[-1][1]:
                dp.append([e, dp[i][1] + p])
        return dp[-1][1]

# Test the solution
assert Solution().jobScheduling([24,24,7,2,1,13,6,14,18,24], [27,27,20,7,14,22,20,24,19,27], [6,1,4,2,3,6,5,6,9,8]) == 20
assert Solution().jobScheduling([848,586,593,909,163,129,685,481,258,764], [917,920,975,984,996,471,770,656,977,922], [48,72,37,67,72,46,54,37,53,30]) == 204
```

</div>

<div id="fc24d0b1-e48c-4abf-aa9c-3a2ec63d5a69" class="cell markdown">

## 92.

Date: 7th Jan 2024<br> Easy Leetcode:
determine-color-of-a-chessboard-square<br> Solution:
<https://leetcode.com/problems/determine-color-of-a-chessboard-square/submissions/1139164949/>

</div>

<div id="9eda5233-5806-4e9b-8d97-1eb76338afae" class="cell code"
execution_count="99">

``` python
class Solution:
    def squareIsWhite(coordinates: str) -> bool:

       # Get the coords in integers 
       x = ord(coordinates[0]) - 97
       y = int(coordinates[1])

       return not (x + y) % 2

# Test the solution
assert Solution.squareIsWhite("a1") == False
assert Solution.squareIsWhite("h3") == True
assert Solution.squareIsWhite("c7") == False
```

</div>

<div id="273edc0e-d309-4819-b323-eae9c483ca2d" class="cell markdown">

## 93.

Date: 7th Jan 2024<br> Medium Leetcode:
determine-color-of-a-chessboard-square<br> Solution:
<https://leetcode.com/problems/minimum-moves-to-capture-the-queen/submissions/1139194482/>

</div>

<div id="3d9d1d72-e750-4790-8747-15c95d81b0fd" class="cell code"
execution_count="100">

``` python
class Solution:
    def minMovesToCaptureTheQueen(a: int, b: int, c: int, d: int, e: int, f: int) -> int:
        # Answer can be 1, 2, or 3
        # Min(bishop moves, rook moves)
        rook, bishop, queen = (a - 1, b - 1), (c - 1, d - 1), (e - 1, f - 1)

        # Directions to move
        bishop_dirs = [(1, 1), (-1, -1), (1, -1), (-1, 1)]
        rook_dirs = [(1, 0), (0, 1), (-1, 0), (0, -1)]

        # Move bishop
        for direction in bishop_dirs:
            curr = bishop
            hit_rook = False
            while 0 <= curr[0] <= 7 and 0 <= curr[1] <= 7:
                curr = (curr[0] + direction[0], curr[1] + direction[1])
                if curr == queen:
                    print ("Bishop has hit the Queen")
                    if not hit_rook:
                        return 1
                    else:
                        return 2 # Rook can capture in 2 moves
                if curr == rook:
                    print ("Bishop has hit the Rook")
                    hit_rook = True


        # Move rook
        for direction in rook_dirs:
            curr = rook
            hit_bishop = False
            while 0 <= curr[0] <= 7 and 0 <= curr[1] <= 7:
                curr = (curr[0] + direction[0], curr[1] + direction[1])
                if curr == queen:
                    print ("Rook has hit the Queen")
                    if not hit_bishop:
                        return 1
                    else:
                        # Rook on its own would take 3 moves, however bishop can move outwards and let rook cut 
                        # So result is always 2
                        return 2

                if curr == bishop:
                    print ("Rook has hit the Bishop")
                    hit_bishop = True

        return 2

    def showBoard(a, b, c, d, e, f, *, empty_spaces=1):
        
        rook, bishop, queen = (a - 1, b - 1), (c - 1, d - 1), (e - 1, f - 1)
        for i in range(8):
            for j in range(8):
                if (i, j) == rook:
                    print ("R", end=" "*empty_spaces)
                elif (i, j) == bishop:
                    print ("B", end=" "*empty_spaces)
                elif (i, j) == queen:
                    print("Q", end=" "*empty_spaces)
                else:
                    print("#" if (i + j) % 2 else "*", end=" "*empty_spaces)

            print()

# Test the solution
# assert Solution.minMovesToCaptureTheQueen(5, 3, 3, 4, 5, 2) == 1
# assert Solution.minMovesToCaptureTheQueen(a=1, b=1, c=8, d=8, e=2, f=3) == 2
temp = [6, 8, 6, 6, 6, 3]
assert Solution.minMovesToCaptureTheQueen(*temp) == 2
Solution.showBoard(*temp, empty_spaces=3)
```

<div class="output stream stdout">

    Rook has hit the Bishop
    Rook has hit the Queen
    *   #   *   #   *   #   *   #   
    #   *   #   *   #   *   #   *   
    *   #   *   #   *   #   *   #   
    #   *   #   *   #   *   #   *   
    *   #   *   #   *   #   *   #   
    #   *   Q   *   #   B   #   R   
    *   #   *   #   *   #   *   #   
    #   *   #   *   #   *   #   *   

</div>

</div>

<div id="b8b79e97-b5e0-4e11-bf02-63dc4753b15a" class="cell markdown">

## 94.

Date: 7th Jan 2024<br> Hard Leetcode:
arithmetic-slices-ii-subsequence<br> Solution:
<https://leetcode.com/problems/arithmetic-slices-ii-subsequence/submissions/1139335916>

</div>

<div id="ffd56be7-c81f-44be-89df-bd746eaeb727" class="cell code"
execution_count="101">

``` python
class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:

        @functools.cache
        def countArithmeticSlices(currIdx: int, diff: int) -> int:

            curr, nextNum = nums[currIdx], nums[currIdx] + diff
            count = 0

            if nextNum in hashmap:
                nextIdx = hashmap[nextNum]
                if type(nextIdx) == int and nextIdx > currIdx:
                    count += 1 + countArithmeticSlices(nextIdx, diff)
                elif type(nextIdx) == list:
                    for i in filter(lambda x: x > currIdx, nextIdx):
                        if curr + diff == nums[i]:
                            count += 1 + countArithmeticSlices(i, diff)

            return count

        n = len(nums)
        result = 0
        hashmap = dict()
        for k, v in enumerate(nums):
            if v not in hashmap:
                hashmap[v] = k
            else: 
                hashmap[v] = [hashmap[v], k] if type(hashmap[v]) == int else [*hashmap[v], k]

        for i in range(n):
            for j in range(i + 1, n):
                diff = nums[j] - nums[i]
                result += countArithmeticSlices(j, diff)
        return result

# Test the solution
assert Solution().numberOfArithmeticSlices(list(range(1000))) == 2781846
assert Solution().numberOfArithmeticSlices([3,6,9,12,15,2,4,8,10,10,10,10,10]) == 28
assert Solution().numberOfArithmeticSlices([7,7,7,7,7]) == 16
```

</div>

<div id="6572f414-ed4e-4b4a-a778-3a63600881ee" class="cell markdown">

## 95.

Date: 7th Jan 2024<br> Easy Leetcode: assign-cookies<br> Solution:
<https://leetcode.com/problems/assign-cookies/submissions/1139397548/>

</div>

<div id="cf76c2f2-eeed-4ecf-8a3b-f0c4a68f3d56" class="cell code"
execution_count="102">

``` python
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:

        g.sort()
        s.sort()

        # 2 pointers
        gi = si = 0

        satisifed = 0
        while si < len(s) and gi < len(g):
            if s[si] >= g[gi]:
                gi += 1
                satisifed += 1
            si += 1

        return satisifed

# Test the solution
assert Solution().findContentChildren([1, 2, 3], [1, 1]) == 1
assert Solution().findContentChildren([1, 2], [1, 2, 3]) == 2
assert Solution().findContentChildren([10,9,8,7], [5,6,7,8]) == 2
assert Solution().findContentChildren([10,15,20], [5,5,5,5,5,5]) == 0
```

</div>

<div id="f7ad685f-96d5-4bc6-b979-55e7fc2d9b96" class="cell markdown">

## 96.

Date: 7th Jan 2024<br> Medium Leetcode: 3sum<br> Solution:
<https://leetcode.com/problems/3sum/submissions/1139496979>

</div>

<div id="c2ec4fe9-53c4-4274-83bd-059fb21153d8" class="cell code"
execution_count="103">

``` python
class Solution:
    def threeSum_(self, nums: List[int]) -> List[List[int]]:
        hashmap = dict()
        for i, n in enumerate(nums):
            indices = hashmap.get(n, set())
            indices.add(i)
            hashmap[n] = indices

        i = 0
        j = len(nums) - 1

        solutions = set()
        for i, j in itertools.combinations(range(len(nums)), r=2):
                
            partial_sum = nums[i] + nums[j]
            target = - partial_sum

            indices = hashmap.get(target, set())
            
            idx = None
            for idx in indices:
                if idx != i and idx != j:
                    break
                else:
                    idx = None
                    
            if idx:
                solution = (nums[i], nums[j], nums[idx])
                solutions.add(tuple(sorted(solution)))

        return solutions

    def threeSum(self, nums: List[int]) -> List[List[int]]:
        
        # Sort the array
        nums.sort()
        n = len(nums)
        solutions = []

        i = 0
        while i <= n - 3:
            j = i + 1
            k = n - 1
            while j < k:
                total = nums[i] + nums[j] + nums[k]
                if total == 0:
                    solutions.append([nums[i], nums[j], nums[k]])
                    j += 1
                    k -= 1
                elif total < 0:
                    j += 1
                else:
                    k -= 1
                    
            i += 1
            
        return set(map(lambda x: tuple(sorted(x)), solutions))

# Test the solution
temp = [1,-2,2,5,3,0,0,1,2,-4,4]
assert Solution().threeSum(temp) == Solution().threeSum_(temp)
```

</div>

<div id="5db1e2a7-bb7c-47d7-830e-c1e9bcdb8607" class="cell markdown">

## 97.

Date: 8th Jan 2024<br> Easy Leetcode: contains-duplicate-ii<br>
Solution:
<https://leetcode.com/problems/contains-duplicate-ii/submissions/1139965212/>

</div>

<div id="7e5d2a3b-5c1e-4a8e-8253-559e478b6906" class="cell code"
execution_count="104">

``` python
class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:
        indices = dict()
        for i, n in enumerate(nums):
            if n not in indices:
                indices[n] = i
            else:
                last_idx = indices[n]
                if abs(last_idx - i) <= k:
                    return True
                else:
                    indices[n] = i
                    
        return False

# Test the solution
assert Solution().containsNearbyDuplicate([1], 10) == False
assert Solution().containsNearbyDuplicate([1,0,1], 0) == False
assert Solution().containsNearbyDuplicate([1,1], 0) == False
assert Solution().containsNearbyDuplicate([1,1], 1) == True
assert Solution().containsNearbyDuplicate([1,0,0,1], 0) == False
```

</div>

<div id="853d41bc-d832-4646-9058-7ae8a4cfdddb" class="cell markdown">

## 98.

Date: 8th Jan 2024<br> Easy Leetcode:
intersection-of-two-linked-lists/<br> Solution:
<https://leetcode.com/problems/intersection-of-two-linked-lists/submissions/1139982107/>

</div>

<div id="f2195972-46ce-402d-a58c-76e51960f529" class="cell code"
execution_count="105">

``` python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:

        # Time Complexity - O(M + N)
        # Space Complexity - O(1)

        lengthA = lengthB = 0

        curr = headA
        while curr:
            lengthA += 1
            curr = curr.next

        curr = headB
        while curr:
            lengthB += 1
            curr = curr.next

        skipA = max(lengthA - lengthB, 0)
        skipB = max(lengthB - lengthA, 0)

        while skipA > 0:
            headA = headA.next
            skipA -= 1

        while skipB > 0:
            headB = headB.next
            skipB -= 1

        while headA and headB and headA != headB:
            headA = headA.next
            headB = headB.next

        # Since the len is equal, headA would either be the pt of intersection or null
        return headA

# Helper function to create the head nodes
def create_test(listA, listB, skipA):
    
    headA = ListNode.to_singly_linked_list(listA)
    headB = ListNode.to_singly_linked_list(listB)
    
    commonNode = headA
    while skipA > 0:
        commonNode = commonNode.next
        skipA -= 1
    
    curr = headB
    while curr.next:
        curr = curr.next
    
    curr.next = commonNode
    return headA, headB

# Test the solution
temp = Solution().getIntersectionNode(*create_test([4,1,8,4,5], [5,6,1], 2))
assert temp and temp.to_list() == [8, 4, 5]

temp = Solution().getIntersectionNode(ListNode.to_singly_linked_list([1,2,3]), ListNode.to_singly_linked_list([4,5]))
assert not temp
```

</div>

<div id="2ad589a1-fa41-4fd5-8a60-cf36317d26c2" class="cell markdown">

## 99.

Date: 8th Jan 2024<br> Medium Leetcode: permutations-ii<br> Solution:
<https://leetcode.com/problems/permutations-ii/submissions/1140352989/>

</div>

<div id="ac53ac06-c91a-40e0-b771-1ea4cbb501e0" class="cell code"
execution_count="106">

``` python
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:

        def permuteR(nums: list[int], size: int = None) -> List[List[int]]:

            if size is None:
                size = len(nums)

            if size == 0:
                return [tuple()]

            results = []
            for n in set(nums):
                copy = list(nums)
                copy.remove(n)
                for result in permuteR(copy, size-1):
                    results.append((n,) + result)

            return results

        def permuteI(nums: list[int]) -> List[List[int]]:

            results = {(nums[0],)}
            for n in nums[1:]:
                new_results = set()
                for result in results:
                    for i in range(len(result) + 1):
                        new_results.add(result[:i] + (n,) + result[i:])
                results = new_results

            return list(results)

        return permuteI(nums)

# Test the solution
Solution().permuteUnique([1, 2, 2])
```

<div class="output execute_result" execution_count="106">

    [(1, 2, 2), (2, 1, 2), (2, 2, 1)]

</div>

</div>

<div id="7c492bb1-b924-4f9a-b096-4a89ce260524" class="cell markdown">

## 100.

Date: 8th Jan 2024<br> Medium Leetcode: group-anagrams<br> Solution:
<https://leetcode.com/problems/group-anagrams/submissions/1140452313/>

</div>

<div id="8a1d9b6b-bfee-4c2c-84bb-49529e7f6464" class="cell code"
execution_count="107">

``` python
class Solution:
    def shorten(s: str):
        counter = collections.Counter(s)
        result = []
        for i in range(97, 123):
            c = chr(i)
            if c in counter:
                result.append(f'{c}{counter[c]}')

        return ''.join(result)

    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        groupings = dict()
        for s in strs:
            shorterned = Solution.shorten(s)
            group = groupings.get(shorterned, [])
            group.append(s)
            groupings[shorterned] = group
        return list(groupings.values())

# Test the solution
Solution().groupAnagrams(["eat","tea","tan","ate","nat","bat"])
```

<div class="output execute_result" execution_count="107">

    [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]

</div>

</div>

<div id="d879b4e7-ea3f-4e11-9c08-1d731cca33b1" class="cell markdown">

## 101.

Date: 9th Jan 2024<br> Medium Leetcode: can-i-win<br> Solution:

</div>

<div id="e3dcde2e-cd51-40f0-b740-903aa0647c3a" class="cell code"
execution_count="63">

``` python
class Solution:

    def canIWin(self, maxChoosableInteger: int, desiredTotal: int, pool: set[int] = None) -> bool:

        if not pool:
            pool = set(range(1, maxChoosableInteger + 1))
            cumTotal = (maxChoosableInteger * (maxChoosableInteger + 1)) / 2
        else:
            cumTotal = sum(pool)

        if desiredTotal <= maxChoosableInteger:
            return True
        elif desiredTotal > cumTotal:
            return False
        elif desiredTotal == maxChoosableInteger + 1:
            return False
        elif (desiredTotal - maxChoosableInteger - 1) in pool:
            return True
        elif desiredTotal == cumTotal:
            return True if len(pool) % 2 == 1 else False
        else:# 2 * maxChoosableInteger < desiredTotal < totalSum:
            # Try out scenarios with backtracking
            # Pick a number - check if for each number that the opp is left to choose they can only lose
            # If no such number exists, we can't force a win return False
            for n in pool:
                updated_pool = set.difference(pool, {n})
                updated_max = maxChoosableInteger if maxChoosableInteger in updated_pool else max(updated_pool)
                if not self.canIWin(updated_max, desiredTotal - n, updated_pool):
                    return True
            else: # Opp wins in every path
                return False

# Testing the solution
Solution().canIWin(20, 209)
```

<div class="output error" ename="KeyboardInterrupt" evalue="">

    ---------------------------------------------------------------------------
    KeyboardInterrupt                         Traceback (most recent call last)
    Cell In[63], line 34
         31                 return False
         33 # Testing the solution
    ---> 34 Solution().canIWin(20, 209)

    Cell In[63], line 28, in Solution.canIWin(self, maxChoosableInteger, desiredTotal, pool)
         26     updated_pool = set.difference(pool, {n})
         27     updated_max = maxChoosableInteger if maxChoosableInteger in updated_pool else max(updated_pool)
    ---> 28     if not self.canIWin(updated_max, desiredTotal - n, updated_pool):
         29         return True
         30 else: # Opp wins in every path

    Cell In[63], line 28, in Solution.canIWin(self, maxChoosableInteger, desiredTotal, pool)
         26     updated_pool = set.difference(pool, {n})
         27     updated_max = maxChoosableInteger if maxChoosableInteger in updated_pool else max(updated_pool)
    ---> 28     if not self.canIWin(updated_max, desiredTotal - n, updated_pool):
         29         return True
         30 else: # Opp wins in every path

        [... skipping similar frames: Solution.canIWin at line 28 (16 times)]

    Cell In[63], line 28, in Solution.canIWin(self, maxChoosableInteger, desiredTotal, pool)
         26     updated_pool = set.difference(pool, {n})
         27     updated_max = maxChoosableInteger if maxChoosableInteger in updated_pool else max(updated_pool)
    ---> 28     if not self.canIWin(updated_max, desiredTotal - n, updated_pool):
         29         return True
         30 else: # Opp wins in every path

    Cell In[63], line 9, in Solution.canIWin(self, maxChoosableInteger, desiredTotal, pool)
          7     cumTotal = (maxChoosableInteger * (maxChoosableInteger + 1)) / 2
          8 else:
    ----> 9     cumTotal = sum(pool)
         11 if desiredTotal <= maxChoosableInteger:
         12     return True

    KeyboardInterrupt: 

</div>

</div>

<div id="169a1419-4ff8-431b-9c76-3e3143361725" class="cell code">

``` python
```

</div>

<div id="17fa6433-ed8e-4a03-832d-317321c945fe" class="cell code">

``` python
```

</div>

<div id="1dc53243-7e47-4b6b-a35f-31e1a48d276e" class="cell markdown">

</div>
