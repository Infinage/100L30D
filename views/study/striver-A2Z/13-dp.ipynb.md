---
jupyter:
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
  language_info:
    codemirror_mode:
      name: ipython
      version: 3
    file_extension: .py
    mimetype: text/x-python
    name: python
    nbconvert_exporter: python
    pygments_lexer: ipython3
    version: 3.11.9
  nbformat: 4
  nbformat_minor: 5
  papermill:
    default_parameters: {}
    duration: 6.659531
    end_time: "2024-05-17T14:08:54.204647"
    environment_variables: {}
    input_path: study/striver-A2Z/13-dp.ipynb
    output_path: study/striver-A2Z/13-dp.ipynb
    parameters: {}
    start_time: "2024-05-17T14:08:47.545116"
    version: 2.6.0
---

<div id="807dd9ee" class="cell markdown"
papermill="{&quot;duration&quot;:1.6323e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:48.693012&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:48.676689&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Important notes

- All subset based problems (non contigous subarrays would have the
  pick/nopick approach)
- To convert a memoization solution to tabulation:
  1.  Find the base case and assign the the DP
  2.  Start iterating from the base case all the way to our starting
      point
  3.  Return the value at the starting point
- We can space optimize a tabulation solution whenever we see only the
  prev/next rows being used in the tabualation solution.
- Time complexity of unmemoized DP code is typically exponential
  O(number of branches \*\* N)
- All subsets problem involve recursion trying all combinations: Pick,
  no pick
- For problems where there is an infinite supply, take would increase
  total but remain at the same index.
- For problems involving counts, we try all possb combinations and base
  case would either return 1 or 0.

</div>

<div id="457ab51f" class="cell markdown"
papermill="{&quot;duration&quot;:1.5218e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:48.723317&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:48.708099&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

### Some important imports

</div>

<div id="164d751b" class="cell code" execution_count="1"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:48.754573Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:48.754386Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:48.759793Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:48.759366Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2356e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:48.760862&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:48.738506&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
import functools
import itertools
import collections
import math
import heapq
```

</div>

<div id="48648354" class="cell markdown"
papermill="{&quot;duration&quot;:1.5159e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:48.791689&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:48.776530&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Introduction to DP: <https://youtu.be/tyB0ztf0DNY?si=SgpBwGNqPXzdPSRA>

1.  Tabulation: Bottom up DP: Ans -\> Base case -\> Ans
2.  Memoization: Top down DP: Base case -\> Ans

</div>

<div id="41c46591" class="cell code" execution_count="2"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:48.823304Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:48.822826Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:48.828983Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:48.828446Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.3087e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:48.830061&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:48.806974&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def fiboBrute(n: int) -> int:
    """
    Vanilla recursion
    Time: O(2 ^ N), Space: O(2 ^ N)
    """
    if n <= 1:
        return n
    else:
        return fiboBrute(n - 1) + fiboBrute(n - 2)

fiboBrute(10)
```

<div class="output execute_result" execution_count="2">

    55

</div>

</div>

<div id="83ba7cd5" class="cell code" execution_count="3"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:48.861621Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:48.861302Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:48.866216Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:48.865730Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.1736e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:48.867225&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:48.845489&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def fiboBetter1(n: int) -> int:
    """
    Memoization Approach: Top down approach
    Time: O(N), Space: O(N) + O(N)
    """
    dp: list[int] = [-1 for i in range(n + 1)]
    def backtrack(curr: int) -> int:
        if curr <= 1:
            return curr
        elif dp[curr] != -1:
            return dp[curr]
        else:
            dp[curr] = backtrack(curr - 1) + backtrack(curr - 2)
            return dp[curr]

    return backtrack(n)

fiboBetter1(10)
```

<div class="output execute_result" execution_count="3">

    55

</div>

</div>

<div id="80fded7e" class="cell code" execution_count="4"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:48.898690Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:48.898378Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:48.902855Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:48.902362Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.1225e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:48.903840&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:48.882615&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def fiboBetter2(n: int) -> int:
    """
    Tabulation: Bottom up approach
    Time: O(N), Space: O(N)
    """
    dp: list[int] = [-1 if i > 1 else i for i in range(n + 1)]
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]

    return dp[n]

fiboBetter2(10)
```

<div class="output execute_result" execution_count="4">

    55

</div>

</div>

<div id="8f7d86e2" class="cell code" execution_count="5"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:48.935625Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:48.935215Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:48.939473Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:48.938990Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.1238e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:48.940568&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:48.919330&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def fiboOptimal(n: int) -> int:
    """
    Bottom up approach
    Time: O(N), Space: O(1)
    """
    prev2, prev1 = 0, 1
    for i in range(2, n + 1):
        prev2, prev1 = prev1, prev1 + prev2
        n -= 1

    return prev1

fiboOptimal(10)
```

<div class="output execute_result" execution_count="5">

    55

</div>

</div>

<div id="855c35fb" class="cell markdown"
papermill="{&quot;duration&quot;:1.5422e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:48.971648&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:48.956226&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Climbing Stairs: <https://leetcode.com/problems/climbing-stairs/> Video
Link: <https://youtu.be/mLfjzJsN8us?si=C7W-jiYvql0mEnbh>

</div>

<div id="87993489" class="cell code" execution_count="6"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:49.003171Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:49.002986Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:49.006998Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:49.006423Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.1556e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:49.008599&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:48.987043&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def climbStairsBetter(n: int) -> int:
    """Time: O(N), Space: O(N)"""

    dp: list[int] = [-1 for i in range(n + 1)]
    def backtrack(curr: int) -> int:
        if curr <= 1:
            return 1
        elif dp[curr] != -1:
            return dp[curr]
        else:
            dp[curr] = backtrack(curr - 1) + backtrack(curr - 2)
            return dp[curr]

    return backtrack(n)

assert climbStairsBetter(45) == 1836311903
```

</div>

<div id="2dc15ac3" class="cell code" execution_count="7"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:49.056071Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:49.055567Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:49.059236Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:49.058811Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.1206e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:49.060245&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:49.039039&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def climbStairs(n: int) -> int:
    """Time: O(N), Space: O(1)"""
    prev2, prev1 = 1, 1
    while n > 0:
        prev2, prev1 = prev1, prev1 + prev2
        n -= 1

    return prev2

assert climbStairs(45) == 1836311903
```

</div>

<div id="3cd4d88c" class="cell markdown"
papermill="{&quot;duration&quot;:1.547e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:49.091536&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:49.076066&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video link: <https://youtu.be/EgG3jsGoPvQ?si=Cm5AVvq_zCnr-w6q> Frog
Jump: 1

</div>

<div id="59c27b1e" class="cell code" execution_count="8"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:49.123769Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:49.123379Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:49.128056Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:49.127605Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2033e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:49.129205&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:49.107172&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def frogJumpBetter(N: int, heights: list[int]) -> int:
    """
    Time: O(N), Space: O(N) + O(N)
    """

    @functools.cache
    def backtrack(curr: int) -> int:
        if curr == N - 1:
            return 0
        elif curr == N - 2:
            return abs(heights[N - 1] - heights[N - 2])
        else:
            jump1 = abs(heights[curr] - heights[curr + 1]) + backtrack(curr + 1)
            jump2 = abs(heights[curr] - heights[curr + 2]) + backtrack(curr + 2)
            return min(jump1, jump2)

    return backtrack(0)

# Testing the solution
assert frogJumpBetter(4, [10,20,30,10]) == 20
assert frogJumpBetter(3, [10,50,10]) == 0
```

</div>

<div id="2bc52e04" class="cell code" execution_count="9"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:49.161147Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:49.160670Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:49.164885Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:49.164470Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.125e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:49.165964&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:49.144714&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def frogJumpOptimal(N: int, heights: list[int]) -> int:
    "Time: O(N), Space: O(1)"
    jump1, jump2 = abs(heights[-2] - heights[-1]), 0
    for i in range(N - 3, -1, -1):
        curr = min(abs(heights[i] - heights[i + 1]) + jump1, abs(heights[i] - heights[i + 2]) + jump2)
        jump1, jump2 = curr, jump1

    return jump1

assert frogJumpOptimal(4, [10,20,30,10]) == 20
assert frogJumpOptimal(3, [10,50,10]) == 0
```

</div>

<div id="4fa38d19" class="cell markdown"
papermill="{&quot;duration&quot;:1.5415e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:49.197159&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:49.181744&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video Link: <https://youtu.be/Kmh3rhyEtB8?si=rqZ5-pJcjIzWU5i8> Frog Jump
with K distance

</div>

<div id="f21ca119" class="cell code" execution_count="10"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:49.228788Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:49.228574Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:49.233376Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:49.232829Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.1936e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:49.234412&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:49.212476&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def frogJumpAtKDistBetter1(N: int, K: int, heights: list[int]) -> int:
    """
    Memoization Approach: Top Down Approach
    Time: O(N x K), Space: O(N) + O(N)
    """

    @functools.cache
    def backtrack(curr: int) -> int:
        if curr >= N - 1:
            return 0
        else:
            minCost = math.inf
            for next_ in range(curr + 1, min(N, curr + K + 1)):
                cost = abs(heights[curr] - heights[next_]) + backtrack(next_)
                minCost = min(minCost, cost)

            return int(minCost)

    return backtrack(0)

# Testing the solution
assert frogJumpAtKDistBetter1(5, 3, [10,30,40,50,20]) == 30
assert frogJumpAtKDistBetter1(3, 1, [10,20,10]) == 20
```

</div>

<div id="1b9a86c0" class="cell code" execution_count="11"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:49.266392Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:49.266069Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:49.270673Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:49.270232Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.1695e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:49.271752&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:49.250057&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def frogJumpAtKDistBetter2(N: int, K: int, heights: list[int]) -> int:
    """
    Tabulation: Bottom up approach
    Time: O(N x K), Space: O(N)
    """

    dp: list[int] = [-1 for i in range(N)]
    dp[-1] = 0

    for curr in range(N - 2, -1, -1):
        minCost = math.inf
        for next_ in range(curr + 1, min(N, curr + K + 1)):
            cost = abs(heights[curr] - heights[next_]) + dp[next_]
            minCost = min(minCost, cost)
        dp[curr] = int(minCost)

    return dp[0]

# Testing the solution
assert frogJumpAtKDistBetter2(5, 3, [10,30,40,50,20]) == 30
assert frogJumpAtKDistBetter2(3, 1, [10,20,10]) == 20
```

</div>

<div id="09ca5d18" class="cell code" execution_count="12"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:49.303567Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:49.303364Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:49.308299Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:49.307776Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2038e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:49.309343&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:49.287305&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def frogJumpAtKDist(N: int, K: int, heights: list[int]) -> int:
    """
    Tabulation: Bottom up approach
    Time: O(N x K), Space: O(K)
    """

    dp: collections.deque[int] = collections.deque([0])
    for curr in range(N - 2, -1, -1):
        minCost = math.inf
        for jump in range(1, min(N - curr, K + 1)):
            next_ = curr + jump
            cost = abs(heights[curr] - heights[next_]) + dp[jump - 1]
            minCost = min(minCost, cost)

        dp.appendleft(int(minCost))
        if len(dp) > K:
            dp.pop()

    return dp[0]

# Testing the solution
assert frogJumpAtKDist(5, 3, [10,30,40,50,20]) == 30
assert frogJumpAtKDist(3, 1, [10,20,10]) == 20
```

</div>

<div id="259d53f8" class="cell markdown"
papermill="{&quot;duration&quot;:1.5451e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:49.340443&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:49.324992&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Maximum sum of Non Adjacent Elements: House Robber Video Link:
<https://youtu.be/GrMBfJNk_NY?si=IPuGJglc0axETveU>

</div>

<div id="89d8dea7" class="cell code" execution_count="13"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:49.372450Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:49.371988Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:49.376238Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:49.375724Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.1524e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:49.377407&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:49.355883&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def robMemo(nums: list[int]) -> int:
    """
    Memoization: Top down approach
    Time: O(N), Space: O(N)
    """

    @functools.cache
    def backtrack(curr: int) -> int:
        if curr >= N:
            return 0
        else:
            return max(backtrack(curr + 1), nums[curr] + backtrack(curr + 2))

    N = len(nums)
    return backtrack(0)

# Testing the solution
assert robMemo([2,7,9,3,1]) == 12
```

</div>

<div id="e69063ac" class="cell code" execution_count="14"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:49.409857Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:49.409449Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:49.413472Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:49.413014Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.1291e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:49.414476&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:49.393185&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def robTab(nums: list[int]) -> int:
    """
    Tabulation: Bottom up approach
    Time: O(N), Space: O(N)
    """
    N = len(nums)
    dp: list[int] = [-1 for i in range(N + 1)]
    dp[-1], dp[-2] = 0, nums[-1]
    for curr in range(N - 2, -1, -1):
        dp[curr] = max(nums[curr] + dp[curr + 2], dp[curr + 1])

    return dp[0]

# Testing the solution
assert robTab([2,7,9,3,1]) == 12
```

</div>

<div id="d3ac1b1c" class="cell code" execution_count="15"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:49.446513Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:49.446144Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:49.449401Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:49.448957Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.0316e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:49.450429&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:49.430113&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/house-robber/submissions/1249841355/
def robSpaceOptimized(nums: list[int]) -> int:
    "Time: O(N), Space: O(1)"
    next1 = next2 = 0
    for curr in range(len(nums) - 1, -1, -1):
        next1, next2 = max(nums[curr] + next2, next1), next1

    return next1

assert robSpaceOptimized([2,7,9,3,1]) == 12
```

</div>

<div id="630eec21" class="cell markdown"
papermill="{&quot;duration&quot;:1.554e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:49.481574&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:49.466034&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

House Robber 2: <https://youtu.be/3WaxQMELSkw?si=i9oGKnDJGJxvUjbu>
<https://leetcode.com/problems/house-robber-ii/submissions/1249888930>

</div>

<div id="3ee7a5cf" class="cell code" execution_count="16"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:49.513741Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:49.513515Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:49.517502Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:49.517084Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.1433e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:49.518551&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:49.497118&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def rob2(nums: list[int]) -> int:
    """
    Ans cannot contain both the first and the last house.
    It can contain either the first or the last house.
    """
    def rob(arr: list[int]) -> int:
        next1 = next2 = 0
        for curr in range(len(arr) - 1, -1, -1):
            next1, next2 = max(arr[curr] + next2, next1), next1

        return next1

    return max(rob(nums[1:]), rob(nums[:-1])) if len(nums) > 1 else sum(nums)

# Testing the solution
assert rob2([1,2,3,1]) == 4
assert rob2([]) == 0
```

</div>

<div id="52745498" class="cell markdown"
papermill="{&quot;duration&quot;:1.5516e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:49.549622&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:49.534106&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Ninja's Training: <https://youtu.be/AE39gJYuRog?si=n4BhCotno-9chP5j>

</div>

<div id="c814dc79" class="cell code" execution_count="17"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:49.581673Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:49.581326Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:49.586499Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:49.585973Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2523e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:49.587523&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:49.565000&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def ninjaTrainingBetter(N: int, points: list[list[int]]) -> int:
    """
    Memoization: Top down approach

    Time: O(N), Space: O(N) + O(N)
    """

    @functools.cache
    def backtrack(i: int, j: int) -> int:
        if i == N:
            return 0
        else:
            max_ = -math.inf
            for k in range(3):
                if k != j:
                    max_ = max(max_, points[i][k] + backtrack(i + 1, k))

            return int(max_)

    return backtrack(0, -1)

# Testing the solution
assert ninjaTrainingBetter(3, [[10,40,70], [20,50,80], [30,60,90]]) == 210
assert ninjaTrainingBetter(3, [[1,2,5], [3,1,1], [3,3,3]]) == 11
assert ninjaTrainingBetter(2, [[10,50,1], [5,100,11]]) == 110
```

</div>

<div id="015e9458" class="cell code" execution_count="18"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:49.619593Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:49.619160Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:49.624303Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:49.623870Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2258e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:49.625403&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:49.603145&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def ninjaTraining(N: int, points: list[list[int]]) -> int:
    """
    Space optimized Tabulation DP: Bottom up

    Start at the last day.
    At each day we sum up corresponding values with the values in DP and assign them to DP.
    Before moving the prev day, to the DP perform this op -> dp[i] = max(dp[j]) where j != i

    At the end of the iteration simply return max of DP.

    Time: O(N), Space: O(1)
    """

    dp: list[int] = [0, 0, 0]
    for i in range(N - 1, -1, -1):
        for j in range(3):
            dp[j] += points[i][j]

        next_dp: list[int] = []
        for j in range(3):
            next_dp.append(max(dp[k] for k in range(3) if k != j))

        dp = next_dp

    return max(dp)

# Testing the solution
assert ninjaTraining(3, [[10,40,70], [20,50,80], [30,60,90]]) == 210
assert ninjaTraining(3, [[1,2,5], [3,1,1], [3,3,3]]) == 11
assert ninjaTraining(2, [[10,50,1], [5,100,11]]) == 110
```

</div>

<div id="d132fa58" class="cell markdown"
papermill="{&quot;duration&quot;:1.5299e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:49.656228&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:49.640929&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Unique 2D paths: <https://youtu.be/sdE0A2Oxofw?si=g1FpuSIYx0x95G-7>
<https://leetcode.com/problems/unique-paths/>

</div>

<div id="d035c9d7" class="cell code" execution_count="19"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:49.687964Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:49.687645Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:49.691795Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:49.691286Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.1105e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:49.692804&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:49.671699&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def uniquePathsMemo(m: int, n: int) -> int:
    """
    Memoization Solution: Top Down
    Time: O(m x n), Space: O(m x n) + O(m x n)
    """
    @functools.cache
    def backtrack(i: int, j: int) -> int:
        if i == m - 1 and j == n - 1:
            return 1
        elif i >= m or j >= n:
            return 0
        else:
            return backtrack(i + 1, j) + backtrack(i, j + 1)

    return backtrack(0, 0)

# Testing the solution
assert uniquePathsMemo(3, 7) == 28
assert uniquePathsMemo(3, 2) == 3
```

</div>

<div id="c3fb756d" class="cell code" execution_count="20"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:49.724759Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:49.724400Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:49.728301Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:49.727891Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.1101e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:49.729392&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:49.708291&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/unique-paths/submissions/1250526713
def uniquePathsTab(m: int, n: int) -> int:
    "Time: O(m x n), Space: O(min(m, n))"
    M, N = min(m, n), max(m, n)
    dp: list[int] = [1 for i in range(M)]

    for i in range(N - 1):
        for j in range(M - 2, -1, -1):
            dp[j] += dp[j + 1]

    return dp[0]

# Testing the solution
assert uniquePathsTab(3, 7) == 28
assert uniquePathsTab(3, 2) == 3
```

</div>

<div id="bb22f54a" class="cell markdown"
papermill="{&quot;duration&quot;:1.5452e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:49.760384&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:49.744932&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video link: <https://youtu.be/TmhpgXScLyY?si=M_FfFKRqRTXid4Jj> Unique
Paths - ii:
<https://leetcode.com/problems/unique-paths-ii/submissions/1250615914>

</div>

<div id="f59a530c" class="cell code" execution_count="21"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:49.792760Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:49.792261Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:49.797300Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:49.796821Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2455e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:49.798321&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:49.775866&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def uniquePathsWithObstacles(obstacleGrid: list[list[int]]) -> int:
    "Time: O(M x N), Space: O(N)"
    M, N = len(obstacleGrid), len(obstacleGrid[0])

    dp: list[int] = [0 for j in range(N)]
    dp[-1] = 1

    for i in range(M - 1, -1, -1):
        for j in range(N - 1, -1, -1):
            if obstacleGrid[i][j] == 0:
                dp[j] = dp[j] + dp[j + 1] if j < N - 1 else dp[j]
            else:
                dp[j] = 0

    return dp[0]

# Testing the solution
assert uniquePathsWithObstacles([[0,0,0],[0,1,0],[0,0,0]]) == 2
assert uniquePathsWithObstacles([[0,1],[0,0]]) == 1
assert uniquePathsWithObstacles([[1]]) == 0
```

</div>

<div id="93e28e9b" class="cell markdown"
papermill="{&quot;duration&quot;:1.5422e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:49.829334&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:49.813912&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Minimum Path Sum: <https://youtu.be/_rgTlyky1uQ?si=3xJY7MmVg5tTEW5Q>
<https://leetcode.com/problems/minimum-path-sum/submissions/1250633614>

</div>

<div id="c97f7ce9" class="cell code" execution_count="22"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:49.861348Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:49.860962Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:49.865695Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:49.865269Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.1879e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:49.866751&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:49.844872&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def minPathSum(grid: list[list[int]]) -> int:
    "Time: O(M x N), Space: O(N)"
    M, N = len(grid), len(grid[0])

    # Initialize DP
    dp: list[float] = [math.inf for j in range(N)]
    dp[-1] = 0

    # DP Solution
    for i in range(M - 1, -1, -1):
        for j in range(N - 1, -1, -1):
            dp[j] = grid[i][j] + (min(dp[j + 1], dp[j]) if j < N - 1 else dp[j])

    return int(dp[0])

# Testing the solution
assert minPathSum([[1,3,1],[1,5,1],[4,2,1]]) == 7
assert minPathSum([[1,2,3],[4,5,6]]) == 12
```

</div>

<div id="107526ff" class="cell markdown"
papermill="{&quot;duration&quot;:1.5523e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:49.897997&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:49.882474&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video Link: <https://youtu.be/0bHoB32fuj0?si=5UHeArKmLvTVpbrk> Triangle:
<https://leetcode.com/problems/triangle/submissions/1251774955/>

</div>

<div id="62387041" class="cell code" execution_count="23"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:49.929713Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:49.929547Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:49.933894Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:49.933460Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.146e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:49.934974&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:49.913514&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def minimumTotal(triangle: list[list[int]]) -> int:
    """Time: O(N x N), Space: O(N)"""
    N = len(triangle)
    dp: list[int] = [0 for i in range(N + 1)]

    while N > 0:
        next_: list[int] = []
        for i in range(N):
            next_.append(min(dp[i], dp[i + 1]) + triangle[N - 1][i])
        dp = next_
        N -= 1

    return dp[0]

# Testing the solution
assert minimumTotal([[2],[3,4],[6,5,7],[4,1,8,3]]) == 11
assert minimumTotal([[-10]]) == -10
```

</div>

<div id="51332104" class="cell markdown"
papermill="{&quot;duration&quot;:1.554e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:49.966099&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:49.950559&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video Link: <https://youtu.be/N_aJ5qQbYA0?si=LTME1YI3hqtU8u8_> Maximum
Falling path sum We cannot apply greedy algorithms here because there is
no uniformity mentioned. Uniformity implies how the numbers are
distributed. For eg:

    1   2  3    4
    10  1  100  1
    1   2  5    0

In the above example from (0, 0), if we greedily chose (1, 0) - we would
miss out on 100 at (1, 2). If suppose we were told that the numbers were
arranged in ascending or descending order we can greedily pick a path

</div>

<div id="4f9fb3eb" class="cell code" execution_count="24"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:49.997949Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:49.997477Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:50.002794Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:50.002353Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2351e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:50.003840&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:49.981489&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def getMaxPathSumBetter(matrix: list[list[int]]):
    """
    With memoization:
    Time complexity: O(3 ^ N)

    Memoization Approach: Top Down
    Time: O(N x M), Space: O(N x M) + O(N x M)
    """
    M, N = len(matrix), len(matrix[0])

    @functools.cache
    def backtrack(i: int = 0, j: int = 0) -> float:
        if i >= M:
            return 0
        elif j < 0 or j >= N:
            return -math.inf
        else:
            return matrix[i][j] + max(backtrack(i + 1, j - 1), backtrack(i + 1, j), backtrack(i + 1, j + 1))

    maxPathSum = -math.inf
    for j in range(N):
        maxPathSum = max(maxPathSum, backtrack(0, j))

    return int(maxPathSum)

# Testing the solution
assert getMaxPathSumBetter([[1,2,10,4],[100,3,2,1],[1,1,20,2],[1,2,2,1]]) == 105
assert getMaxPathSumBetter([[10,2,3],[3,7,2],[8,1,5]]) == 25
```

</div>

<div id="b3cf95be" class="cell code" execution_count="25"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:50.035890Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:50.035730Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:50.040701Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:50.040266Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2279e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:50.041723&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:50.019444&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def getMaxPathSum(matrix: list[list[int]]):
    """
    Space optimized DP: Bottom up
    Time: O(M x N), Space: O(N)
    """
    M, N = len(matrix), len(matrix[0])

    dp: list[float] = [0 for i in range(N)]
    i = M - 1
    while i >= 0:
        next_: list[float] = []
        for j in range(N):
            next_.append(matrix[i][j] + max(dp[j - 1] if j - 1 >= 0 else -math.inf, dp[j], dp[j + 1] if j + 1 < N else -math.inf))

        dp = next_
        i -= 1

    return max(dp)

# Testing the solution
assert getMaxPathSum([[1,2,10,4],[100,3,2,1],[1,1,20,2],[1,2,2,1]]) == 105
assert getMaxPathSum([[10,2,3],[3,7,2],[8,1,5]]) == 25
```

</div>

<div id="703cdb9d" class="cell markdown"
papermill="{&quot;duration&quot;:1.5564e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:50.072880&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:50.057316&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Cherry Pickup: 2: <https://leetcode.com/problems/cherry-pickup-ii/>
Video Link: <https://youtu.be/QGfn7JeXK54?si=2K0Lz9iKN_IxLUDN>

</div>

<div id="d82f0e5d" class="cell code" execution_count="26"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:50.104429Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:50.104224Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:50.111113Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:50.110632Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.3858e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:50.112125&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:50.088267&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def cherryPickupMemo(grid: list[list[int]]) -> int:
    """
    Without memoization, time complexity: O(3 ^ M * 3 ^ M)

    Space complexity is definitely improved with using @functools.cache, using list here to illustrate.
    Time: O (M x N x N), Space: O (M x N x N)

    To figure out the dp size, simply check how many parameters are chaning. Here we have an i, j1, j2 and hence dp is a 3D Matrix.
    """
    M, N = len(grid), len(grid[0])
    dp: list[list[list[float]]] = [[[-1 for k in range(N)] for j in range(N)] for i in range(M)]

    def backtrack(i: int, j1: int, j2: int) -> float:
        if j1 < 0 or j2 < 0 or j1 >= N or j2 >= N or j1 == j2:
            return -math.inf
        elif i > M - 1:
            return 0
        elif dp[i][j1][j2] != -1:
            return dp[i][j1][j2]
        else:
            next_picked = -math.inf
            for j1_offset in range(-1, 2):
                for j2_offset in range(-1, 2):
                    next_picked = max(next_picked, backtrack(i + 1, j1 + j1_offset, j2 + j2_offset))

            dp[i][j1][j2] = grid[i][j1] + grid[i][j2] + next_picked
            return dp[i][j1][j2]

    result = int(backtrack(0, 0, N - 1))
    return result

# Testing the solution
assert cherryPickupMemo([[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]) == 28
```

</div>

<div id="85c88b05" class="cell code" execution_count="27"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:50.143767Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:50.143570Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:50.150806Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:50.150296Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.4258e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:50.151901&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:50.127643&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def cherryPickupTab(grid: list[list[int]]) -> int:
    """
    Simply start with the base case. Move bottom up.
    """
    M, N = len(grid), len(grid[0])

    # Initialize DP with the base case
    dp: list[list[list[float]]] = [[[0 for k in range(N)] for j in range(N)] for i in range(M)]
    for j1 in range(N):
        for j2 in range(N):
            dp[-1][j1][j2] = grid[-1][j1] + grid[-1][j2] if j1 != j2 else grid[-1][j1]

    # i, j1, j2: (0 - M), (0 - N), (0 - N)
    for i in range(M - 2, -1, -1):
        for j1 in range(N):
            for j2 in range(N):
                max_: float = -math.inf
                curr = grid[i][j1] + grid[i][j2] if j1 != j2 else grid[i][j1]
                for j1_offset in range(-1, 2):
                    for j2_offset in range(-1, 2):
                        if 0 <= j1 + j1_offset < N and 0 <= j2 + j2_offset < N:
                            max_ = max(max_, dp[i + 1][j1 + j1_offset][j2 + j2_offset])

                dp[i][j1][j2] = max(-1, max_ + curr)

    return int(dp[0][0][-1])

# Testing the solution
assert cherryPickupTab([[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]) == 28
```

</div>

<div id="e2fdb650" class="cell code" execution_count="28"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:50.184249Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:50.183825Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:50.190568Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:50.190158Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.3853e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:50.191574&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:50.167721&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def cherryPickupSpaceOptimized(grid: list[list[int]]) -> int:
    M, N = len(grid), len(grid[0])
    dp: list[list[float]] = [[grid[-1][j1] + grid[-1][j2] if j1 != j2 else grid[-1][j1] for j1 in range(N)] for j2 in range(N)]

    for i in range(M - 2, -1, -1):
        dp_next: list[list[float]] = []
        for j1 in range(N):
            dp_next.append([])
            for j2 in range(N):
                max_: float = -math.inf
                curr = grid[i][j1] + grid[i][j2] if j1 != j2 else grid[i][j1]
                for j1_offset in range(-1, 2):
                    for j2_offset in range(-1, 2):
                        if 0 <= j1 + j1_offset < N and 0 <= j2 + j2_offset < N:
                            max_ = max(max_, dp[j1 + j1_offset][j2 + j2_offset])

                dp_next[j1].append(curr + max_)
        dp = dp_next

    return int(dp[0][-1])

# Testing the solution
assert cherryPickupSpaceOptimized([[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]) == 28
```

</div>

<div id="17816765" class="cell markdown"
papermill="{&quot;duration&quot;:1.5501e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:50.222786&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:50.207285&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Subset sum equals target Video Link:
<https://youtu.be/fWX9xDmIzRI?si=jb2Tgvw_E0Tyk1Pj>

</div>

<div id="4f37d7b7" class="cell code" execution_count="29"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:50.255043Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:50.254787Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:50.259869Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:50.259359Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2255e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:50.260861&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:50.238606&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def isSubsetSumMemo(N: int, arr: list[int], target: int) -> int:
    """
    For cases where subset exists, the recursion would stop early. For the negative cases, we would get overlapping subproblems and
    hence memoization would help decrease the time complexity.

    Time without memoization: O(2 ^ N), Space: O(N)
    With memoization: O(N x target), Space: O(N x target) + O(N)
    """

    dp: list[list[int]] = [[-1 for j in range(target + 1)] for i in range(N)]
    def backtrack(i: int, total: int) -> bool:
        if total == 0:
            return True
        elif total < 0 or i > N - 1:
            return False
        elif dp[i][total] != -1:
            return bool(dp[i][total])
        else:
            result = backtrack(i + 1, total - arr[i]) or backtrack(i + 1, total)
            dp[i][total] = int(result)
            return result

    return backtrack(0, target)

# Testing the solution
assert isSubsetSumMemo(6, [3, 34, 4, 12, 5, 2], 9) == True
assert isSubsetSumMemo(6, [3, 34, 4, 12, 5, 2], 30) == False
```

</div>

<div id="5551c36b" class="cell code" execution_count="30"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:50.293066Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:50.292707Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:50.298419Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:50.297964Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.3048e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:50.299466&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:50.276418&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def isSubsetSumTab(N: int, arr: list[int], target: int) -> bool:
    """
    Each cell in the dp represents -> If total - arr[i] is true down the line.
    Note that dp[i][0] is always true, since if the target is to be 0 regardless of arr[i] tehn subsetSumTarget is possible.
    """
    dp: list[list[int]] = [[1 if j == 0 else -1 if i < N else 0 for j in range(target + 1)] for i in range(N + 1)]

    for i in range(N - 1, -1, -1):
        for total in range(1, target + 1):
            if dp[i + 1][total] == 1 or (total - arr[i] >= 0 and dp[i + 1][total - arr[i]] == 1):
                dp[i][total] = 1
            else:
                dp[i][total] = 0

    print(dp)
    return bool(dp[0][target])

# Testing the solution
assert isSubsetSumTab(6, [3, 34, 4, 12, 5, 2], 9) == True
assert isSubsetSumTab(6, [3, 34, 4, 12, 5, 2], 30) == False
```

<div class="output stream stdout">

    [[1, 0, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1], [1, 0, 1, 0, 0, 1, 0, 1, 0, 0], [1, 0, 1, 0, 0, 1, 0, 1, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
    [[1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

</div>

</div>

<div id="ca80b369" class="cell code" execution_count="31"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:50.331888Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:50.331691Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:50.336432Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:50.336015Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2066e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:50.337481&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:50.315415&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def isSubsetSumSpaceOptimized(N: int, arr: list[int], target: int) -> bool:
    "Time: O(N x target), Space: O(target)"
    dp: list[int] = [0 if j > 0 else 1 for j in range(target + 1)]

    for i in range(N - 1, -1, -1):
        next_: list[int] = []
        for total in range(target + 1):
            if total == 0 or dp[total] == 1 or (total - arr[i] >= 0 and dp[total - arr[i]] == 1):
                next_.append(1)
            else:
                next_.append(0)

        dp = next_

    return bool(dp[target])

# Testing the solution
assert isSubsetSumSpaceOptimized(6, [3, 34, 4, 12, 5, 2], 9) == True
assert isSubsetSumSpaceOptimized(6, [3, 34, 4, 12, 5, 2], 30) == False
```

</div>

<div id="7a10f4ca" class="cell markdown"
papermill="{&quot;duration&quot;:1.5537e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:50.368896&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:50.353359&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Partition equal subset sum:
<https://leetcode.com/problems/partition-equal-subset-sum/> Video Link:
<https://youtu.be/7win3dcgo3k?si=LJO4Ot4EZzQ2fRc0>

</div>

<div id="373088cf" class="cell code" execution_count="32"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:50.401011Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:50.400694Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:50.405975Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:50.405524Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2466e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:50.407038&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:50.384572&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/partition-equal-subset-sum/submissions/1253314239
def canPartition(nums: list[int]) -> bool:
    def subsetSumEqualsTarget(target: int) -> bool:
        "Time: O(N x target), Space: O(target)"
        dp: list[bool] = [False if i > 0 else True for i in range(target + 1)]
        for i in range(N - 1, -1, -1):
            next_: list[bool] = []
            for total in range(target + 1):
                if total == 0 or dp[total] or (total - nums[i] >= 0 and dp[total - nums[i]]):
                    next_.append(True)
                else:
                    next_.append(False)

            dp = next_

        return dp[target]

    N = len(nums)
    total = sum(nums)
    return total % 2 == 0 and subsetSumEqualsTarget(total // 2)

# Testing the solution
assert canPartition([1,5,11,5]) == True
assert canPartition([1,2,3,5]) == False
assert canPartition([3,3,3,4,5]) == True
```

</div>

<div id="56f6a268" class="cell markdown"
papermill="{&quot;duration&quot;:1.538e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:50.438131&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:50.422751&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Partition Array Into Two Arrays to Minimize Sum Difference Video link:
<https://youtu.be/GS_OqZb2CWc?si=Jtc2dP_dqmNi5Zli>

</div>

<div id="00588c88" class="cell code" execution_count="33"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:50.469984Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:50.469668Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:50.474368Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:50.473952Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.1753e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:50.475394&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:50.453641&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def minimumDifferenceBrute(nums: list[int]) -> int:
    """
    Throws a TLE :(
    """
    N, total_sum = len(nums), sum(nums)
    subset_length = N // 2

    @functools.cache
    def backtrack(i: int, subset_sum: int, count: int) -> float:
        if count == subset_length:
            return abs(2 * subset_sum - total_sum)
        elif i == N:
            return math.inf
        else:
            return min(backtrack(i + 1, subset_sum + nums[i], count + 1), backtrack(i + 1, subset_sum, count))

    result = int(backtrack(0, 0, 0))
    return result

# Testing the solution
assert minimumDifferenceBrute([3,9,7,3]) == 2
assert minimumDifferenceBrute([-36,36]) == 72
assert minimumDifferenceBrute([2,-1,0,4,-2,-9]) == 0
```

</div>

<div id="97c34ef1" class="cell code" execution_count="34"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:50.507843Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:50.507493Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:50.514230Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:50.513812Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.408e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:50.515272&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:50.491192&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def minimumDifference(nums: list[int]) -> int:
    """
    Use the DP tabulation approach we used to check if a subset with target sum exists. Still Memory limit exceeded.
    Note that this is different the one on the video. This solution is leetcode specific. In the video by Striver, the values can only be positive. Further more we can split into any size.
    In LC however, the subset must be split into 2 halves, values can be both positive and negative.
    """

    N, total_abs_sum, total_sum = len(nums), sum(map(abs, nums)), sum(nums)

    # Each value represents the length of subset summing up to target. -1 if cannot be reached.
    dp: list[int] = [-1 if j != 0 else 0 for j in range(-total_abs_sum, total_abs_sum + 1)]

    for i in range(N - 1, -1, -1):
        next_dp: list[int] = []
        for target in range(-total_abs_sum, total_abs_sum + 1):
            # Pick, subset length incremented by 1
            if 0 <= target - nums[i] + total_abs_sum <= 2 * total_abs_sum and dp[target - nums[i] + total_abs_sum] != -1:
                subset_length = dp[target - nums[i] + total_abs_sum] + 1
                existing_length = dp[target + total_abs_sum]
                next_dp.append(subset_length if existing_length != N // 2 else existing_length)
            # No pick, hence subset length is unupdated
            elif dp[target + total_abs_sum] != -1:
                next_dp.append(dp[target + total_abs_sum])
            # Base case
            elif target == 0:
                next_dp.append(0)
            # Sum cannot be reached
            else:
                next_dp.append(-1)

        dp = next_dp

    # Find out targets where value is N // 2
    min_diff: float = math.inf
    for subset_sum, subset_length in enumerate(dp, start=-total_abs_sum):
        if subset_length == N // 2:
            min_diff = min(min_diff, abs(2 * subset_sum - total_sum))

    return int(min_diff)

# Testing the solution
assert minimumDifference([3,9,7,3]) == 2
assert minimumDifference([-36,36]) == 72
assert minimumDifference([2,-1,0,4,-2,-9]) == 0
```

</div>

<div id="54752ee1" class="cell code" execution_count="35"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:50.547351Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:50.547154Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:50.552281Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:50.551815Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2185e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:50.553306&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:50.531121&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def minSubsetSumDifference(arr: list[int], N: int) -> int:
    # Compute max total sum
    total_sum: int = sum(arr)

    # Compute DP grid for all possible subset sums
    dp: list[bool] = [False if i > 0 else True for i in range(total_sum + 1)]
    for i in range(N - 1, -1, -1):
        next_dp: list[bool] = []
        for target in range(total_sum + 1):
            if target == 0 or dp[target] or (target - arr[i] >= 0 and dp[target - arr[i]]):
                next_dp.append(True)
            else:
                next_dp.append(False)
        dp = next_dp

    # Compute the minimum subset difference
    min_diff: int = total_sum

    # total_sum / 2 since it is enough if we computed one half, diff of sum from total sum would cover the other half as well
    for target in range(math.ceil(total_sum / 2) + 1):
        if dp[target]:
            min_diff = min(min_diff, abs(2 * target - total_sum))

    return min_diff

# Testing the solution
assert minSubsetSumDifference([8,6,5], 3) == 3
```

</div>

<div id="884d535e" class="cell markdown"
papermill="{&quot;duration&quot;:1.5437e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:50.584232&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:50.568795&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Count subsets with sum k

</div>

<div id="534b55bb" class="cell code" execution_count="36"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:50.616111Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:50.615911Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:50.621600Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:50.621169Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2871e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:50.622632&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:50.599761&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def perfectSumMemo(nums: list[int], N: int, K: int):
    """
    Time: O(N * K) + O(N); Space: O(N * K)
    """

    # Filter out all the zeros
    arr: list[int] = []
    N = zero_count = 0
    for n in nums:
        if n > 0:
            arr.append(n)
            N += 1
        else:
            zero_count += 1

    # Compute the results and store it to a list
    dp: list[list[int]] = [[-1 for j in range(K + 1)] for i in range(N)]

    # Recursively find the solution
    def backtrack(i: int, total: int) -> int:
        if total == K:
            return 1
        elif i >= N or total > K:
            return 0
        elif dp[i][total] != -1:
            return dp[i][total]
        else:
            result = backtrack(i + 1, total + arr[i]) + backtrack(i + 1, total)
            dp[i][total] = result
            return result

    return backtrack(0, 0) * (2 ** zero_count)

# Testing the solution
assert perfectSumMemo([5, 2, 3, 10, 6, 8], 6, 10) == 3
assert perfectSumMemo([1, 0], 2, 1) == 2
```

</div>

<div id="dee4da2c" class="cell code" execution_count="37"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:50.655026Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:50.654601Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:50.660184Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:50.659747Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2828e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:50.661265&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:50.638437&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def perfectSumTabulation(nums: list[int], N: int, K: int):
    # Filter out all the zeros
    arr: list[int] = []
    N = zero_count = 0
    for n in nums:
        if n > 0:
            arr.append(n)
            N += 1
        else:
            zero_count += 1

    # Initialize a DP array
    dp: list[list[int]] = [[-1 if j < K else 1 for j in range(K + 1)] for i in range(N)]
    dp.append([0 if j < K else 1 for j in range(K + 1)])

    # Traverse through grid
    for i in range(N - 1, -1, -1):
        for total in range(K):
            dp[i][total] = dp[i + 1][total]
            if total + arr[i] <= K:
                dp[i][total] += dp[i + 1][total + arr[i]]

    return dp[0][0] * (2 ** zero_count)

# Testing the solution
assert perfectSumTabulation([5, 2, 3, 10, 6, 8], 6, 10) == 3
assert perfectSumTabulation([1, 0], 2, 1) == 2
```

</div>

<div id="2d2468ad" class="cell code" execution_count="38"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:50.693113Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:50.692908Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:50.697869Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:50.697431Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2091e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:50.698931&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:50.676840&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def perfectSum(nums: list[int], N: int, K: int):
    # Filter out all the zeros
    arr: list[int] = []
    N = zero_count = 0
    for n in nums:
        if n > 0:
            arr.append(n)
            N += 1
        else:
            zero_count += 1

    # Initialize a DP array
    dp: list[int] = [0 if j < K else 1 for j in range(K + 1)]

    # Traverse through grid
    for i in range(N - 1, -1, -1):
        next_dp: list[int] = []
        for total in range(K + 1):
            next_dp.append(dp[total])
            if total + arr[i] <= K:
                next_dp[-1] += dp[total + arr[i]]

        dp = next_dp

    return dp[0] * (2 ** zero_count)

# Testing the solution
assert perfectSum([5, 2, 3, 10, 6, 8], 6, 10) == 3
assert perfectSum([1, 0], 2, 1) == 2
```

</div>

<div id="2bff8c7f" class="cell markdown"
papermill="{&quot;duration&quot;:1.5836e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:50.730462&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:50.714626&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Count Paritions with given difference:
<https://youtu.be/zoilQD1kYSg?si=F8PFSkzkZXEsFJ2N>

</div>

<div id="051bd113" class="cell code" execution_count="39"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:50.763236Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:50.762695Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:50.767875Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:50.767363Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2804e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:50.768896&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:50.746092&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def countPartitionsMemo(N: int, diff: int, arr: list[int]) -> int:
    """
    s1 + s2 = S
    s1 - s2 = d
    2 * s1 = S + d

    Time: O(N x target) + O(N)
    Space: O(N x target)
    """

    # Simply check if the target exists
    target = (sum(arr) + diff) / 2

    # Count all subset sums equals target
    @functools.cache
    def backtrack(i: int, total: int) -> int:
        if i == N:
            return total == target
        elif total > target:
            return 0
        else:
            return backtrack(i + 1, total + arr[i]) + backtrack(i + 1, total)

    result = backtrack(0, 0) if target == int(target) else 0
    MOD = int(1e9 + 7)
    return result % MOD

# Testing the solution
assert countPartitionsMemo(4, 0, [1,1,1,1]) == 6
assert countPartitionsMemo(4, 3, [5,2,6,4]) == 1
assert countPartitionsMemo(5, 5, [1,3,3,2,1]) == 0
```

</div>

<div id="4cd9fbc1" class="cell code" execution_count="40"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:50.802147Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:50.801662Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:50.807451Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:50.806931Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.3766e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:50.808576&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:50.784810&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def countPartitionsTabulation(N: int, diff: int, arr: list[int]) -> int:
    """
    Time: O(N x target), Space: O(N x target)
    """
    # Simply check if the target exists
    target_: float = (sum(arr) + diff) / 2
    MOD = int(1e9 + 7)

    if int(target_) != target_:
        return 0

    else:

        # Convert to int for typing support
        target = int(target_)

        # Initialize DP array for tabulation
        dp: list[list[int]] = [[0 if j != target or i != N else 1 for j in range(target + 1)] for i in range(N + 1)]

        # Iterate through DP and find the solution
        for i in range(N - 1, -1, -1):
            for total in range(target + 1):
                dp[i][total] = dp[i + 1][total]
                if total + arr[i] <= target:
                    dp[i][total] += dp[i + 1][total + arr[i]]

        return dp[0][0]

# Testing the solution
assert countPartitionsTabulation(4, 3, [5,2,6,4]) == 1
assert countPartitionsTabulation(4, 3, [5,2,6,4]) == 1
assert countPartitionsTabulation(5, 5, [1,3,3,2,1]) == 0
```

</div>

<div id="09aacbe5" class="cell code" execution_count="41"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:50.842148Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:50.841692Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:50.847322Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:50.846797Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.366e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:50.848490&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:50.824830&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def countPartitions(N: int, diff: int, arr: list[int]) -> int:
    # Simply check if the target exists
    target_: float = (sum(arr) + diff) / 2
    MOD = int(1e9 + 7)

    if int(target_) != target_:
        return 0

    else:
        # Convert to int for type hinting
        target = int(target_)

        # Create a 1D grid (space optimized)
        dp: list[int] = [0 if j != target else 1 for j in range(target + 1)]

        # Iterate through DP
        for i in range(N - 1, -1, -1):
            next_dp: list[int] = []
            for total in range(target + 1):
                next_dp.append(dp[total])
                if total + arr[i] <= target:
                    next_dp[-1] += dp[total + arr[i]]

            dp = next_dp

        return dp[0] % MOD

# Testing the solution
assert countPartitions(4, 3, [5,2,6,4]) == 1
assert countPartitions(4, 3, [5,2,6,4]) == 1
assert countPartitions(5, 5, [1,3,3,2,1]) == 0
```

</div>

<div id="db7bdbb0" class="cell markdown"
papermill="{&quot;duration&quot;:1.6027e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:50.880660&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:50.864633&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video Link: <https://youtu.be/GqOmJHQZivw?si=dHaZZvKQa2PHaukO> 0/1
Knapsack

</div>

<div id="51fdc55d" class="cell code" execution_count="42"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:50.913871Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:50.913351Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:50.918866Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:50.918422Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.3526e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:50.919923&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:50.896397&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def knapsack01Memo(N: int, max_weight: int, weights: list[int], values: list[int]) -> int:
    """
    Time complexity without memoization: O(2 ** N), Space: O(N).
    Post memoization: O(N x max_weight), Space: O(N x max_weight)
    """
    @functools.cache
    def backtrack(i: int, total_weight: int) -> float:
        """
        Intuition: Till index i, what is the max value, we can accumulate with max_weight as total_weight.
        """
        if total_weight > max_weight:
            return -math.inf
        elif i >= N:
            return 0
        else:
            pick = values[i] + backtrack(i + 1, total_weight + weights[i])
            nopick = backtrack(i + 1, total_weight)
            return max(pick, nopick)

    result = backtrack(0, 0)
    return int(max(result, 0))

# Testing the solution
assert knapsack01Memo(4, 5, [1,2,4,5], [5,4,8,6]) == 13
assert knapsack01Memo(3, 8, [3,4,5], [30,50,60]) == 90
```

</div>

<div id="e0b05d00" class="cell code" execution_count="43"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:50.953949Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:50.953574Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:50.958855Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:50.958385Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.3583e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:50.959956&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:50.936373&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def knapsack01Tabulation(N: int, max_weight: int, weights: list[int], values: list[int]) -> int:
    dp: list[list[int]] = [[-1 if i < N else 0 for j in range(max_weight + 1)] for i in range(N + 1)]
    for i in range(N - 1, -1, -1):
        for total_weight in range(max_weight + 1):
            # No pick
            dp[i][total_weight] = dp[i + 1][total_weight]

            # Pick
            if total_weight + weights[i] <= max_weight:
                dp[i][total_weight] = max(dp[i][total_weight], values[i] + dp[i + 1][total_weight + weights[i]])

    return dp[0][0]

# Testing the solution
assert knapsack01Tabulation(4, 5, [1,2,4,5], [5,4,8,6]) == 13
assert knapsack01Tabulation(3, 8, [3,4,5], [30,50,60]) == 90
```

</div>

<div id="045af9de" class="cell code" execution_count="44"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:50.993433Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:50.992901Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:50.997952Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:50.997508Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2898e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:50.998997&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:50.976099&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def knapsack01SpaceOptimized(N: int, max_weight: int, weights: list[int], values: list[int]) -> int:
    dp: list[int] = [0 for j in range(max_weight + 1)]
    for i in range(N - 1, -1, -1):
        next_dp: list[int] = []
        for total_weight in range(max_weight + 1):
            next_dp.append(dp[total_weight]) # No pick
            if weights[i] + total_weight <= max_weight:
                next_dp[-1] = max(next_dp[-1], values[i] + dp[weights[i] + total_weight]) # Pick
        dp = next_dp

    return dp[0]

# Testing the solution
assert knapsack01SpaceOptimized(4, 5, [1,2,4,5], [5,4,8,6]) == 13
assert knapsack01SpaceOptimized(3, 8, [3,4,5], [30,50,60]) == 90
```

</div>

<div id="b6d1c8d2" class="cell code" execution_count="45"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:51.031759Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:51.031296Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:51.036524Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:51.035988Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2663e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:51.037577&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:51.014914&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def knapsack01(N: int, max_weight: int, weights: list[int], values: list[int]) -> int:
    """
    Space optimization to use just a single row. This is possible because
    in the inner loop we are moving from the left to right and at each iteration
    we are using the element to the right, we have no need of the element to the left

    [x . . . . . . * . . . ]
    [. x . . . * . . . . . ]
    [. . x . . . . . * . . ]

    At the inner loop we had required the value of the element to the left, this would not have been possible.
    """
    dp: list[int] = [0 for j in range(max_weight + 1)]
    for i in range(N - 1, -1, -1):
        for total_weight in range(max_weight + 1):
            if weights[i] + total_weight <= max_weight:
                dp[total_weight] = max(dp[total_weight], values[i] + dp[total_weight + weights[i]])

    return dp[0]

# Testing the solution
assert knapsack01(4, 5, [1,2,4,5], [5,4,8,6]) == 13
assert knapsack01(3, 8, [3,4,5], [30,50,60]) == 90
```

</div>

<div id="71d6293a" class="cell markdown"
papermill="{&quot;duration&quot;:1.6025e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:51.069630&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:51.053605&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video link: <https://youtu.be/myPeWb3Y68A?si=9z1QMQXCYmEcFEW4> Coin
Change:
<https://leetcode.com/problems/coin-change/submissions/1255049748>
Logic: Whenever there is an infinite / unlimited supply, not_take would
update the index, <br> take would not update index - it would stay where
it is because we might end up picking it more than once

</div>

<div id="93a2c45e" class="cell code" execution_count="46"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:51.102897Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:51.102293Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:51.107415Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:51.106914Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2768e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:51.108484&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:51.085716&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def coinChangeMemoization(coins: list[int], amount: int) -> int:
    """
    Without memoization, the time complexity is roughly 2 ** N. It would be greater than
    2 ** N since at each index for take we are still staying at the same index.

    With memoization, the time complexity is O(N x amount)
    """
    @functools.cache
    def backtrack(i: int, total: int) -> float:
        if total == amount:
            return 0
        elif i == N or total > amount:
            return math.inf
        else:
            return min(1 + backtrack(i, total + coins[i]), backtrack(i + 1, total))

    N = len(coins)
    result = backtrack(0, 0)
    return int(result) if not math.isinf(result) else -1

# Testing the solution
assert coinChangeMemoization([1,2,5], 11) == 3
assert coinChangeMemoization([2], 3) == -1
```

</div>

<div id="eb1b662f" class="cell code" execution_count="47"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:51.141533Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:51.141124Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:51.146425Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:51.145972Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2993e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:51.147507&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:51.124514&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def coinChangeTabulation(coins: list[int], amount: int) -> int:
    N = len(coins)
    dp: list[list[float]] = [[math.inf if j < amount else 0 for j in range(amount + 1)] for i in range(N + 1)]
    for i in range(N - 1, -1, -1):
        for total in range(amount, -1, -1):
            if total + coins[i] <= amount:
                dp[i][total] = min(dp[i + 1][total], 1 + dp[i][total + coins[i]])
            else:
                dp[i][total] = dp[i + 1][total]

    result = dp[0][0]
    return int(result) if not math.isinf(result) else -1

# Testing the solution
assert coinChangeTabulation([1,2,5], 11) == 3
assert coinChangeTabulation([2], 3) == -1
```

</div>

<div id="ddd554c7" class="cell code" execution_count="48"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:51.180844Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:51.180345Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:51.185188Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:51.184661Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2656e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:51.186347&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:51.163691&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def coinChangeSpaceOptimized(coins: list[int], amount: int) -> int:
    N = len(coins)
    dp: list[float] = [math.inf if j < amount else 0 for j in range(amount + 1)]
    for i in range(N - 1, -1, -1):
        for total in range(amount, -1, -1):
            if total + coins[i] <= amount:
                dp[total] = min(dp[total], 1 + dp[total + coins[i]])

    result = dp[0]
    return int(result) if not math.isinf(result) else -1

# Testing the solution
assert coinChangeSpaceOptimized([1,2,5], 11) == 3
assert coinChangeSpaceOptimized([2], 3) == -1
```

</div>

<div id="3e5fb6cb" class="cell markdown"
papermill="{&quot;duration&quot;:1.5647e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:51.218135&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:51.202488&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video Link: <https://youtu.be/b3GD8263-PQ?si=CNz-raf3oynQQsPJ> Target
Sum: <https://leetcode.com/problems/target-sum/>

</div>

<div id="18960ee2" class="cell code" execution_count="49"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:51.250886Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:51.250416Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:51.254781Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:51.254268Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.1946e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:51.255819&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:51.233873&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/target-sum/submissions/1255976702
def findTargetSumWaysMemo(nums: list[int], target: int) -> int:
    @functools.cache
    def backtrack(i: int, total: int) -> int:
        if i == N:
            return int(total == target)
        else:
            return backtrack(i + 1, total - nums[i]) + backtrack(i + 1, total + nums[i])

    N = len(nums)
    return backtrack(0, 0)

# Testing the solution
assert findTargetSumWaysMemo([1,1,1,1,1], 3) == 5
assert findTargetSumWaysMemo([1], 2) == 0
```

</div>

<div id="8420cf7b" class="cell code" execution_count="50"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:51.288414Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:51.288036Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:51.293530Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:51.292997Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.3059e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:51.294625&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:51.271566&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def findTargetSumWaysTab(nums: list[int], target: int) -> int:
    N: int = len(nums)
    boundary: int = sum(nums)
    dp: list[list[int]] = [[0 if i < N or j != target else 1 for j in range(-boundary, boundary + 1)] for i in range(N + 1)]

    for i in range(N - 1, -1, -1):
        for total in range(-boundary, boundary + 1):
            if total - nums[i] + boundary >= 0:
                dp[i][total + boundary] += dp[i + 1][total - nums[i] + boundary]
            if total + nums[i] + boundary <= 2 * boundary:
                dp[i][total + boundary] += dp[i + 1][total + nums[i] + boundary]

    return dp[0][boundary]

# Testing the solution
assert findTargetSumWaysTab([1,1,1,1,1], 3) == 5
assert findTargetSumWaysTab([1], 2) == 0
```

</div>

<div id="7c66396e" class="cell code" execution_count="51"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:51.327333Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:51.326953Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:51.332149Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:51.331705Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2858e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:51.333192&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:51.310334&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/target-sum/submissions/1255976333/
def findTargetSumWays(nums: list[int], target: int) -> int:
    N = len(nums)
    boundary: int = sum(nums)
    dp: list[int] = [0 if j != target else 1 for j in range(-boundary, boundary + 1)]

    for i in range(N - 1, -1, -1):
        next_dp: list[int] = []
        for total in range(-boundary, boundary + 1):
            next_dp.append(0)
            if total + nums[i] + boundary <= 2 * boundary:
                next_dp[-1] += dp[total + nums[i] + boundary]
            if total - nums[i] + boundary >= 0:
                next_dp[-1] += dp[total - nums[i] + boundary]

        dp = next_dp

    return dp[boundary]

# Testing the solution
assert findTargetSumWays([1,1,1,1,1], 3) == 5
assert findTargetSumWays([1], 2) == 0
```

</div>

<div id="8f0e96f1" class="cell code" execution_count="52"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:51.366597Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:51.366078Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:51.372621Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:51.372078Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.4509e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:51.373797&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:51.349288&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Striver's approach: Use logic from 'Count Paritions with given difference'
# https://leetcode.com/problems/target-sum/submissions/1255993345/
def findTargetSumWaysStriver(nums: list[int], target: int) -> int:
    """
    We need to count the number of subsets s1, s2 such that s1 - s2 = target.
    s1 = (S + d) / 2
    """

    S = sum(nums)
    s1 = (S + target) / 2
    s2 = S - s1

    # Edge case - target is negative.
    if s1 < 0:
        s1 = s2

    count = 0
    if int(s1) == s1:
        s1 = int(s1)
        zero_count = nums.count(0)
        nums = list(filter(lambda x: x != 0, nums))
        N = len(nums)
        dp: list[int] = [0 if j < s1 else 1 for j in range(s1 + 1)]
        for i in range(N - 1, -1, -1):
            for total in range(s1 + 1):
                if total + nums[i] <= s1:
                    dp[total] += dp[total + nums[i]]

        count = dp[0] * (2 ** zero_count)

    return count

# Testing the solution
assert findTargetSumWaysStriver([1,1,1,1,1], 3) == 5
assert findTargetSumWaysStriver([1,0,0], 1) == 4
assert findTargetSumWaysStriver([100], -200) == 0
assert findTargetSumWaysStriver([100], -100) == 1
```

</div>

<div id="54ee6894" class="cell markdown"
papermill="{&quot;duration&quot;:1.6739e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:51.408642&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:51.391903&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video link: <https://youtu.be/HgyouUi11zk?si=tgZcsIOYwWogacGr> Coin
Change II: <https://leetcode.com/problems/coin-change-ii/description/>

</div>

<div id="a21ca5a5" class="cell code" execution_count="53"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:51.441690Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:51.441152Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:51.445532Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:51.445068Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2176e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:51.446614&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:51.424438&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def coinChangeMemo(amount: int, coins: list[int]):
    """
    Time: ~O(N x amount), Space: O(N x amount) + O(amount)
    """

    @functools.cache
    def backtrack(i: int, total: int) -> int:
        if total == amount:
            return 1
        elif total > amount or i == N:
            return 0
        else:
            return backtrack(i, total + coins[i]) + backtrack(i + 1, total)

    N = len(coins)
    return backtrack(0, 0)

# Testing the solution
assert coinChangeMemo(5, [1,2,5]) == 4
assert coinChangeMemo(3, [2]) == 0
```

</div>

<div id="b74d7fa9" class="cell code" execution_count="54"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:51.479851Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:51.479420Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:51.483927Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:51.483458Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.233e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:51.484933&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:51.462603&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/coin-change-ii/submissions/1256028931
def coinChangeTab(amount: int, coins: list[int]):
    N = len(coins)
    dp: list[int] = [0 if j != amount else 1 for j in range(amount + 1)]
    for i in range(N - 1, -1, -1):
        for total in range(amount, -1, -1):
            if total + coins[i] <= amount:
                dp[total] += dp[total + coins[i]]

    return dp[0]

# Testing the solution
assert coinChangeTab(5, [1,2,5]) == 4
assert coinChangeTab(3, [2]) == 0
```

</div>

<div id="b0b593c4" class="cell markdown"
papermill="{&quot;duration&quot;:1.5899e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:51.517184&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:51.501285&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video Link: <https://youtu.be/OgvOZ6OrJoY?si=rcbpx6IrU_SvQ4v1> Unbounded
Knapsack

</div>

<div id="5fc22211" class="cell code" execution_count="55"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:51.550279Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:51.549790Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:51.554450Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:51.554029Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2551e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:51.555525&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:51.532974&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def unboundedKnapSackMemo(N: int, max_weight: int, values: list[int], weights: list[int]) -> int:
     @functools.cache
     def backtrack(i: int, total_weight: int) -> float:
         if total_weight > max_weight:
             return -math.inf
         elif i == N:
             return 0
         else:
             return max(values[i] + backtrack(i, total_weight + weights[i]), backtrack(i + 1, total_weight))

     return int(backtrack(0, 0))

# Testing the solution
assert unboundedKnapSackMemo(2, 3, [1, 1], [2, 1]) == 3
assert unboundedKnapSackMemo(4, 8, [6, 1, 7, 7], [1, 3, 4, 5]) == 48
```

</div>

<div id="3377312f" class="cell code" execution_count="56"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:51.588888Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:51.588449Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:51.593291Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:51.592729Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2699e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:51.594402&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:51.571703&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def unboundedKnapSackTab(N: int, max_weight: int, values: list[int], weights: list[int]) -> int:
    dp: list[int] = [0 for j in range(max_weight + 1)]
    for i in range(N - 1, -1, -1):
        for total in range(max_weight, -1, -1):
            if total + weights[i] <= max_weight:
                dp[total] = max(dp[total], values[i] + dp[total + weights[i]])

    return dp[0]

# Testing the solution
assert unboundedKnapSackTab(2, 3, [1, 1], [2, 1]) == 3
assert unboundedKnapSackTab(4, 8, [6, 1, 7, 7], [1, 3, 4, 5]) == 48
```

</div>

<div id="2d0c40ff" class="cell markdown"
papermill="{&quot;duration&quot;:1.5942e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:51.626611&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:51.610669&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video Link: <https://youtu.be/mO8XpGoJwuo?si=uzBPZ8auw70L9WCm> Rod
cutting Problem

</div>

<div id="aee57cd8" class="cell code" execution_count="57"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:51.676729Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:51.676205Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:51.681178Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:51.680698Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2713e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:51.682206&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:51.659493&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def cutRodMemo(price: list[int], N: int) -> int:
    @functools.cache
    def backtrack(i: int, length: int) -> float:
        if length == 0:
            return 0
        elif i == N or length < 0:
            return -math.inf
        else:
            return max(price[i] + backtrack(i, length - i - 1), backtrack(i + 1, length))

    result = backtrack(0, N)
    return int(result)

# Testing the solution
assert cutRodMemo([1, 5, 8, 9, 10, 17, 17, 20], 8) == 22
assert cutRodMemo([3, 5, 8, 9, 10, 17, 17, 20], 8) == 24
```

</div>

<div id="bcdf21dd" class="cell code" execution_count="58"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:51.714999Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:51.714502Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:51.719161Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:51.718698Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2202e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:51.720211&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:51.698009&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def cutRodTab(price: list[int], N: int) -> int:
    dp: list[float] = [-math.inf if j > 0 else 0 for j in range(N + 1)]
    for i in range(N - 1, -1, -1):
        for length in range(N + 1):
            if length - i - 1 >= 0:
                dp[length] = max(dp[length], price[i] + dp[length - i - 1])

    return int(dp[N])

# Testing the solution
assert cutRodTab([1, 5, 8, 9, 10, 17, 17, 20], 8) == 22
assert cutRodTab([3, 5, 8, 9, 10, 17, 17, 20], 8) == 24
```

</div>

<div id="8e8177cc" class="cell markdown"
papermill="{&quot;duration&quot;:1.579e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:51.751905&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:51.736115&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video link: <https://youtu.be/NPZn9jBrX8U?si=RNey3xHjlEm1LXyr> Longest
common subsequences:
<https://leetcode.com/problems/longest-common-subsequence> Naive
approach: Generate all subsequences O((2 \*\* N) x (2 \*\* M)) and
compare common subsequences in both

</div>

<div id="917d5e52" class="cell code" execution_count="59"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:51.784460Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:51.784073Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:51.789120Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:51.788643Z&quot;}"
papermill="{&quot;duration&quot;:2.2632e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:51.790150&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:51.767518&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def longestCommonSubsequenceMemo(text1: str, text2: str) -> int:
    # Time: O(N x M), Space: O(N x M) + O(M + N)
    @functools.cache
    def backtrack(i: int, j: int) -> int:
        if i == N1 or j == N2:
            return 0
        elif text1[i] == text2[j]:
            return 1 + backtrack(i + 1, j + 1)
        else:
            return max(backtrack(i + 1, j), backtrack(i, j + 1))

    N1, N2 = len(text1), len(text2)
    return backtrack(0, 0)

# Testing the solution
assert longestCommonSubsequenceMemo("abcde", "ace") == 3
assert longestCommonSubsequenceMemo("bsbininm", "jmjkbkjkv") == 1
assert longestCommonSubsequenceMemo("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa") == 35
assert longestCommonSubsequenceMemo("bl", "yby") == 1
```

</div>

<div id="30813726" class="cell code" execution_count="60"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:51.823289Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:51.822818Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:51.828112Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:51.827641Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2912e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:51.829230&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:51.806318&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def longestCommonSubsequenceTab(text1: str, text2: str) -> int:
    # Time: O(M x N), Space: O(N x M)
    N1, N2 = len(text1), len(text2)
    dp: list[list[int]] = [[0 for j in range(N2 + 1)] for i in range(N1 + 1)]
    for i in range(N1 - 1, -1, -1):
        for j in range(N2 - 1, -1, -1):
            if text1[i] == text2[j]:
                dp[i][j] = 1 + dp[i + 1][j + 1]
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j + 1])

    return dp[0][0]

# Testing the solution
assert longestCommonSubsequenceTab("abcde", "ace") == 3
assert longestCommonSubsequenceTab("bsbininm", "jmjkbkjkv") == 1
assert longestCommonSubsequenceTab("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa") == 35
assert longestCommonSubsequenceTab("bl", "yby") == 1
```

</div>

<div id="e099ef3b" class="cell code" execution_count="61"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:51.862634Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:51.862200Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:51.867391Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:51.866868Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.3163e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:51.868500&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:51.845337&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/longest-common-subsequence/submissions/1256127917
def longestCommonSubsequence(text1: str, text2: str) -> int:
    # Time: O(M x N), Space: O(N2 + N2)
    N1, N2 = len(text1), len(text2)
    dp: list[int] = [0 for j in range(N2 + 1)]
    for i in range(N1 - 1, -1, -1):
        next_dp: list[int] = list(dp)
        for j in range(N2 - 1, -1, -1):
            if text1[i] == text2[j]:
                next_dp[j] = 1 + dp[j + 1]
            else:
                next_dp[j] = max(dp[j], next_dp[j + 1])

        dp = next_dp

    return dp[0]

# Testing the solution
assert longestCommonSubsequence("abcde", "ace") == 3
assert longestCommonSubsequence("bsbininm", "jmjkbkjkv") == 1
assert longestCommonSubsequence("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa") == 35
assert longestCommonSubsequence("bl", "yby") == 1
```

</div>

<div id="e01786f1" class="cell markdown"
papermill="{&quot;duration&quot;:1.5595e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:51.900195&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:51.884600&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video Link: <https://youtu.be/-zI4mrF2Pb4?si=8kICsv0E7jYx6sWn> Print
longest common subsequece

</div>

<div id="1c0d3fe8" class="cell code" execution_count="62"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:51.932754Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:51.932284Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:51.940074Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:51.939563Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.5345e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:51.941176&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:51.915831&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def all_longest_common_subsequences(text1: str, text2: str) -> list[str]:
    """
    DP grid computes the longest common subseq length given starting pos of text1, text2
    We start at -1, -1 on the grid.
    If text1[i] == text2[j], we know that the line: 1 + dp[i + 1][j + 1] was executed, there we increment both i, j by 1
    If text1[i] != text2[j], either the max came from text1 or text2. If only one max exists, recurse into that else recurse through both

    Time: DP grid compute: O(M x N) + Backtracking to find longest common subsequence: O(M + N)
    Space: O(M x N)
    """

    N1, N2 = len(text1), len(text2)
    dp: list[list[int]] = [[0 for j in range(N2 + 1)] for i in range(N1 + 1)]
    for i in range(N1 - 1, -1, -1):
        for j in range(N2 - 1, -1, -1):
            if text1[i] == text2[j]:
                dp[i][j] = 1 + dp[i + 1][j + 1]
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j + 1])

    def backtrack(i: int, j: int):
        if dp[i][j] == 0:
            result.add(''.join(stack))
            return
        elif text1[i] == text2[j]:
            stack.append(text1[i])
            backtrack(i + 1, j + 1)
            stack.pop()
        else:
            max_ = max(dp[i + 1][j], dp[i][j + 1])
            if dp[i + 1][j] == max_:
                backtrack(i + 1, j)
            if dp[i][j + 1] == max_:
                backtrack(i, j + 1)

    result: set[str] = set()
    stack: list[str] = []
    backtrack(i, j)
    return sorted(result)

# Tesitng the solution
assert all_longest_common_subsequences("abcde", "ace") == ['ace']
assert all_longest_common_subsequences("abaaa", "baabaca") == ['aaaa', 'abaa', 'baaa']
```

</div>

<div id="1b3c52ec" class="cell markdown"
papermill="{&quot;duration&quot;:1.5908e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:51.973329&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:51.957421&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video Link: <https://youtu.be/_wP9mWNPL5w?si=UHRuFgDl6a5g8OlH> Longest
common Substring

</div>

<div id="95b817c0" class="cell code" execution_count="63"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:52.006135Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:52.005655Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:52.010581Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:52.010139Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2566e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:52.011656&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:51.989090&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def longestCommonSubstrTab(text1: str, text2: str) -> int:
    """
    Same code as longest common subsequence but with a slight modification.
    Here we reset the dp table value to 0 if text1[i] != text2[j] instead of getting the max of dp[i + 1][j] or dp[i][j + 1] since we are not allowed non consequetive values.

    Time: O(N1 x N2), Space: O(N1 x N2)
    """
    N1, N2 = len(text1), len(text2)
    dp: list[list[int]] = [[0 for j in range(N2 + 1)] for i in range(N1 + 1)]
    max_length = 0
    for i in range(N1 - 1, -1, -1):
        for j in range(N2 - 1, -1, -1):
            if text1[i] == text2[j]:
                dp[i][j] = dp[i + 1][j + 1] + 1
                max_length = max(max_length, dp[i][j])

    return max_length

# Testing the solution
assert longestCommonSubstrTab("ABCDGH", "ACDGHR") == 4
assert longestCommonSubstrTab("ABC", "ACB") == 1
```

</div>

<div id="f32221a7" class="cell code" execution_count="64"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:52.044159Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:52.043946Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:52.048725Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:52.048282Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2248e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:52.049796&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:52.027548&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def longestCommonSubstr(text1: str, text2: str) -> int:
    """Time: O(N1 x N2), Space: O(N2)"""
    N1, N2 = len(text1), len(text2)
    dp: list[int] = [0 for j in range(N2 + 1)]
    max_length = 0
    for i in range(N1 - 1, -1, -1):
        next_dp: list[int] = [0]
        for j in range(N2 - 1, -1, -1):
            if text1[i] == text2[j]:
                next_dp.append(1 + dp[j + 1])
                max_length = max(max_length, next_dp[-1])
            else:
                next_dp.append(0)

        dp = list(reversed(next_dp))

    return max_length

# Testing the solution
assert longestCommonSubstr("ABCDGH", "ACDGHR") == 4
assert longestCommonSubstr("ABC", "ACB") == 1
```

</div>

<div id="32bd7ea7" class="cell markdown"
papermill="{&quot;duration&quot;:1.5787e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:52.081564&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:52.065777&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video Link: <https://youtu.be/6i_T5kkfv4A?si=3pJmCMahWgxxnGRq> Longest
Palindromic Subsequence

</div>

<div id="d0a53967" class="cell code" execution_count="65"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:52.114171Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:52.113790Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:52.117993Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:52.117567Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.1776e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:52.119059&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:52.097283&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/longest-palindromic-subsequence/submissions/1256744931
def longestPalindromeSubseqMemo(text: str) -> int:
    @functools.cache
    def backtrack(i: int, j: int) -> int:
        if i >= j:
            return int(i == j)
        elif text[i] == text[j]:
            return 2 + backtrack(i + 1, j - 1)
        else:
            return max(backtrack(i + 1, j), backtrack(i, j - 1))

    N = len(text)
    result = backtrack(0, N - 1)
    return result

# Testing the solution
assert longestPalindromeSubseqMemo("bbbab") == 4
assert longestPalindromeSubseqMemo("cbbd") == 2
```

</div>

<div id="c5612366" class="cell code" execution_count="66"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:52.151188Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:52.150981Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:52.155704Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:52.155290Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.1937e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:52.156761&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:52.134824&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def longestPalindromeSubseqTab(text: str) -> int:
    N = len(text)
    dp: list[list[int]] = [[0 if j != (N - 1) / 2 else 1 for j in range(N + 1)] for i in range(N + 1)]
    for i in range(N - 1, -1, -1):
        for j in range(N):
            if i >= j:
                dp[i][j] = int(i == j)
            elif text[i] == text[j]:
                dp[i][j] = 2 + dp[i + 1][j - 1]
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])

    return dp[0][N - 1]

# Testing the solution
assert longestPalindromeSubseqTab("bbbab") == 4
assert longestPalindromeSubseqTab("cbbd") == 2
```

</div>

<div id="a74fa1d5" class="cell code" execution_count="67"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:52.189821Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:52.189290Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:52.194290Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:52.193869Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2747e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:52.195332&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:52.172585&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/longest-palindromic-subsequence/submissions/1256759252
def longestPalindromeSubseq(text: str) -> int:
    N = len(text)
    dp: list[int] = [0 if j != (N - 1) / 2 else 1 for j in range(N + 1)]
    for i in range(N - 1, -1, -1):
        next_dp: list[int] = []
        for j in range(N):
            if i >= j:
                next_dp.append(int(i == j))
            elif text[i] == text[j]:
                next_dp.append(2 + dp[j - 1])
            else:
                next_dp.append(max(dp[j], next_dp[-1]))

        # We run the inner loop for N iterations, dp however has a length of N + 1
        # Hence we add 0 in the end to make sure that the values are consistent of DP compute
        # We could make this simpler by initializing next_dp as list(dp), but that would
        # be wasted O(N) runtime.
        next_dp.append(0)
        dp = next_dp

    return dp[N - 1]

# Testing the solution
assert longestPalindromeSubseq("bbbab") == 4
assert longestPalindromeSubseq("cbbd") == 2
```

</div>

<div id="e94ba584" class="cell code" execution_count="68"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:52.228838Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:52.228275Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:52.233279Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:52.232816Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.3041e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:52.234370&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:52.211329&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def longestPalindromeSubseqStriver(text: str) -> int:
    """
    1. We reverse text.
    2. Whatever value is the LCS of both the texts, that is our desired answer
    """
    def LCS(text1: str, text2: str) -> int:
        N = len(text1)
        dp: list[int] = [0 for j in range(N + 1)]
        for i in range(N - 1, -1, -1):
            next_dp: list[int] = list(dp)
            for j in range(N - 1, -1, -1):
                if text1[i] == text2[j]:
                    next_dp[j] = 1 + dp[j + 1]
                else:
                    next_dp[j] = max(dp[j], next_dp[j + 1])
            dp = next_dp

        return dp[0]

    return LCS(text, text[::-1])

# Testing the solution
assert longestPalindromeSubseqStriver("bbbab") == 4
assert longestPalindromeSubseqStriver("cbbd") == 2
```

</div>

<div id="5a62593a" class="cell code" execution_count="69"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:52.268300Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:52.267739Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:52.270467Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:52.270043Z&quot;}"
papermill="{&quot;duration&quot;:2.0943e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:52.271518&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:52.250575&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Video link: https://youtu.be/xPBLEj41rFU?si=TkaEwZIQqY7WkasB
# Minimum insertions to make a string palindromic
```

</div>

<div id="a73343a1" class="cell code" execution_count="70"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:52.304331Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:52.303974Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:52.308339Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:52.307927Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.1989e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:52.309383&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:52.287394&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/submissions/1256992480/
def minInsertions(text: str) -> int:
    """
    1. Find the longest palindromic substring
    2. Minimum insertions required would be length of the N - longest palindromic substr
    """

    @functools.cache
    def longestPalindromicSubstrLength(i: int, j: int) -> int:
        if i >= j:
            return int(i == j)
        elif text[i] == text[j]:
            return 2 + longestPalindromicSubstrLength(i + 1, j - 1)
        else:
            return max(longestPalindromicSubstrLength(i + 1, j), longestPalindromicSubstrLength(i, j - 1))

    N = len(text)
    return N - longestPalindromicSubstrLength(0, N - 1)

# Testing the solution
assert minInsertions("mbadm") == 2
assert minInsertions("leetcode") == 5
```

</div>

<div id="76604d02" class="cell markdown"
papermill="{&quot;duration&quot;:1.5705e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:52.340958&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:52.325253&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Minimum ops to convert s1 to s2 Video Link:
<https://youtu.be/yMnH0jrir0Q?si=WNsLNkqd3rhHqzDX>

</div>

<div id="07d4a7a1" class="cell code" execution_count="71"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:52.374030Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:52.373573Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:52.380265Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:52.379830Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.4449e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:52.381380&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:52.356931&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/delete-operation-for-two-strings/submissions/1257015539
def minDistance(word1: str, word2: str) -> int:
    """
    The idea is to think about what characters we should leave untouched. In this
    case, we can leave out characters that are subsequences also present in word2.o

    Hence logic: Find length of longest common subsequence -> (N1 - S) + (N2 - S)
    """
    N1, N2 = len(word1), len(word2)
    dp: list[int] = [0 for j in range(N2 + 1)]
    for i in range(N1 - 1, -1, -1):
        next_dp: list[int] = [0]
        for j in range(N2 - 1, -1, -1):
            if word1[i] == word2[j]:
                next_dp.append(1 + dp[j + 1])
            else:
                next_dp.append(max(dp[j], next_dp[-1]))

        next_dp.reverse()
        dp = next_dp

    substr_length = dp[0]
    return (N1 - substr_length) + (N2 - substr_length)

# Testing the solution
assert minDistance("leetcode", "etco") == 4
assert minDistance("sea", "eat") == 2
```

</div>

<div id="899a0256" class="cell markdown"
papermill="{&quot;duration&quot;:1.5849e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:52.413497&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:52.397648&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Shortest common supersequence:
<https://youtu.be/xElxAuBcvsU?si=A_v7qeegsKrHgGle>
<https://leetcode.com/problems/shortest-common-supersequence/>

</div>

<div id="ddeea61a" class="cell code" execution_count="72"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:52.446262Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:52.445801Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:52.453494Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:52.453014Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.5438e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:52.454557&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:52.429119&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/shortest-common-supersequence/submissions/1257426491
def shortestCommonSupersequenceBetter(str1: str, str2: str) -> str:
    """
    Logic: Common characters should be taken once. Add missing characters in order.
    """
    N1, N2 = len(str1), len(str2)

    # Compute the DP grid for Longest common subsequence
    dp: list[list[int]] = [[0 for j in range(N2 + 1)] for i in range(N1 + 1)]
    for i in range(N1 - 1, -1, -1):
        for j in range(N2 - 1, -1, -1):
            if str1[i] == str2[j]:
                dp[i][j] = 1 + dp[i + 1][j + 1]
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j + 1])

    # Find out the subsequence
    lcs_list: list[str] = []
    i = j = 0
    while i < N1 and j < N2:
        if str1[i] == str2[j]:
            lcs_list.append(str1[i])
            i, j = i + 1, j + 1
        elif dp[i][j + 1] >= dp[i + 1][j]:
            j = j + 1
        else:
            i = i + 1

    # Compute LCS string
    lcs_list.append("*")
    lcs = ''.join(lcs_list)
    N3 = len(lcs)

    # Add the missing characters in order
    i = j = k = 0
    supersequence_list: list[str] = []
    while k < N3:
        while i < N1 and str1[i] != lcs[k]:
            supersequence_list.append(str1[i])
            i += 1
        while j < N2 and str2[j] != lcs[k]:
            supersequence_list.append(str2[j])
            j += 1
        supersequence_list.append(lcs[k])
        i, j, k = i + 1, j + 1, k + 1

    supersequence_list.pop()
    return ''.join(supersequence_list)

# Testing the solution
assert len(shortestCommonSupersequenceBetter("abac", "cab")) == 5
assert len(shortestCommonSupersequenceBetter("brute", "groot")) == 8
```

</div>

<div id="e8a2cfe9" class="cell code" execution_count="73"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:52.488267Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:52.487705Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:52.494310Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:52.493784Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.4633e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:52.495354&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:52.470721&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/shortest-common-supersequence/submissions/1257436090/
def shortestCommonSupersequenceStriver(str1: str, str2: str) -> str:
    """
    Instead of computing the missing characters seperately we add them during out iteration through the DP table itself.
    """
    N1, N2 = len(str1), len(str2)

    # Compute the DP grid for Longest common subsequence
    dp: list[list[int]] = [[0 for j in range(N2 + 1)] for i in range(N1 + 1)]
    for i in range(N1 - 1, -1, -1):
        for j in range(N2 - 1, -1, -1):
            if str1[i] == str2[j]:
                dp[i][j] = 1 + dp[i + 1][j + 1]
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j + 1])

    # Find out the supersequence, slight modification to LCS print code
    # Instead of iterating until any one of the strings going out of bounds, we iterate until both are out of bounds
    # When strings don't match and we go to the direction of maximum in the DP table, we add the string that is being shrunk
    # j = j + 1 code => str2[j] is added other wise str1[i]
    supersequence_list: list[str] = []
    i = j = 0
    while i < N1 or j < N2:
        if i < N1 and j < N2 and str1[i] == str2[j]:
            supersequence_list.append(str1[i])
            i, j = i + 1, j + 1
        elif i >= N1 or (j < N2 and dp[i][j + 1] >= dp[i + 1][j]):
            supersequence_list.append(str2[j])
            j = j + 1
        else:
            supersequence_list.append(str1[i])
            i = i + 1

    return ''.join(supersequence_list)

# Testing the solution
assert len(shortestCommonSupersequenceStriver("abac", "cab")) == 5
assert len(shortestCommonSupersequenceStriver("brute", "groot")) == 8
```

</div>

<div id="2e842207" class="cell markdown"
papermill="{&quot;duration&quot;:1.5928e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:52.527639&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:52.511711&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Number of Distinct Subsequences:
<https://leetcode.com/problems/distinct-subsequences> Video Link:
<https://youtu.be/nVG7eTiD2bY?si=aNNyhjH2VDvfErnT> Naive Time
complexity: Exponential, Space: O(M + N)

</div>

<div id="b80cade8" class="cell code" execution_count="74"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:52.560723Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:52.560196Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:52.564653Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:52.564204Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.22e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:52.565719&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:52.543519&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def numDistinctMemo(s: str, t: str) -> int:
    @functools.cache
    def backtrack(i: int, j: int) -> int:
        if j >= N2:
            return 1
        elif i >= N1:
            return 0
        elif s[i] != t[j]:
            return backtrack(i + 1, j)
        else:
            return backtrack(i + 1, j + 1) + backtrack(i + 1, j)

    N1, N2 = len(s), len(t)
    return backtrack(0, 0)

# Testing the solution
assert numDistinctMemo("babgbag", "bag") == 5
assert numDistinctMemo("rabbbit", "rabbit") == 3
```

</div>

<div id="97af7ce5" class="cell code" execution_count="75"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:52.598692Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:52.598278Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:52.603286Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:52.602831Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2592e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:52.604278&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:52.581686&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def numDistinctTab(s: str, t: str) -> int:
    N1, N2 = len(s), len(t)
    dp: list[list[int]] = [[0 if j < N2 else 1 for j in range(N2 + 1)] for i in range(N1 + 1)]
    for i in range(N1 - 1, -1, -1):
        for j in range(N2 - 1, -1, -1):
            if s[i] != t[j]:
                dp[i][j] = dp[i + 1][j]
            else:
                dp[i][j] = dp[i + 1][j + 1] + dp[i + 1][j]

    return dp[0][0]

# Testing the solution
assert numDistinctTab("babgbag", "bag") == 5
assert numDistinctTab("rabbbit", "rabbit") == 3
```

</div>

<div id="7ac5bcf2" class="cell code" execution_count="76"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:52.637506Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:52.636970Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:52.641887Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:52.641348Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2657e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:52.642915&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:52.620258&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/distinct-subsequences/submissions/1258020441
def numDistinctSpaceOptimized(s: str, t: str) -> int:
    N1, N2 = len(s), len(t)
    dp: list[int] = [0 if j < N2 else 1 for j in range(N2 + 1)]
    for i in range(N1 - 1, -1, -1):
        next_dp: list[int] = [1]
        for j in range(N2 - 1, -1, -1):
            if s[i] != t[j]:
                next_dp.append(dp[j])
            else:
                next_dp.append(dp[j + 1] + dp[j])

        next_dp.reverse()
        dp = next_dp

    return dp[0]

# Testing the solution
assert numDistinctSpaceOptimized("babgbag", "bag") == 5
assert numDistinctSpaceOptimized("rabbbit", "rabbit") == 3
```

</div>

<div id="67fc3008" class="cell code" execution_count="77"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:52.675677Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:52.675126Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:52.679519Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:52.679095Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.1986e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:52.680567&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:52.658581&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/distinct-subsequences/submissions/1258288057
def numDistinct(s: str, t: str) -> int:
    N1, N2 = len(s), len(t)
    dp: list[int] = [0 if j < N2 else 1 for j in range(N2 + 1)]
    for i in range(N1 - 1, -1, -1):
        for j in range(N2):
            if s[i] == t[j]:
                dp[j] += dp[j + 1]

    return dp[0]

# Testing the solution
assert numDistinct("babgbag", "bag") == 5
assert numDistinct("rabbbit", "rabbit") == 3
```

</div>

<div id="88f0f8ed" class="cell markdown"
papermill="{&quot;duration&quot;:1.5638e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:52.712444&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:52.696806&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Edit Distance Video Link:
<https://youtu.be/fJaKO8FbDdo?si=YtaIzd2Iphw_Vrlc> Naive solution time
complexity: O(3 \*\* N x 3 \*\* M), Space: O(M + N)

</div>

<div id="1ece6567" class="cell code" execution_count="78"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:52.745470Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:52.744941Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:52.749967Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:52.749441Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2688e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:52.750974&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:52.728286&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/edit-distance/submissions/1258864387/
def editDistanceMemo(word1: str, word2: str) -> int:
    @functools.cache
    def backtrack(i: int, j: int) -> int:
        if i >= N1 or j >= N2:
            return (N1 - i) + (N2 - j)
        elif word1[i] == word2[j]:
            return backtrack(i + 1, j + 1)
        else:
            delete_op = backtrack(i + 1, j)
            insert_op = backtrack(i, j + 1)
            replace_op = backtrack(i + 1, j + 1)
            return 1 + min(delete_op, insert_op, replace_op)

    N1, N2 = len(word1), len(word2)
    return backtrack(0, 0)

# Testing the solution
assert editDistanceMemo("horse", "ros") == 3
assert editDistanceMemo("intention", "execution") == 5
```

</div>

<div id="a32793d7" class="cell code" execution_count="79"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:52.783570Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:52.783236Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:52.788532Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:52.788080Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2803e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:52.789606&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:52.766803&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def editDistanceTab(word1: str, word2: str) -> int:
    N1, N2 = len(word1), len(word2)
    dp: list[list[int]] = [[(N1 - i) + (N2 - j) if i >= N1 or j >= N2 else 0 for j in range(N2 + 1)] for i in range(N1 + 1)]
    for i in range(N1 - 1, -1, -1):
        for j in range(N2 - 1, -1, -1):
            if word1[i] == word2[j]:
                dp[i][j] = dp[i + 1][j + 1]
            else:
                dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j + 1], dp[i + 1][j + 1])

    return dp[0][0]

# Testing the solution
assert editDistanceTab("horse", "ros") == 3
assert editDistanceTab("intention", "execution") == 5
```

</div>

<div id="5af4af2c" class="cell code" execution_count="80"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:52.823103Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:52.822539Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:52.827906Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:52.827499Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.3311e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:52.828934&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:52.805623&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def editDistanceSpaceOptimized(word1: str, word2: str) -> int:
    N1, N2 = len(word1), len(word2)
    if N1 == 0 or N2 == 0:
        return max(N1, N2)

    else:
        dp: list[int] = [N2 - j for j in range(N2 + 1)]
        for i in range(N1 - 1, -1, -1):
            dp[-1] = N1 - i - 1
            next_dp: list[int] = list(dp)
            for j in range(N2 - 1, -1, -1):
                if word1[i] == word2[j]:
                    next_dp[j] = dp[j + 1]
                else:
                    next_dp[j] = 1 + min(dp[j], dp[j + 1], next_dp[j + 1])

            dp = next_dp

        return dp[0]

# Testing the solution
assert editDistanceSpaceOptimized("horse", "ros") == 3
assert editDistanceSpaceOptimized("intention", "execution") == 5
```

</div>

<div id="06a1202d" class="cell markdown"
papermill="{&quot;duration&quot;:1.5754e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:52.860711&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:52.844957&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video Link: <https://youtu.be/ZmlQ3vgAOMo?si=E_X4r10aFkD_A9Nn> Wildcard
Matching

</div>

<div id="fc9c33aa" class="cell code" execution_count="81"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:52.893538Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:52.893076Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:52.898835Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:52.898303Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.3368e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:52.899891&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:52.876523&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def isMatchMemo(s: str, p: str) -> bool:
    @functools.cache
    def backtrack(i: int, j: int) -> bool:
        if i >= N1 and j >= N2:
            return True
        elif i >= N1 or j >= N2:
            return False
        elif s[i] == p[j] or p[j] == '?':
            return backtrack(i + 1, j + 1)
        elif p[j] == '*':
            # consume s[i] or don't consume s[i]
            return backtrack(i + 1, j) or backtrack(i, j + 1)
        else:
            return False

    s, p = s + '$', p + '$'
    N1, N2 = len(s), len(p)
    return backtrack(0, 0)

# Testing the solution
assert isMatchMemo("d", "*d") == True
assert isMatchMemo("abacd", "*c?") == True
assert isMatchMemo("aa", "*") == True
assert isMatchMemo("cb", "?a") == False
assert isMatchMemo("cb", "?a") == False
assert isMatchMemo("abcabczzzde", "*abc???de*") == True
assert isMatchMemo("aaa", "***a") == True
```

</div>

<div id="66694128" class="cell code" execution_count="82"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:52.933067Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:52.932578Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:52.938349Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:52.937812Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.3584e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:52.939491&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:52.915907&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def isMatchTab(s: str, p: str) -> bool:
    s, p = s + '$', p + '$'
    N1, N2 = len(s), len(p)
    dp: list[list[bool]] = [[True if i >= N1 and j >= N2 else False for j in range(N2 + 1)] for i in range(N1 + 1)]
    for i in range(N1 - 1, -1, -1):
        for j in range(N2 - 1, -1, -1):
            if s[i] == p[j] or p[j] == '?':
                dp[i][j] = dp[i + 1][j + 1]
            elif p[j] == '*':
                dp[i][j] = dp[i + 1][j] or dp[i][j + 1]
            else:
                dp[i][j] = False

    return dp[0][0]

# Testing the solution
assert isMatchTab("abacd", "*c?") == True
assert isMatchTab("abcabczzzde", "*abc???de*") == True
assert isMatchTab("aaa", "***?") == True
```

</div>

<div id="1803ba8d" class="cell code" execution_count="83"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:52.972844Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:52.972453Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:52.977961Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:52.977451Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.3275e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:52.978979&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:52.955704&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/wildcard-matching/submissions/1259222651
def isMatch(s: str, p: str) -> bool:
    s, p = s + '$', p + '$'
    N1, N2 = len(s), len(p)
    dp: list[bool] = [True if j >= N2 else False for j in range(N2 + 1)]
    for i in range(N1 - 1, -1, -1):
        next_dp: list[bool] = list(dp)
        for j in range(N2 - 1, -1, -1):
            if s[i] == p[j] or p[j] == '?':
                next_dp[j] = dp[j + 1]
            elif p[j] == '*':
                next_dp[j] = dp[j] or next_dp[j + 1]
            else:
                next_dp[j] = False

        dp = next_dp

    return dp[0]

# Testing the solution
assert isMatch("abacd", "*c?") == True
assert isMatch("abcabczzzde", "*abc???de*") == True
assert isMatch("aaa", "***?") == True
```

</div>

<div id="0af9e13b" class="cell markdown"
papermill="{&quot;duration&quot;:1.5511e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:53.010271&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:52.994760&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Best time to buy and sell stocks - II Video Link:
<https://youtu.be/nGJmxkUJQGs?si=xgX1LFznD2IAPCJ7>

</div>

<div id="0b5303c1" class="cell code" execution_count="84"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:53.042911Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:53.042410Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:53.047255Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:53.046847Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2432e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:53.048325&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:53.025893&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def stocks1Memo(prices: list[int]) -> int:
    @functools.cache
    def backtrack(i: int, inventory: int) -> int:
        if i == N:
            return 0
        elif inventory == -1:
            return max(backtrack(i + 1, i), backtrack(i + 1, -1))
        else:
            return max(prices[i] - prices[inventory] + backtrack(i + 1, -1), backtrack(i + 1, inventory))

    N = len(prices)
    return backtrack(0, -1)

# Testing the solution
assert stocks1Memo([7,1,5,3,6,4]) == 7
assert stocks1Memo([1,2,3,4,5]) == 4
assert stocks1Memo([7,6,4,3,1]) == 0
```

</div>

<div id="b24f5c40" class="cell code" execution_count="85"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:53.081969Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:53.081541Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:53.086551Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:53.086111Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2874e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:53.087595&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:53.064721&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Striver's approach
def stocks1StriverMemo(prices: list[int]) -> int:
    @functools.cache
    def backtrack(i: int, inventory: bool) -> int:
        if i == N:
            return 0
        elif not inventory: # No stock previously purchased: buy or not buy
            return max(-prices[i] + backtrack(i + 1, True), backtrack(i + 1, False))
        else: # Stock already exists: sell or hold stock
            return max(prices[i] + backtrack(i + 1, False), backtrack(i + 1, True))

    N = len(prices)
    return backtrack(0, False)

# Testing the solution
assert stocks1StriverMemo([7,1,5,3,6,4]) == 7
assert stocks1StriverMemo([1,2,3,4,5]) == 4
assert stocks1StriverMemo([7,6,4,3,1]) == 0
```

</div>

<div id="6e752e9f" class="cell code" execution_count="86"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:53.120076Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:53.119855Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:53.125432Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:53.124953Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.3024e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:53.126470&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:53.103446&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def stocks1Tab(prices: list[int]) -> int:
    N = len(prices)
    dp: list[list[int]] = [[0 for j in range(2)] for i in range(N + 1)]
    for i in range(N - 1, -1, -1):
        for j in range(1, -1, -1):
            if j == 0:
                dp[i][j] = max(-prices[i] + dp[i + 1][1], dp[i + 1][0])
            else:
                dp[i][j] = max(prices[i] + dp[i + 1][0], dp[i + 1][1])

    return dp[0][0]

# Testing the solution
assert stocks1Tab([7,1,5,3,6,4]) == 7
assert stocks1Tab([1,2,3,4,5]) == 4
assert stocks1Tab([7,6,4,3,1]) == 0
```

</div>

<div id="32c0e187" class="cell code" execution_count="87"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:53.159231Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:53.158993Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:53.164042Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:53.163590Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2775e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:53.165129&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:53.142354&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/submissions/1259669260
def stocks1(prices: list[int]) -> int:
    N = len(prices)
    dp: list[int] = [0 for j in range(2)]
    for i in range(N - 1, -1, -1):
        for j in range(1, -1, -1):
            if j == 0:
                dp[j] = max(-prices[i] + dp[1], dp[0])
            else:
                dp[j] = max(prices[i] + dp[0], dp[1])

    return dp[0]

# Testing the solution
assert stocks1([7,1,5,3,6,4]) == 7
assert stocks1([1,2,3,4,5]) == 4
assert stocks1([7,6,4,3,1]) == 0
```

</div>

<div id="f99546d3" class="cell markdown"
papermill="{&quot;duration&quot;:1.5703e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:53.197125&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:53.181422&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video Link: <https://youtu.be/-uQGzhYj8BQ?si=-Ps8pCdPtuWjuTQZ> Buy and
Sell Stocks - III:
<https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/>

</div>

<div id="8939c406" class="cell code" execution_count="88"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:53.229458Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:53.229210Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:53.234548Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:53.234097Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2822e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:53.235532&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:53.212710&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def stocks2Memo(prices: list[int]) -> int:
    """
    0 - Start
    1 - Buy 1
    2 - Sell 1
    3 - Buy 2
    4 - Sell 2
    """
    @functools.cache
    def backtrack(i: int, j: int) -> int:
        if i == N or j == 4:
            return 0
        elif j % 2 == 0: # Not holding any stock: buy / not buy
            return max(-prices[i] + backtrack(i + 1, j + 1), backtrack(i + 1, j))
        else:
            return max(prices[i] + backtrack(i + 1, j + 1), backtrack(i + 1, j))

    N = len(prices)
    return backtrack(0, 0)

# Testing the solution
assert stocks2Memo([3,3,5,0,0,3,1,4]) == 6
assert stocks2Memo([1,2,3,4,5]) == 4
assert stocks2Memo([7,6,4,3,1]) == 0
```

</div>

<div id="4f33510b" class="cell code" execution_count="89"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:53.268302Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:53.267878Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:53.274648Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:53.274125Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.4328e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:53.275726&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:53.251398&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def stocks2Tab(prices: list[int]) -> int:
    N = len(prices)
    dp: list[list[int]] = [[0 for j in range(5)] for i in range(N + 1)]
    for i in range(N - 1, -1, -1):
        for j in range(3, -1, -1):
            if j % 2 == 0: # Not holding any stock: buy / not buy
                dp[i][j] = max(-prices[i] + dp[i + 1][j + 1], dp[i + 1][j])
            else:
                dp[i][j] = max(prices[i] + dp[i + 1][j + 1], dp[i + 1][j])

    return dp[0][0]

# Testing the solution
assert stocks2Tab([3,3,5,0,0,3,1,4]) == 6
assert stocks2Tab([1,2,3,4,5]) == 4
assert stocks2Tab([7,6,4,3,1]) == 0
```

</div>

<div id="2d27ea1d" class="cell code" execution_count="90"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:53.309392Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:53.308898Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:53.313957Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:53.313446Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2912e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:53.314941&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:53.292029&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/submissions/1259699363
def stocks2(prices: list[int]) -> int:
    N = len(prices)
    dp: list[int] = [0 for j in range(5)]
    for i in range(N - 1, -1, -1):
        for j in range(3, -1, -1):
            if j % 2 == 0: # Not holding any stock: buy / not buy
                dp[j] = max(-prices[i] + dp[j + 1], dp[j])
            else:
                dp[j] = max(prices[i] + dp[j + 1], dp[j])

    return dp[0]

# Testing the solution
assert stocks2([3,3,5,0,0,3,1,4]) == 6
assert stocks2([1,2,3,4,5]) == 4
assert stocks2([7,6,4,3,1]) == 0
```

</div>

<div id="3105a916" class="cell markdown"
papermill="{&quot;duration&quot;:2.0358e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:53.351073&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:53.330715&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Best time to buy and sell stocks - IV Video Link:
<https://youtu.be/IV1dHbk5CDc?si=zvqGmxYAZN10-UGg>

</div>

<div id="9619fbbe" class="cell code" execution_count="91"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:53.397605Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:53.397114Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:53.402053Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:53.401568Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2632e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:53.403140&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:53.380508&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Minor update on the previous problem
def stocks3(k: int, prices: list[int]) -> int:
    N = len(prices)
    max_transaction = 2 * k
    dp: list[int] = [0 for j in range(max_transaction + 1)]
    for i in range(N - 1, -1, -1):
        for j in range(max_transaction - 1, -1, -1):
            if j % 2 == 0: # Not holding any stock: buy / not buy
                dp[j] = max(-prices[i] + dp[j + 1], dp[j])
            else:
                dp[j] = max(prices[i] + dp[j + 1], dp[j])

    return dp[0]

# Testing the solution
assert stocks3(2, [2,4,1]) == 2
assert stocks3(2, [3,2,6,5,0,3]) == 7
```

</div>

<div id="317bdab8" class="cell code" execution_count="92"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:53.436595Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:53.436161Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:53.441143Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:53.440593Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.297e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:53.442189&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:53.419219&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Let's try striver's approach of using a 3D array
def stocks3StriverMemo(k: int, prices: list[int]) -> int:
    @functools.cache
    def backtrack(i: int, inventory: bool, count: int) -> int:
        if i == N or count == k:
            return 0
        elif not inventory: # Not holding any stock
            return max(-prices[i] + backtrack(i + 1, True, count), backtrack(i + 1, False, count))
        else:
            return max(prices[i] + backtrack(i + 1, False, count + 1), backtrack(i + 1, True, count))

    N = len(prices)
    return backtrack(0, 0, 0)

# Testing the solution
assert stocks3StriverMemo(2, [2,4,1]) == 2
assert stocks3StriverMemo(2, [3,2,6,5,0,3]) == 7
```

</div>

<div id="a04d3d04" class="cell code" execution_count="93"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:53.475286Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:53.474907Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:53.480661Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:53.480185Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.351e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:53.481788&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:53.458278&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def stocks3StriverTab(K: int, prices: list[int]) -> int:
    N = len(prices)
    dp: list[list[list[int]]] = [[[0 for count in range(K + 1)] for j in range(2)] for i in range(N + 1)]
    for i in range(N - 1, -1, -1):
        for j in range(1, -1, -1):
            for count in range(K - 1, -1, -1):
                if j == 0:
                    dp[i][j][count] = max(-prices[i] + dp[i + 1][1][count], dp[i + 1][0][count])
                else:
                    dp[i][j][count] = max(prices[i] + dp[i + 1][0][count + 1], dp[i + 1][1][count])

    return dp[0][0][0]

# Testing the solution
assert stocks3StriverTab(2, [2,4,1]) == 2
assert stocks3StriverTab(2, [3,2,6,5,0,3]) == 7
```

</div>

<div id="f4b496e3" class="cell code" execution_count="94"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:53.514600Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:53.514145Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:53.519528Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:53.519093Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2874e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:53.520585&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:53.497711&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def stocks3Striver(K: int, prices: list[int]) -> int:
    N = len(prices)
    dp: list[list[int]] = [[0 for count in range(K + 1)] for j in range(2)]
    for i in range(N - 1, -1, -1):
        for j in range(1, -1, -1):
            for count in range(K - 1, -1, -1):
                if j == 0:
                    dp[j][count] = max(-prices[i] + dp[1][count], dp[0][count])
                else:
                    dp[j][count] = max(prices[i] + dp[0][count + 1], dp[1][count])

    return dp[0][0]

# Testing the solution
assert stocks3Striver(2, [2,4,1]) == 2
assert stocks3Striver(2, [3,2,6,5,0,3]) == 7
```

</div>

<div id="6d856ff6" class="cell markdown"
papermill="{&quot;duration&quot;:1.6223e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:53.553230&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:53.537007&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video link: <https://youtu.be/IGIe46xw3YY?si=B0IUJM2GtIGVlq7D> Best time
to buy and sell stock with cooldown

</div>

<div id="d8063cf8" class="cell code" execution_count="95"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:53.585880Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:53.585672Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:53.590985Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:53.590569Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2915e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:53.592006&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:53.569091&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Copy pasting code from stocks II, when selling do a i + 2 instead of i + 1
def stocksWithCooldownTab(prices: list[int]) -> int:
    N = len(prices)
    dp: list[list[int]] = [[0 for j in range(2)] for i in range(N + 2)]
    for i in range(N - 1, -1, -1):
        for j in range(1, -1, -1):
            if j == 0:
                dp[i][j] = max(-prices[i] + dp[i + 1][1], dp[i + 1][0])
            else:
                dp[i][j] = max(prices[i] + dp[i + 2][0], dp[i + 1][1])

    return dp[0][0]

# Testing the solution
assert stocksWithCooldownTab([1,2,3,0,2]) == 3
assert stocksWithCooldownTab([1,2,2,3,1,2,3,3,1,2,3,4,1,2,3,1,2,3,2,2,3,4,1,23,2,23]) == 31
```

</div>

<div id="0f414ee0" class="cell code" execution_count="96"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:53.625636Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:53.625288Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:53.630682Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:53.630237Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.3561e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:53.631712&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:53.608151&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def stocksWithCooldown(prices: list[int]) -> int:
    N = len(prices)
    dp: list[int] = [0 for j in range(2)]
    next_dp: list[int] = [0 for j in range(2)]
    for i in range(N - 1, -1, -1):
        temp = list(dp)
        for j in range(1, -1, -1):
            if j == 0:
                dp[j] = max(-prices[i] + dp[1], dp[0])
            else:
                dp[j] = max(prices[i] + next_dp[0], dp[1])
        next_dp = temp

    return dp[0]

# Testing the solution
assert stocksWithCooldown([1,2,3,0,2]) == 3
assert stocksWithCooldown([1,2,2,3,1,2,3,3,1,2,3,4,1,2,3,1,2,3,2,2,3,4,1,23,2,23]) == 31
```

</div>

<div id="ba9b90d0" class="cell markdown"
papermill="{&quot;duration&quot;:1.6263e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:53.664333&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:53.648070&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video link: <https://youtu.be/k4eK-vEmnKg?si=-J8puY5S-kGzz_uT> Buy and
sell stocks with transaction fee

</div>

<div id="31f18961" class="cell code" execution_count="97"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:53.697129Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:53.696619Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:53.701466Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:53.700927Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2409e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:53.702484&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:53.680075&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def stocksWithTranFeeMemo(prices: list[int], fee: int) -> int:
    @functools.cache
    def backtrack(i: int, inventory: bool) -> int:
        if i == N:
            return 0
        elif not inventory:
            return max(-prices[i] + backtrack(i + 1, True), backtrack(i + 1, False))
        else:
            return max(prices[i] + backtrack(i + 1, False) - fee, backtrack(i + 1, True))

    N = len(prices)
    return backtrack(0, False)

# Testing the solution
assert stocksWithTranFeeMemo([1,3,2,8,4,9], 2) == 8
assert stocksWithTranFeeMemo([1,3,7,5,10,3], 3) == 6
```

</div>

<div id="ebfef8d3" class="cell code" execution_count="98"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:53.736154Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:53.735847Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:53.741110Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:53.740576Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.3714e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:53.742244&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:53.718530&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def stocksWithTranFeeTab(prices: list[int], fee: int) -> int:
    N = len(prices)
    dp: list[list[int]] = [[0 for j in range(2)] for i in range(N + 1)]
    for i in range(N - 1, -1, -1):
        for j in range(2):
            if not j:
                dp[i][j] = max(-prices[i] + dp[i + 1][1], dp[i + 1][0])
            else:
                dp[i][j] = max(prices[i] + dp[i + 1][0] - fee, dp[i + 1][1])

    return dp[0][0]

# Testing the solution
assert stocksWithTranFeeTab([1,3,2,8,4,9], 2) == 8
assert stocksWithTranFeeTab([1,3,7,5,10,3], 3) == 6
```

</div>

<div id="4ca839d1" class="cell code" execution_count="99"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:53.775895Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:53.775485Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:53.780500Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:53.779951Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2995e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:53.781640&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:53.758645&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/submissions/1260096941
def stocksWithTranFee(prices: list[int], fee: int) -> int:
    """
    Can simplify the inner loop since we are always checking for case where
    we are holding stock and not holding stock.
    """
    N = len(prices)
    dp: list[int] = [0 for j in range(2)]
    for i in range(N - 1, -1, -1):
        dp[0] = max(-prices[i] + dp[1], dp[0])
        dp[1] = max(prices[i] + dp[0] - fee, dp[1])

    return dp[0]

# Testing the solution
assert stocksWithTranFee([1,3,2,8,4,9], 2) == 8
assert stocksWithTranFee([1,3,7,5,3,3], 10) == 0
```

</div>

<div id="5c9cb929" class="cell markdown"
papermill="{&quot;duration&quot;:1.6005e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:53.813985&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:53.797980&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Longest increasing subsequence Video link:
<https://youtu.be/ekcwMsSIzVc?si=53GtUk_ZTJC3oDDc>

</div>

<div id="1a46c49e" class="cell code" execution_count="100"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:53.847123Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:53.846646Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:53.851917Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:53.851401Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2809e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:53.853002&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:53.830193&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def lengthOfLISMemo(nums: list[int]) -> int:
    """
    In striver's video, instead of stroing the max_, he stores the index of the latest max.
    This way subsequent tabulations would be much simpler.
    """
    @functools.cache
    def backtrack(i: int, max_: int) -> int:
        if i == N:
            return 0
        elif nums[i] > max_:
            return max(1 + backtrack(i + 1, nums[i]), backtrack(i + 1, max_))
        else:
            return backtrack(i + 1, max_)

    N, min_ = len(nums), min(nums)
    return backtrack(0, min_ - 1)

# Testing the solution
assert lengthOfLISMemo([10,9,2,5,3,7,101,18]) == 4
assert lengthOfLISMemo([0,1,0,3,2,3]) == 4
assert lengthOfLISMemo([1,1,1,1,1]) == 1
```

</div>

<div id="cd333f6f" class="cell code" execution_count="101"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:53.885735Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:53.885377Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:53.890610Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:53.890145Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.2779e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:53.891645&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:53.868866&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def lengthOfLISTab(nums: list[int]) -> int:
    N = len(nums)
    dp: list[list[int]] = [[0 for j in range(N + 2)] for i in range(N + 1)]
    for i in range(N - 1, -1, -1):
        for j in range(N - 1, -1, -1):
            # if j == 0, max_ => min_ - 1, j is right shifted by 1 index to accomodated min_ - 1
            if j == 0 or nums[i] > nums[j - 1]:
                dp[i][j] = max(1 + dp[i + 1][i + 1], dp[i + 1][j])
            else:
                dp[i][j] = dp[i + 1][j]

    return dp[0][0]

# Testing the solution
assert lengthOfLISTab([0,1,0,3,2,3]) == 4
assert lengthOfLISTab([1,1,1,1,1]) == 1
```

</div>

<div id="27be61f6" class="cell code" execution_count="102"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:53.923913Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:53.923455Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:53.927783Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:53.927353Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.1421e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:53.928812&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:53.907391&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def lengthOfLIS(nums: list[int]) -> int:
    "Slight improvement, at any point - j (inner loop) cannot be greater than i itself"
    N = len(nums)
    dp: list[int] = [0 for j in range(N + 2)]
    for i in range(N - 1, -1, -1):
        for j in range(i, -1, -1):
            if j == 0 or nums[i] > nums[j - 1]:
                dp[j] = max(1 + dp[i + 1], dp[j])

    return dp[0]

# Testing the solution
assert lengthOfLIS([0,1,0,3,2,3]) == 4
assert lengthOfLIS([1,1,1,1,1]) == 1
```

</div>

<div id="1c08a876" class="cell code" execution_count="103"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:53.961587Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:53.961132Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:53.963852Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:53.963346Z&quot;}"
papermill="{&quot;duration&quot;:2.03e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:53.964956&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:53.944656&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# LIS Tabulation: https://youtu.be/IFfYfonAFGc?si=XTbp31f-RLY2EsvQ
```

</div>

<div id="9532e810" class="cell code" execution_count="104"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:53.997568Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:53.997197Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:54.003582Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:54.003139Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.3674e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:54.004589&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:53.980915&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def lengthOfLISBetter(nums: list[int]) -> int:
    """
    Time: O(N ** 2), Space: O(N)
    This solution would be required if we were to trace back the LIS.
    """
    N = len(nums)
    lengths: list[int] = [1 for i in range(N)]
    prevs: list[int] = [i for i in range(N)]
    for i in range(N):
        for j in range(i):
            if nums[j] < nums[i] and lengths[i] < 1 + lengths[j]:
                lengths[i] = 1 + lengths[j]
                prevs[i] = j

    # Prev Index, Length
    max_: tuple[int, int] = (0, 1)
    for i in range(N):
        if max_[1] < lengths[i]:
            max_ = i, lengths[i]

    # Backtrack and print the LIS
    i = max_[0]
    LIS: list[int] = [nums[i]]
    while i != prevs[i]:
        LIS.append(nums[i])
        i = prevs[i]

    # Reverse the LIS and print it
    LIS.reverse()
    print(LIS)

    return max_[1]

# Testing the solution
assert lengthOfLISBetter([0,1,0,3,2,3]) == 4
assert lengthOfLISBetter([1,1,1,1,1]) == 1
```

<div class="output stream stdout">

    [1, 2, 3, 3]
    [1]

</div>

</div>

<div id="c89b7972" class="cell markdown"
papermill="{&quot;duration&quot;:1.5689e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:54.036074&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:54.020385&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

LIS with Binary Search:
<https://youtu.be/on2hvxBXJH4?si=XLlRu7uTag9KM_Mr> Intuition:

    Say we have an array like:
    0, 1, 0, 3, 2, 3

    Step 1: [0]
    Step 2: [0, 1]
    Step 3: [0, 1], [0]
    Step 4: [0, 1, 3], [0, 3]
    Step 5: [0, 1, 3], [0, 3], [0, 1, 2], [0, 2]
    Step 6: [0, 1, 3], [0, 3], [0, 1, 2, 3], [0, 2, 3]

    Basically at each step we are inserting into the right position and creating a new array if we cannot insert into existing arrays. This consumes a lot of time and memory.
    We could instead simply save the correct insert position to find the max LIS length which is the trick to finding the N log N solution

    Step 1: [0]
    Step 2: [0, 1]
    Step 3: [0, 1]
    Step 4: [0, 1, 3]
    Step 5: [0, 1, 2] (replace 2 at the position where it would get inserted into)
    Step 6: [0, 1, 2, 3]

    Do note that this array is not the subsequence. We merely use it to compute the length of LIS.

</div>

<div id="17062257" class="cell code" execution_count="105"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-17T14:08:54.068143Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-17T14:08:54.067933Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-17T14:08:54.072674Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-17T14:08:54.072270Z&quot;}"
papermill="{&quot;duration&quot;:2.2077e-2,&quot;end_time&quot;:&quot;2024-05-17T14:08:54.073772&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-17T14:08:54.051695&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/longest-increasing-subsequence/submissions/1260560726
def lengthOfLISOptimal(nums: list[int]) -> int:
    def LB(arr: list[int], target: int) -> int:
        """
        Given n, returns the insertion position of N
        """
        N = len(arr)
        low, high = 0, N - 1
        while low <= high:
            mid = (low + high) // 2
            if arr[mid] < target:
                low = mid + 1
            else:
                high = mid - 1

        return low

    dp: list[int] = []
    for n in nums:
        if not dp or dp[-1] < n:
            dp.append(n)
        else:
            idx = LB(dp, n)
            dp[idx] = n

    return len(dp)

# Testing the solution
assert lengthOfLISOptimal([0,1,0,3,2,3]) == 4
assert lengthOfLISOptimal([1,1,1,1,1]) == 1
```

</div>
