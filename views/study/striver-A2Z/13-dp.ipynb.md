---
jupyter:
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
  language_info:
    codemirror_mode:
      name: ipython
      version: 3
    file_extension: .py
    mimetype: text/x-python
    name: python
    nbconvert_exporter: python
    pygments_lexer: ipython3
    version: 3.11.9
  nbformat: 4
  nbformat_minor: 5
  papermill:
    default_parameters: {}
    duration: 4.120124
    end_time: "2024-05-13T16:03:37.543757"
    environment_variables: {}
    input_path: study/striver-A2Z/13-dp.ipynb
    output_path: study/striver-A2Z/13-dp.ipynb
    parameters: {}
    start_time: "2024-05-13T16:03:33.423633"
    version: 2.6.0
---

<div id="807dd9ee" class="cell markdown"
papermill="{&quot;duration&quot;:1.2517e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:34.581156&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:34.568639&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Important notes

- All subset based problems (non contigous subarrays would have the
  pick/nopick approach)
- To convert a memoization solution to tabulation:
  1.  Find the base case and assign the the DP
  2.  Start iterating from the base case all the way to our starting
      point
  3.  Return the value at the starting point
- We can space optimize a tabulation solution whenever we see only the
  prev/next rows being used in the tabualation solution.
- Time complexity of unmemoized DP code is typically exponential
  O(number of branches \*\* N)
- All subsets problem involve recursion trying all combinations: Pick,
  no pick
- For problems where there is an infinite supply, take would increase
  total but remain at the same index.
- For problems involving counts, we try all possb combinations and base
  case would either return 1 or 0.

</div>

<div id="457ab51f" class="cell markdown"
papermill="{&quot;duration&quot;:1.0602e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:34.602416&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:34.591814&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

### Some important imports

</div>

<div id="164d751b" class="cell code" execution_count="1"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:34.624640Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:34.624401Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:34.629854Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:34.629414Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.8074e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:34.630963&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:34.612889&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
import functools
import itertools
import collections
import math
import heapq
```

</div>

<div id="48648354" class="cell markdown"
papermill="{&quot;duration&quot;:1.0591e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:34.652191&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:34.641600&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Introduction to DP: <https://youtu.be/tyB0ztf0DNY?si=SgpBwGNqPXzdPSRA>

1.  Tabulation: Bottom up DP: Ans -\> Base case -\> Ans
2.  Memoization: Top down DP: Base case -\> Ans

</div>

<div id="41c46591" class="cell code" execution_count="2"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:34.675345Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:34.674816Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:34.681575Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:34.681065Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.9701e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:34.682665&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:34.662964&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def fiboBrute(n: int) -> int:
    """
    Vanilla recursion
    Time: O(2 ^ N), Space: O(2 ^ N)
    """
    if n <= 1:
        return n
    else:
        return fiboBrute(n - 1) + fiboBrute(n - 2)

fiboBrute(10)
```

<div class="output execute_result" execution_count="2">

    55

</div>

</div>

<div id="83ba7cd5" class="cell code" execution_count="3"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:34.706053Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:34.705530Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:34.711047Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:34.710535Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.841e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:34.712149&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:34.693739&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def fiboBetter1(n: int) -> int:
    """
    Memoization Approach: Top down approach
    Time: O(N), Space: O(N) + O(N)
    """
    dp: list[int] = [-1 for i in range(n + 1)]
    def backtrack(curr: int) -> int:
        if curr <= 1:
            return curr
        elif dp[curr] != -1:
            return dp[curr]
        else:
            dp[curr] = backtrack(curr - 1) + backtrack(curr - 2)
            return dp[curr]

    return backtrack(n)

fiboBetter1(10)
```

<div class="output execute_result" execution_count="3">

    55

</div>

</div>

<div id="80fded7e" class="cell code" execution_count="4"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:34.735357Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:34.734860Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:34.740200Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:34.739624Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.8162e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:34.741245&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:34.723083&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def fiboBetter2(n: int) -> int:
    """
    Tabulation: Bottom up approach
    Time: O(N), Space: O(N)
    """
    dp: list[int] = [-1 if i > 1 else i for i in range(n + 1)]
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]

    return dp[n]

fiboBetter2(10)
```

<div class="output execute_result" execution_count="4">

    55

</div>

</div>

<div id="8f7d86e2" class="cell code" execution_count="5"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:34.764456Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:34.763914Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:34.768611Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:34.768158Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.7391e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:34.769619&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:34.752228&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def fiboOptimal(n: int) -> int:
    """
    Bottom up approach
    Time: O(N), Space: O(1)
    """
    prev2, prev1 = 0, 1
    for i in range(2, n + 1):
        prev2, prev1 = prev1, prev1 + prev2
        n -= 1

    return prev1

fiboOptimal(10)
```

<div class="output execute_result" execution_count="5">

    55

</div>

</div>

<div id="855c35fb" class="cell markdown"
papermill="{&quot;duration&quot;:1.0858e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:34.791516&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:34.780658&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Climbing Stairs: <https://leetcode.com/problems/climbing-stairs/> Video
Link: <https://youtu.be/mLfjzJsN8us?si=C7W-jiYvql0mEnbh>

</div>

<div id="87993489" class="cell code" execution_count="6"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:34.814771Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:34.814331Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:34.818597Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:34.818165Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.7213e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:34.819658&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:34.802445&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def climbStairsBetter(n: int) -> int:
    """Time: O(N), Space: O(N)"""

    dp: list[int] = [-1 for i in range(n + 1)]
    def backtrack(curr: int) -> int:
        if curr <= 1:
            return 1
        elif dp[curr] != -1:
            return dp[curr]
        else:
            dp[curr] = backtrack(curr - 1) + backtrack(curr - 2)
            return dp[curr]

    return backtrack(n)

assert climbStairsBetter(45) == 1836311903
```

</div>

<div id="2dc15ac3" class="cell code" execution_count="7"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:34.843009Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:34.842538Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:34.845919Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:34.845508Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.6798e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:34.847546&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:34.830748&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def climbStairs(n: int) -> int:
    """Time: O(N), Space: O(1)"""
    prev2, prev1 = 1, 1
    while n > 0:
        prev2, prev1 = prev1, prev1 + prev2
        n -= 1

    return prev2

assert climbStairs(45) == 1836311903
```

</div>

<div id="3cd4d88c" class="cell markdown"
papermill="{&quot;duration&quot;:1.0971e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:34.870308&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:34.859337&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video link: <https://youtu.be/EgG3jsGoPvQ?si=Cm5AVvq_zCnr-w6q> Frog
Jump: 1

</div>

<div id="59c27b1e" class="cell code" execution_count="8"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:34.893570Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:34.893087Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:34.898010Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:34.897582Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.7813e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:34.899066&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:34.881253&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def frogJumpBetter(N: int, heights: list[int]) -> int:
    """
    Time: O(N), Space: O(N) + O(N)
    """

    @functools.cache
    def backtrack(curr: int) -> int:
        if curr == N - 1:
            return 0
        elif curr == N - 2:
            return abs(heights[N - 1] - heights[N - 2])
        else:
            jump1 = abs(heights[curr] - heights[curr + 1]) + backtrack(curr + 1)
            jump2 = abs(heights[curr] - heights[curr + 2]) + backtrack(curr + 2)
            return min(jump1, jump2)

    return backtrack(0)

# Testing the solution
assert frogJumpBetter(4, [10,20,30,10]) == 20
assert frogJumpBetter(3, [10,50,10]) == 0
```

</div>

<div id="2bc52e04" class="cell code" execution_count="9"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:34.922389Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:34.921935Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:34.926364Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:34.925842Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.724e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:34.927459&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:34.910219&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def frogJumpOptimal(N: int, heights: list[int]) -> int:
    "Time: O(N), Space: O(1)"
    jump1, jump2 = abs(heights[-2] - heights[-1]), 0
    for i in range(N - 3, -1, -1):
        curr = min(abs(heights[i] - heights[i + 1]) + jump1, abs(heights[i] - heights[i + 2]) + jump2)
        jump1, jump2 = curr, jump1

    return jump1

assert frogJumpOptimal(4, [10,20,30,10]) == 20
assert frogJumpOptimal(3, [10,50,10]) == 0
```

</div>

<div id="4fa38d19" class="cell markdown"
papermill="{&quot;duration&quot;:1.0866e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:34.949316&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:34.938450&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video Link: <https://youtu.be/Kmh3rhyEtB8?si=rqZ5-pJcjIzWU5i8> Frog Jump
with K distance

</div>

<div id="f21ca119" class="cell code" execution_count="10"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:34.990044Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:34.989714Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:34.994574Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:34.994054Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:3.5549e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:34.995743&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:34.960194&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def frogJumpAtKDistBetter1(N: int, K: int, heights: list[int]) -> int:
    """
    Memoization Approach: Top Down Approach
    Time: O(N x K), Space: O(N) + O(N)
    """

    @functools.cache
    def backtrack(curr: int) -> int:
        if curr >= N - 1:
            return 0
        else:
            minCost = math.inf
            for next_ in range(curr + 1, min(N, curr + K + 1)):
                cost = abs(heights[curr] - heights[next_]) + backtrack(next_)
                minCost = min(minCost, cost)

            return int(minCost)

    return backtrack(0)

# Testing the solution
assert frogJumpAtKDistBetter1(5, 3, [10,30,40,50,20]) == 30
assert frogJumpAtKDistBetter1(3, 1, [10,20,10]) == 20
```

</div>

<div id="1b9a86c0" class="cell code" execution_count="11"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:35.019339Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:35.018826Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:35.023837Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:35.023379Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.793e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.024919&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.006989&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def frogJumpAtKDistBetter2(N: int, K: int, heights: list[int]) -> int:
    """
    Tabulation: Bottom up approach
    Time: O(N x K), Space: O(N)
    """

    dp: list[int] = [-1 for i in range(N)]
    dp[-1] = 0

    for curr in range(N - 2, -1, -1):
        minCost = math.inf
        for next_ in range(curr + 1, min(N, curr + K + 1)):
            cost = abs(heights[curr] - heights[next_]) + dp[next_]
            minCost = min(minCost, cost)
        dp[curr] = int(minCost)

    return dp[0]

# Testing the solution
assert frogJumpAtKDistBetter2(5, 3, [10,30,40,50,20]) == 30
assert frogJumpAtKDistBetter2(3, 1, [10,20,10]) == 20
```

</div>

<div id="09ca5d18" class="cell code" execution_count="12"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:35.048381Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:35.047989Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:35.052935Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:35.052448Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.8147e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.054225&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.036078&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def frogJumpAtKDist(N: int, K: int, heights: list[int]) -> int:
    """
    Tabulation: Bottom up approach
    Time: O(N x K), Space: O(K)
    """

    dp: collections.deque[int] = collections.deque([0])
    for curr in range(N - 2, -1, -1):
        minCost = math.inf
        for jump in range(1, min(N - curr, K + 1)):
            next_ = curr + jump
            cost = abs(heights[curr] - heights[next_]) + dp[jump - 1]
            minCost = min(minCost, cost)

        dp.appendleft(int(minCost))
        if len(dp) > K:
            dp.pop()

    return dp[0]

# Testing the solution
assert frogJumpAtKDist(5, 3, [10,30,40,50,20]) == 30
assert frogJumpAtKDist(3, 1, [10,20,10]) == 20
```

</div>

<div id="259d53f8" class="cell markdown"
papermill="{&quot;duration&quot;:1.1038e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.077035&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.065997&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Maximum sum of Non Adjacent Elements: House Robber Video Link:
<https://youtu.be/GrMBfJNk_NY?si=IPuGJglc0axETveU>

</div>

<div id="89d8dea7" class="cell code" execution_count="13"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:35.099952Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:35.099601Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:35.103707Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:35.103285Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.6983e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.104852&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.087869&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def robMemo(nums: list[int]) -> int:
    """
    Memoization: Top down approach
    Time: O(N), Space: O(N)
    """

    @functools.cache
    def backtrack(curr: int) -> int:
        if curr >= N:
            return 0
        else:
            return max(backtrack(curr + 1), nums[curr] + backtrack(curr + 2))

    N = len(nums)
    return backtrack(0)

# Testing the solution
assert robMemo([2,7,9,3,1]) == 12
```

</div>

<div id="e69063ac" class="cell code" execution_count="14"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:35.128209Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:35.127719Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:35.132030Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:35.131510Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.7211e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.133094&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.115883&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def robTab(nums: list[int]) -> int:
    """
    Tabulation: Bottom up approach
    Time: O(N), Space: O(N)
    """
    N = len(nums)
    dp: list[int] = [-1 for i in range(N + 1)]
    dp[-1], dp[-2] = 0, nums[-1]
    for curr in range(N - 2, -1, -1):
        dp[curr] = max(nums[curr] + dp[curr + 2], dp[curr + 1])

    return dp[0]

# Testing the solution
assert robTab([2,7,9,3,1]) == 12
```

</div>

<div id="d3ac1b1c" class="cell code" execution_count="15"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:35.156493Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:35.156013Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:35.160072Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:35.159607Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.6958e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.161172&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.144214&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/house-robber/submissions/1249841355/
def robSpaceOptimized(nums: list[int]) -> int:
    "Time: O(N), Space: O(1)"
    next1 = next2 = 0
    for curr in range(len(nums) - 1, -1, -1):
        next1, next2 = max(nums[curr] + next2, next1), next1

    return next1

assert robSpaceOptimized([2,7,9,3,1]) == 12
```

</div>

<div id="630eec21" class="cell markdown"
papermill="{&quot;duration&quot;:1.0804e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.183127&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.172323&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

House Robber 2: <https://youtu.be/3WaxQMELSkw?si=i9oGKnDJGJxvUjbu>
<https://leetcode.com/problems/house-robber-ii/submissions/1249888930>

</div>

<div id="3ee7a5cf" class="cell code" execution_count="16"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:35.206550Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:35.206108Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:35.210859Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:35.210377Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.7802e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.211928&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.194126&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def rob2(nums: list[int]) -> int:
    """
    Ans cannot contain both the first and the last house.
    It can contain either the first or the last house.
    """
    def rob(arr: list[int]) -> int:
        next1 = next2 = 0
        for curr in range(len(arr) - 1, -1, -1):
            next1, next2 = max(arr[curr] + next2, next1), next1

        return next1

    return max(rob(nums[1:]), rob(nums[:-1])) if len(nums) > 1 else sum(nums)

# Testing the solution
assert rob2([1,2,3,1]) == 4
assert rob2([]) == 0
```

</div>

<div id="52745498" class="cell markdown"
papermill="{&quot;duration&quot;:1.1532e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.235394&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.223862&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Ninja's Training: <https://youtu.be/AE39gJYuRog?si=n4BhCotno-9chP5j>

</div>

<div id="c814dc79" class="cell code" execution_count="17"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:35.259542Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:35.258935Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:35.264702Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:35.264144Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.9075e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.265860&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.246785&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def ninjaTrainingBetter(N: int, points: list[list[int]]) -> int:
    """
    Memoization: Top down approach

    Time: O(N), Space: O(N) + O(N)
    """

    @functools.cache
    def backtrack(i: int, j: int) -> int:
        if i == N:
            return 0
        else:
            max_ = -math.inf
            for k in range(3):
                if k != j:
                    max_ = max(max_, points[i][k] + backtrack(i + 1, k))

            return int(max_)

    return backtrack(0, -1)

# Testing the solution
assert ninjaTrainingBetter(3, [[10,40,70], [20,50,80], [30,60,90]]) == 210
assert ninjaTrainingBetter(3, [[1,2,5], [3,1,1], [3,3,3]]) == 11
assert ninjaTrainingBetter(2, [[10,50,1], [5,100,11]]) == 110
```

</div>

<div id="015e9458" class="cell code" execution_count="18"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:35.290405Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:35.289830Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:35.295971Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:35.295382Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.9743e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.297153&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.277410&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def ninjaTraining(N: int, points: list[list[int]]) -> int:
    """
    Space optimized Tabulation DP: Bottom up

    Start at the last day.
    At each day we sum up corresponding values with the values in DP and assign them to DP.
    Before moving the prev day, to the DP perform this op -> dp[i] = max(dp[j]) where j != i

    At the end of the iteration simply return max of DP.

    Time: O(N), Space: O(1)
    """

    dp: list[int] = [0, 0, 0]
    for i in range(N - 1, -1, -1):
        for j in range(3):
            dp[j] += points[i][j]

        next_dp: list[int] = []
        for j in range(3):
            next_dp.append(max(dp[k] for k in range(3) if k != j))

        dp = next_dp

    return max(dp)

# Testing the solution
assert ninjaTraining(3, [[10,40,70], [20,50,80], [30,60,90]]) == 210
assert ninjaTraining(3, [[1,2,5], [3,1,1], [3,3,3]]) == 11
assert ninjaTraining(2, [[10,50,1], [5,100,11]]) == 110
```

</div>

<div id="d132fa58" class="cell markdown"
papermill="{&quot;duration&quot;:1.1742e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.320292&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.308550&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Unique 2D paths: <https://youtu.be/sdE0A2Oxofw?si=g1FpuSIYx0x95G-7>
<https://leetcode.com/problems/unique-paths/>

</div>

<div id="d035c9d7" class="cell code" execution_count="19"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:35.345408Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:35.344967Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:35.349749Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:35.349219Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.896e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.350963&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.332003&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def uniquePathsMemo(m: int, n: int) -> int:
    """
    Memoization Solution: Top Down
    Time: O(m x n), Space: O(m x n) + O(m x n)
    """
    @functools.cache
    def backtrack(i: int, j: int) -> int:
        if i == m - 1 and j == n - 1:
            return 1
        elif i >= m or j >= n:
            return 0
        else:
            return backtrack(i + 1, j) + backtrack(i, j + 1)

    return backtrack(0, 0)

# Testing the solution
assert uniquePathsMemo(3, 7) == 28
assert uniquePathsMemo(3, 2) == 3
```

</div>

<div id="c3fb756d" class="cell code" execution_count="20"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:35.376924Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:35.376418Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:35.381256Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:35.380722Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.9183e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.382503&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.363320&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/unique-paths/submissions/1250526713
def uniquePathsTab(m: int, n: int) -> int:
    "Time: O(m x n), Space: O(min(m, n))"
    M, N = min(m, n), max(m, n)
    dp: list[int] = [1 for i in range(M)]

    for i in range(N - 1):
        for j in range(M - 2, -1, -1):
            dp[j] += dp[j + 1]

    return dp[0]

# Testing the solution
assert uniquePathsTab(3, 7) == 28
assert uniquePathsTab(3, 2) == 3
```

</div>

<div id="bb22f54a" class="cell markdown"
papermill="{&quot;duration&quot;:1.1573e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.405903&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.394330&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video link: <https://youtu.be/TmhpgXScLyY?si=M_FfFKRqRTXid4Jj> Unique
Paths - ii:
<https://leetcode.com/problems/unique-paths-ii/submissions/1250615914>

</div>

<div id="f59a530c" class="cell code" execution_count="21"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:35.430787Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:35.430283Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:35.436007Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:35.435423Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.9883e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.437361&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.417478&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def uniquePathsWithObstacles(obstacleGrid: list[list[int]]) -> int:
    "Time: O(M x N), Space: O(N)"
    M, N = len(obstacleGrid), len(obstacleGrid[0])

    dp: list[int] = [0 for j in range(N)]
    dp[-1] = 1

    for i in range(M - 1, -1, -1):
        for j in range(N - 1, -1, -1):
            if obstacleGrid[i][j] == 0:
                dp[j] = dp[j] + dp[j + 1] if j < N - 1 else dp[j]
            else:
                dp[j] = 0

    return dp[0]

# Testing the solution
assert uniquePathsWithObstacles([[0,0,0],[0,1,0],[0,0,0]]) == 2
assert uniquePathsWithObstacles([[0,1],[0,0]]) == 1
assert uniquePathsWithObstacles([[1]]) == 0
```

</div>

<div id="93e28e9b" class="cell markdown"
papermill="{&quot;duration&quot;:1.174e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.461222&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.449482&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Minimum Path Sum: <https://youtu.be/_rgTlyky1uQ?si=3xJY7MmVg5tTEW5Q>
<https://leetcode.com/problems/minimum-path-sum/submissions/1250633614>

</div>

<div id="c97f7ce9" class="cell code" execution_count="22"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:35.486487Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:35.485941Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:35.491581Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:35.491028Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.9752e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.492820&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.473068&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def minPathSum(grid: list[list[int]]) -> int:
    "Time: O(M x N), Space: O(N)"
    M, N = len(grid), len(grid[0])

    # Initialize DP
    dp: list[float] = [math.inf for j in range(N)]
    dp[-1] = 0

    # DP Solution
    for i in range(M - 1, -1, -1):
        for j in range(N - 1, -1, -1):
            dp[j] = grid[i][j] + (min(dp[j + 1], dp[j]) if j < N - 1 else dp[j])

    return int(dp[0])

# Testing the solution
assert minPathSum([[1,3,1],[1,5,1],[4,2,1]]) == 7
assert minPathSum([[1,2,3],[4,5,6]]) == 12
```

</div>

<div id="107526ff" class="cell markdown"
papermill="{&quot;duration&quot;:1.1774e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.516774&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.505000&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video Link: <https://youtu.be/0bHoB32fuj0?si=5UHeArKmLvTVpbrk> Triangle:
<https://leetcode.com/problems/triangle/submissions/1251774955/>

</div>

<div id="62387041" class="cell code" execution_count="23"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:35.540797Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:35.540182Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:35.545404Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:35.544850Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.8558e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.546601&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.528043&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def minimumTotal(triangle: list[list[int]]) -> int:
    """Time: O(N x N), Space: O(N)"""
    N = len(triangle)
    dp: list[int] = [0 for i in range(N + 1)]

    while N > 0:
        next_: list[int] = []
        for i in range(N):
            next_.append(min(dp[i], dp[i + 1]) + triangle[N - 1][i])
        dp = next_
        N -= 1

    return dp[0]

# Testing the solution
assert minimumTotal([[2],[3,4],[6,5,7],[4,1,8,3]]) == 11
assert minimumTotal([[-10]]) == -10
```

</div>

<div id="51332104" class="cell markdown"
papermill="{&quot;duration&quot;:1.1626e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.569776&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.558150&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video Link: <https://youtu.be/N_aJ5qQbYA0?si=LTME1YI3hqtU8u8_> Maximum
Falling path sum We cannot apply greedy algorithms here because there is
no uniformity mentioned. Uniformity implies how the numbers are
distributed. For eg:

    1   2  3    4
    10  1  100  1
    1   2  5    0

In the above example from (0, 0), if we greedily chose (1, 0) - we would
miss out on 100 at (1, 2). If suppose we were told that the numbers were
arranged in ascending or descending order we can greedily pick a path

</div>

<div id="4f9fb3eb" class="cell code" execution_count="24"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:35.593490Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:35.592944Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:35.598904Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:35.598419Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.907e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.599984&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.580914&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def getMaxPathSumBetter(matrix: list[list[int]]):
    """
    With memoization:
    Time complexity: O(3 ^ N)

    Memoization Approach: Top Down
    Time: O(N x M), Space: O(N x M) + O(N x M)
    """
    M, N = len(matrix), len(matrix[0])

    @functools.cache
    def backtrack(i: int = 0, j: int = 0) -> float:
        if i >= M:
            return 0
        elif j < 0 or j >= N:
            return -math.inf
        else:
            return matrix[i][j] + max(backtrack(i + 1, j - 1), backtrack(i + 1, j), backtrack(i + 1, j + 1))

    maxPathSum = -math.inf
    for j in range(N):
        maxPathSum = max(maxPathSum, backtrack(0, j))

    return int(maxPathSum)

# Testing the solution
assert getMaxPathSumBetter([[1,2,10,4],[100,3,2,1],[1,1,20,2],[1,2,2,1]]) == 105
assert getMaxPathSumBetter([[10,2,3],[3,7,2],[8,1,5]]) == 25
```

</div>

<div id="b3cf95be" class="cell code" execution_count="25"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:35.623936Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:35.623441Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:35.629139Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:35.628605Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.8947e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.630362&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.611415&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def getMaxPathSum(matrix: list[list[int]]):
    """
    Space optimized DP: Bottom up
    Time: O(M x N), Space: O(N)
    """
    M, N = len(matrix), len(matrix[0])

    dp: list[float] = [0 for i in range(N)]
    i = M - 1
    while i >= 0:
        next_: list[float] = []
        for j in range(N):
            next_.append(matrix[i][j] + max(dp[j - 1] if j - 1 >= 0 else -math.inf, dp[j], dp[j + 1] if j + 1 < N else -math.inf))

        dp = next_
        i -= 1

    return max(dp)

# Testing the solution
assert getMaxPathSum([[1,2,10,4],[100,3,2,1],[1,1,20,2],[1,2,2,1]]) == 105
assert getMaxPathSum([[10,2,3],[3,7,2],[8,1,5]]) == 25
```

</div>

<div id="703cdb9d" class="cell markdown"
papermill="{&quot;duration&quot;:1.1188e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.652981&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.641793&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Cherry Pickup: 2: <https://leetcode.com/problems/cherry-pickup-ii/>
Video Link: <https://youtu.be/QGfn7JeXK54?si=2K0Lz9iKN_IxLUDN>

</div>

<div id="d82f0e5d" class="cell code" execution_count="26"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:35.677259Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:35.676663Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:35.684193Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:35.683689Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.0833e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.685290&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.664457&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def cherryPickupMemo(grid: list[list[int]]) -> int:
    """
    Without memoization, time complexity: O(3 ^ M * 3 ^ M)

    Space complexity is definitely improved with using @functools.cache, using list here to illustrate.
    Time: O (M x N x N), Space: O (M x N x N)

    To figure out the dp size, simply check how many parameters are chaning. Here we have an i, j1, j2 and hence dp is a 3D Matrix.
    """
    M, N = len(grid), len(grid[0])
    dp: list[list[list[float]]] = [[[-1 for k in range(N)] for j in range(N)] for i in range(M)]

    def backtrack(i: int, j1: int, j2: int) -> float:
        if j1 < 0 or j2 < 0 or j1 >= N or j2 >= N or j1 == j2:
            return -math.inf
        elif i > M - 1:
            return 0
        elif dp[i][j1][j2] != -1:
            return dp[i][j1][j2]
        else:
            next_picked = -math.inf
            for j1_offset in range(-1, 2):
                for j2_offset in range(-1, 2):
                    next_picked = max(next_picked, backtrack(i + 1, j1 + j1_offset, j2 + j2_offset))

            dp[i][j1][j2] = grid[i][j1] + grid[i][j2] + next_picked
            return dp[i][j1][j2]

    result = int(backtrack(0, 0, N - 1))
    return result

# Testing the solution
assert cherryPickupMemo([[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]) == 28
```

</div>

<div id="85c88b05" class="cell code" execution_count="27"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:35.709167Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:35.708810Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:35.716585Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:35.716010Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.0901e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.717659&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.696758&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def cherryPickupTab(grid: list[list[int]]) -> int:
    """
    Simply start with the base case. Move bottom up.
    """
    M, N = len(grid), len(grid[0])

    # Initialize DP with the base case
    dp: list[list[list[float]]] = [[[0 for k in range(N)] for j in range(N)] for i in range(M)]
    for j1 in range(N):
        for j2 in range(N):
            dp[-1][j1][j2] = grid[-1][j1] + grid[-1][j2] if j1 != j2 else grid[-1][j1]

    # i, j1, j2: (0 - M), (0 - N), (0 - N)
    for i in range(M - 2, -1, -1):
        for j1 in range(N):
            for j2 in range(N):
                max_: float = -math.inf
                curr = grid[i][j1] + grid[i][j2] if j1 != j2 else grid[i][j1]
                for j1_offset in range(-1, 2):
                    for j2_offset in range(-1, 2):
                        if 0 <= j1 + j1_offset < N and 0 <= j2 + j2_offset < N:
                            max_ = max(max_, dp[i + 1][j1 + j1_offset][j2 + j2_offset])

                dp[i][j1][j2] = max(-1, max_ + curr)

    return int(dp[0][0][-1])

# Testing the solution
assert cherryPickupTab([[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]) == 28
```

</div>

<div id="e2fdb650" class="cell code" execution_count="28"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:35.741642Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:35.741100Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:35.748296Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:35.747816Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.0337e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.749373&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.729036&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def cherryPickupSpaceOptimized(grid: list[list[int]]) -> int:
    M, N = len(grid), len(grid[0])
    dp: list[list[float]] = [[grid[-1][j1] + grid[-1][j2] if j1 != j2 else grid[-1][j1] for j1 in range(N)] for j2 in range(N)]

    for i in range(M - 2, -1, -1):
        dp_next: list[list[float]] = []
        for j1 in range(N):
            dp_next.append([])
            for j2 in range(N):
                max_: float = -math.inf
                curr = grid[i][j1] + grid[i][j2] if j1 != j2 else grid[i][j1]
                for j1_offset in range(-1, 2):
                    for j2_offset in range(-1, 2):
                        if 0 <= j1 + j1_offset < N and 0 <= j2 + j2_offset < N:
                            max_ = max(max_, dp[j1 + j1_offset][j2 + j2_offset])

                dp_next[j1].append(curr + max_)
        dp = dp_next

    return int(dp[0][-1])

# Testing the solution
assert cherryPickupSpaceOptimized([[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]) == 28
```

</div>

<div id="17816765" class="cell markdown"
papermill="{&quot;duration&quot;:1.1072e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.771892&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.760820&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Subset sum equals target Video Link:
<https://youtu.be/fWX9xDmIzRI?si=jb2Tgvw_E0Tyk1Pj>

</div>

<div id="4f37d7b7" class="cell code" execution_count="29"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:35.795489Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:35.794947Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:35.800567Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:35.800068Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.876e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.801630&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.782870&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def isSubsetSumMemo(N: int, arr: list[int], target: int) -> int:
    """
    For cases where subset exists, the recursion would stop early. For the negative cases, we would get overlapping subproblems and
    hence memoization would help decrease the time complexity.

    Time without memoization: O(2 ^ N), Space: O(N)
    With memoization: O(N x target), Space: O(N x target) + O(N)
    """

    dp: list[list[int]] = [[-1 for j in range(target + 1)] for i in range(N)]
    def backtrack(i: int, total: int) -> bool:
        if total == 0:
            return True
        elif total < 0 or i > N - 1:
            return False
        elif dp[i][total] != -1:
            return bool(dp[i][total])
        else:
            result = backtrack(i + 1, total - arr[i]) or backtrack(i + 1, total)
            dp[i][total] = int(result)
            return result

    return backtrack(0, target)

# Testing the solution
assert isSubsetSumMemo(6, [3, 34, 4, 12, 5, 2], 9) == True
assert isSubsetSumMemo(6, [3, 34, 4, 12, 5, 2], 30) == False
```

</div>

<div id="5551c36b" class="cell code" execution_count="30"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:35.825947Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:35.825582Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:35.831422Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:35.830884Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.9252e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.832519&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.813267&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def isSubsetSumTab(N: int, arr: list[int], target: int) -> bool:
    """
    Each cell in the dp represents -> If total - arr[i] is true down the line.
    Note that dp[i][0] is always true, since if the target is to be 0 regardless of arr[i] tehn subsetSumTarget is possible.
    """
    dp: list[list[int]] = [[1 if j == 0 else -1 if i < N else 0 for j in range(target + 1)] for i in range(N + 1)]

    for i in range(N - 1, -1, -1):
        for total in range(1, target + 1):
            if dp[i + 1][total] == 1 or (total - arr[i] >= 0 and dp[i + 1][total - arr[i]] == 1):
                dp[i][total] = 1
            else:
                dp[i][total] = 0

    print(dp)
    return bool(dp[0][target])

# Testing the solution
assert isSubsetSumTab(6, [3, 34, 4, 12, 5, 2], 9) == True
assert isSubsetSumTab(6, [3, 34, 4, 12, 5, 2], 30) == False
```

<div class="output stream stdout">

    [[1, 0, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1], [1, 0, 1, 0, 0, 1, 0, 1, 0, 0], [1, 0, 1, 0, 0, 1, 0, 1, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
    [[1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

</div>

</div>

<div id="ca80b369" class="cell code" execution_count="31"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:35.856539Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:35.856063Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:35.861383Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:35.860924Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.8429e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.862447&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.844018&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def isSubsetSumSpaceOptimized(N: int, arr: list[int], target: int) -> bool:
    "Time: O(N x target), Space: O(target)"
    dp: list[int] = [0 if j > 0 else 1 for j in range(target + 1)]

    for i in range(N - 1, -1, -1):
        next_: list[int] = []
        for total in range(target + 1):
            if total == 0 or dp[total] == 1 or (total - arr[i] >= 0 and dp[total - arr[i]] == 1):
                next_.append(1)
            else:
                next_.append(0)

        dp = next_

    return bool(dp[target])

# Testing the solution
assert isSubsetSumSpaceOptimized(6, [3, 34, 4, 12, 5, 2], 9) == True
assert isSubsetSumSpaceOptimized(6, [3, 34, 4, 12, 5, 2], 30) == False
```

</div>

<div id="7a10f4ca" class="cell markdown"
papermill="{&quot;duration&quot;:1.1132e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.884848&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.873716&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Partition equal subset sum:
<https://leetcode.com/problems/partition-equal-subset-sum/> Video Link:
<https://youtu.be/7win3dcgo3k?si=LJO4Ot4EZzQ2fRc0>

</div>

<div id="373088cf" class="cell code" execution_count="32"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:35.908846Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:35.908526Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:35.913943Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:35.913478Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.9054e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.915071&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.896017&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/partition-equal-subset-sum/submissions/1253314239
def canPartition(nums: list[int]) -> bool:
    def subsetSumEqualsTarget(target: int) -> bool:
        "Time: O(N x target), Space: O(target)"
        dp: list[bool] = [False if i > 0 else True for i in range(target + 1)]
        for i in range(N - 1, -1, -1):
            next_: list[bool] = []
            for total in range(target + 1):
                if total == 0 or dp[total] or (total - nums[i] >= 0 and dp[total - nums[i]]):
                    next_.append(True)
                else:
                    next_.append(False)

            dp = next_

        return dp[target]

    N = len(nums)
    total = sum(nums)
    return total % 2 == 0 and subsetSumEqualsTarget(total // 2)

# Testing the solution
assert canPartition([1,5,11,5]) == True
assert canPartition([1,2,3,5]) == False
assert canPartition([3,3,3,4,5]) == True
```

</div>

<div id="56f6a268" class="cell markdown"
papermill="{&quot;duration&quot;:1.1214e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.938013&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.926799&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Partition Array Into Two Arrays to Minimize Sum Difference Video link:
<https://youtu.be/GS_OqZb2CWc?si=Jtc2dP_dqmNi5Zli>

</div>

<div id="00588c88" class="cell code" execution_count="33"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:35.961394Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:35.960944Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:35.966094Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:35.965624Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.8214e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.967248&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.949034&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def minimumDifferenceBrute(nums: list[int]) -> int:
    """
    Throws a TLE :(
    """
    N, total_sum = len(nums), sum(nums)
    subset_length = N // 2

    @functools.cache
    def backtrack(i: int, subset_sum: int, count: int) -> float:
        if count == subset_length:
            return abs(2 * subset_sum - total_sum)
        elif i == N:
            return math.inf
        else:
            return min(backtrack(i + 1, subset_sum + nums[i], count + 1), backtrack(i + 1, subset_sum, count))

    result = int(backtrack(0, 0, 0))
    return result

# Testing the solution
assert minimumDifferenceBrute([3,9,7,3]) == 2
assert minimumDifferenceBrute([-36,36]) == 72
assert minimumDifferenceBrute([2,-1,0,4,-2,-9]) == 0
```

</div>

<div id="97c34ef1" class="cell code" execution_count="34"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:35.991568Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:35.991021Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:35.998378Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:35.997937Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.0813e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:35.999483&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:35.978670&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def minimumDifference(nums: list[int]) -> int:
    """
    Use the DP tabulation approach we used to check if a subset with target sum exists. Still Memory limit exceeded.
    Note that this is different the one on the video. This solution is leetcode specific. In the video by Striver, the values can only be positive. Further more we can split into any size.
    In LC however, the subset must be split into 2 halves, values can be both positive and negative.
    """

    N, total_abs_sum, total_sum = len(nums), sum(map(abs, nums)), sum(nums)

    # Each value represents the length of subset summing up to target. -1 if cannot be reached.
    dp: list[int] = [-1 if j != 0 else 0 for j in range(-total_abs_sum, total_abs_sum + 1)]

    for i in range(N - 1, -1, -1):
        next_dp: list[int] = []
        for target in range(-total_abs_sum, total_abs_sum + 1):
            # Pick, subset length incremented by 1
            if 0 <= target - nums[i] + total_abs_sum <= 2 * total_abs_sum and dp[target - nums[i] + total_abs_sum] != -1:
                subset_length = dp[target - nums[i] + total_abs_sum] + 1
                existing_length = dp[target + total_abs_sum]
                next_dp.append(subset_length if existing_length != N // 2 else existing_length)
            # No pick, hence subset length is unupdated
            elif dp[target + total_abs_sum] != -1:
                next_dp.append(dp[target + total_abs_sum])
            # Base case
            elif target == 0:
                next_dp.append(0)
            # Sum cannot be reached
            else:
                next_dp.append(-1)

        dp = next_dp

    # Find out targets where value is N // 2
    min_diff: float = math.inf
    for subset_sum, subset_length in enumerate(dp, start=-total_abs_sum):
        if subset_length == N // 2:
            min_diff = min(min_diff, abs(2 * subset_sum - total_sum))

    return int(min_diff)

# Testing the solution
assert minimumDifference([3,9,7,3]) == 2
assert minimumDifference([-36,36]) == 72
assert minimumDifference([2,-1,0,4,-2,-9]) == 0
```

</div>

<div id="54752ee1" class="cell code" execution_count="35"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:36.023171Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:36.022697Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:36.027896Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:36.027466Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.8134e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.028942&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.010808&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def minSubsetSumDifference(arr: list[int], N: int) -> int:
    # Compute max total sum
    total_sum: int = sum(arr)

    # Compute DP grid for all possible subset sums
    dp: list[bool] = [False if i > 0 else True for i in range(total_sum + 1)]
    for i in range(N - 1, -1, -1):
        next_dp: list[bool] = []
        for target in range(total_sum + 1):
            if target == 0 or dp[target] or (target - arr[i] >= 0 and dp[target - arr[i]]):
                next_dp.append(True)
            else:
                next_dp.append(False)
        dp = next_dp

    # Compute the minimum subset difference
    min_diff: int = total_sum

    # total_sum / 2 since it is enough if we computed one half, diff of sum from total sum would cover the other half as well
    for target in range(math.ceil(total_sum / 2) + 1):
        if dp[target]:
            min_diff = min(min_diff, abs(2 * target - total_sum))

    return min_diff

# Testing the solution
assert minSubsetSumDifference([8,6,5], 3) == 3
```

</div>

<div id="884d535e" class="cell markdown"
papermill="{&quot;duration&quot;:1.1108e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.051641&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.040533&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Count subsets with sum k

</div>

<div id="534b55bb" class="cell code" execution_count="36"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:36.076973Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:36.076530Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:36.082578Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:36.082019Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.9748e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.083699&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.063951&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def perfectSumMemo(nums: list[int], N: int, K: int):
    """
    Time: O(N * K) + O(N); Space: O(N * K)
    """

    # Filter out all the zeros
    arr: list[int] = []
    N = zero_count = 0
    for n in nums:
        if n > 0:
            arr.append(n)
            N += 1
        else:
            zero_count += 1

    # Compute the results and store it to a list
    dp: list[list[int]] = [[-1 for j in range(K + 1)] for i in range(N)]

    # Recursively find the solution
    def backtrack(i: int, total: int) -> int:
        if total == K:
            return 1
        elif i >= N or total > K:
            return 0
        elif dp[i][total] != -1:
            return dp[i][total]
        else:
            result = backtrack(i + 1, total + arr[i]) + backtrack(i + 1, total)
            dp[i][total] = result
            return result

    return backtrack(0, 0) * (2 ** zero_count)

# Testing the solution
assert perfectSumMemo([5, 2, 3, 10, 6, 8], 6, 10) == 3
assert perfectSumMemo([1, 0], 2, 1) == 2
```

</div>

<div id="dee4da2c" class="cell code" execution_count="37"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:36.108538Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:36.108084Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:36.114037Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:36.113584Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.9773e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.115168&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.095395&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def perfectSumTabulation(nums: list[int], N: int, K: int):
    # Filter out all the zeros
    arr: list[int] = []
    N = zero_count = 0
    for n in nums:
        if n > 0:
            arr.append(n)
            N += 1
        else:
            zero_count += 1

    # Initialize a DP array
    dp: list[list[int]] = [[-1 if j < K else 1 for j in range(K + 1)] for i in range(N)]
    dp.append([0 if j < K else 1 for j in range(K + 1)])

    # Traverse through grid
    for i in range(N - 1, -1, -1):
        for total in range(K):
            dp[i][total] = dp[i + 1][total]
            if total + arr[i] <= K:
                dp[i][total] += dp[i + 1][total + arr[i]]

    return dp[0][0] * (2 ** zero_count)

# Testing the solution
assert perfectSumTabulation([5, 2, 3, 10, 6, 8], 6, 10) == 3
assert perfectSumTabulation([1, 0], 2, 1) == 2
```

</div>

<div id="2d2468ad" class="cell code" execution_count="38"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:36.140360Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:36.139911Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:36.145557Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:36.145056Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.9807e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.146717&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.126910&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def perfectSum(nums: list[int], N: int, K: int):
    # Filter out all the zeros
    arr: list[int] = []
    N = zero_count = 0
    for n in nums:
        if n > 0:
            arr.append(n)
            N += 1
        else:
            zero_count += 1

    # Initialize a DP array
    dp: list[int] = [0 if j < K else 1 for j in range(K + 1)]

    # Traverse through grid
    for i in range(N - 1, -1, -1):
        next_dp: list[int] = []
        for total in range(K + 1):
            next_dp.append(dp[total])
            if total + arr[i] <= K:
                next_dp[-1] += dp[total + arr[i]]

        dp = next_dp

    return dp[0] * (2 ** zero_count)

# Testing the solution
assert perfectSum([5, 2, 3, 10, 6, 8], 6, 10) == 3
assert perfectSum([1, 0], 2, 1) == 2
```

</div>

<div id="2bff8c7f" class="cell markdown"
papermill="{&quot;duration&quot;:1.1432e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.170058&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.158626&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Count Paritions with given difference:
<https://youtu.be/zoilQD1kYSg?si=F8PFSkzkZXEsFJ2N>

</div>

<div id="051bd113" class="cell code" execution_count="39"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:36.194339Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:36.193826Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:36.199232Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:36.198683Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.8959e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.200426&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.181467&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def countPartitionsMemo(N: int, diff: int, arr: list[int]) -> int:
    """
    s1 + s2 = S
    s1 - s2 = d
    2 * s1 = S + d

    Time: O(N x target) + O(N)
    Space: O(N x target)
    """

    # Simply check if the target exists
    target = (sum(arr) + diff) / 2

    # Count all subset sums equals target
    @functools.cache
    def backtrack(i: int, total: int) -> int:
        if i == N:
            return total == target
        elif total > target:
            return 0
        else:
            return backtrack(i + 1, total + arr[i]) + backtrack(i + 1, total)

    result = backtrack(0, 0) if target == int(target) else 0
    MOD = int(1e9 + 7)
    return result % MOD

# Testing the solution
assert countPartitionsMemo(4, 0, [1,1,1,1]) == 6
assert countPartitionsMemo(4, 3, [5,2,6,4]) == 1
assert countPartitionsMemo(5, 5, [1,3,3,2,1]) == 0
```

</div>

<div id="4cd9fbc1" class="cell code" execution_count="40"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:36.225575Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:36.224991Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:36.231441Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:36.230848Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.0124e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.232605&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.212481&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def countPartitionsTabulation(N: int, diff: int, arr: list[int]) -> int:
    """
    Time: O(N x target), Space: O(N x target)
    """
    # Simply check if the target exists
    target_: float = (sum(arr) + diff) / 2
    MOD = int(1e9 + 7)

    if int(target_) != target_:
        return 0

    else:

        # Convert to int for typing support
        target = int(target_)

        # Initialize DP array for tabulation
        dp: list[list[int]] = [[0 if j != target or i != N else 1 for j in range(target + 1)] for i in range(N + 1)]

        # Iterate through DP and find the solution
        for i in range(N - 1, -1, -1):
            for total in range(target + 1):
                dp[i][total] = dp[i + 1][total]
                if total + arr[i] <= target:
                    dp[i][total] += dp[i + 1][total + arr[i]]

        return dp[0][0]

# Testing the solution
assert countPartitionsTabulation(4, 3, [5,2,6,4]) == 1
assert countPartitionsTabulation(4, 3, [5,2,6,4]) == 1
assert countPartitionsTabulation(5, 5, [1,3,3,2,1]) == 0
```

</div>

<div id="09aacbe5" class="cell code" execution_count="41"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:36.256897Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:36.256415Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:36.262178Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:36.261709Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.8734e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.263314&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.244580&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def countPartitions(N: int, diff: int, arr: list[int]) -> int:
    # Simply check if the target exists
    target_: float = (sum(arr) + diff) / 2
    MOD = int(1e9 + 7)

    if int(target_) != target_:
        return 0

    else:
        # Convert to int for type hinting
        target = int(target_)

        # Create a 1D grid (space optimized)
        dp: list[int] = [0 if j != target else 1 for j in range(target + 1)]

        # Iterate through DP
        for i in range(N - 1, -1, -1):
            next_dp: list[int] = []
            for total in range(target + 1):
                next_dp.append(dp[total])
                if total + arr[i] <= target:
                    next_dp[-1] += dp[total + arr[i]]

            dp = next_dp

        return dp[0] % MOD

# Testing the solution
assert countPartitions(4, 3, [5,2,6,4]) == 1
assert countPartitions(4, 3, [5,2,6,4]) == 1
assert countPartitions(5, 5, [1,3,3,2,1]) == 0
```

</div>

<div id="db7bdbb0" class="cell markdown"
papermill="{&quot;duration&quot;:1.1096e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.286060&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.274964&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video Link: <https://youtu.be/GqOmJHQZivw?si=dHaZZvKQa2PHaukO> 0/1
Knapsack

</div>

<div id="51fdc55d" class="cell code" execution_count="42"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:36.310149Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:36.309615Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:36.314849Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:36.314339Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.8378e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.315986&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.297608&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def knapsack01Memo(N: int, max_weight: int, weights: list[int], values: list[int]) -> int:
    """
    Time complexity without memoization: O(2 ** N), Space: O(N).
    Post memoization: O(N x max_weight), Space: O(N x max_weight)
    """
    @functools.cache
    def backtrack(i: int, total_weight: int) -> float:
        """
        Intuition: Till index i, what is the max value, we can accumulate with max_weight as total_weight.
        """
        if total_weight > max_weight:
            return -math.inf
        elif i >= N:
            return 0
        else:
            pick = values[i] + backtrack(i + 1, total_weight + weights[i])
            nopick = backtrack(i + 1, total_weight)
            return max(pick, nopick)

    result = backtrack(0, 0)
    return int(max(result, 0))

# Testing the solution
assert knapsack01Memo(4, 5, [1,2,4,5], [5,4,8,6]) == 13
assert knapsack01Memo(3, 8, [3,4,5], [30,50,60]) == 90
```

</div>

<div id="e0b05d00" class="cell code" execution_count="43"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:36.339588Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:36.339072Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:36.344808Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:36.344219Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.8874e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.345996&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.327122&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def knapsack01Tabulation(N: int, max_weight: int, weights: list[int], values: list[int]) -> int:
    dp: list[list[int]] = [[-1 if i < N else 0 for j in range(max_weight + 1)] for i in range(N + 1)]
    for i in range(N - 1, -1, -1):
        for total_weight in range(max_weight + 1):
            # No pick
            dp[i][total_weight] = dp[i + 1][total_weight]

            # Pick
            if total_weight + weights[i] <= max_weight:
                dp[i][total_weight] = max(dp[i][total_weight], values[i] + dp[i + 1][total_weight + weights[i]])

    return dp[0][0]

# Testing the solution
assert knapsack01Tabulation(4, 5, [1,2,4,5], [5,4,8,6]) == 13
assert knapsack01Tabulation(3, 8, [3,4,5], [30,50,60]) == 90
```

</div>

<div id="045af9de" class="cell code" execution_count="44"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:36.369585Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:36.369090Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:36.374522Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:36.373973Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.8254e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.375622&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.357368&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def knapsack01SpaceOptimized(N: int, max_weight: int, weights: list[int], values: list[int]) -> int:
    dp: list[int] = [0 for j in range(max_weight + 1)]
    for i in range(N - 1, -1, -1):
        next_dp: list[int] = []
        for total_weight in range(max_weight + 1):
            next_dp.append(dp[total_weight]) # No pick
            if weights[i] + total_weight <= max_weight:
                next_dp[-1] = max(next_dp[-1], values[i] + dp[weights[i] + total_weight]) # Pick
        dp = next_dp

    return dp[0]

# Testing the solution
assert knapsack01SpaceOptimized(4, 5, [1,2,4,5], [5,4,8,6]) == 13
assert knapsack01SpaceOptimized(3, 8, [3,4,5], [30,50,60]) == 90
```

</div>

<div id="b6d1c8d2" class="cell code" execution_count="45"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:36.399355Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:36.398898Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:36.404220Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:36.403660Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.8573e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.405372&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.386799&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def knapsack01(N: int, max_weight: int, weights: list[int], values: list[int]) -> int:
    """
    Space optimization to use just a single row. This is possible because
    in the inner loop we are moving from the left to right and at each iteration
    we are using the element to the right, we have no need of the element to the left

    [x . . . . . . * . . . ]
    [. x . . . * . . . . . ]
    [. . x . . . . . * . . ]

    At the inner loop we had required the value of the element to the left, this would not have been possible.
    """
    dp: list[int] = [0 for j in range(max_weight + 1)]
    for i in range(N - 1, -1, -1):
        for total_weight in range(max_weight + 1):
            if weights[i] + total_weight <= max_weight:
                dp[total_weight] = max(dp[total_weight], values[i] + dp[total_weight + weights[i]])

    return dp[0]

# Testing the solution
assert knapsack01(4, 5, [1,2,4,5], [5,4,8,6]) == 13
assert knapsack01(3, 8, [3,4,5], [30,50,60]) == 90
```

</div>

<div id="71d6293a" class="cell markdown"
papermill="{&quot;duration&quot;:1.1214e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.427891&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.416677&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video link: <https://youtu.be/myPeWb3Y68A?si=9z1QMQXCYmEcFEW4> Coin
Change:
<https://leetcode.com/problems/coin-change/submissions/1255049748>
Logic: Whenever there is an infinite / unlimited supply, not_take would
update the index, <br> take would not update index - it would stay where
it is because we might end up picking it more than once

</div>

<div id="93a2c45e" class="cell code" execution_count="46"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:36.451250Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:36.450977Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:36.455948Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:36.455419Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.8055e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.457157&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.439102&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def coinChangeMemoization(coins: list[int], amount: int) -> int:
    """
    Without memoization, the time complexity is roughly 2 ** N. It would be greater than
    2 ** N since at each index for take we are still staying at the same index.

    With memoization, the time complexity is O(N x amount)
    """
    @functools.cache
    def backtrack(i: int, total: int) -> float:
        if total == amount:
            return 0
        elif i == N or total > amount:
            return math.inf
        else:
            return min(1 + backtrack(i, total + coins[i]), backtrack(i + 1, total))

    N = len(coins)
    result = backtrack(0, 0)
    return int(result) if not math.isinf(result) else -1

# Testing the solution
assert coinChangeMemoization([1,2,5], 11) == 3
assert coinChangeMemoization([2], 3) == -1
```

</div>

<div id="eb1b662f" class="cell code" execution_count="47"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:36.480908Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:36.480397Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:36.486039Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:36.485473Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.8793e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.487158&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.468365&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def coinChangeTabulation(coins: list[int], amount: int) -> int:
    N = len(coins)
    dp: list[list[float]] = [[math.inf if j < amount else 0 for j in range(amount + 1)] for i in range(N + 1)]
    for i in range(N - 1, -1, -1):
        for total in range(amount, -1, -1):
            if total + coins[i] <= amount:
                dp[i][total] = min(dp[i + 1][total], 1 + dp[i][total + coins[i]])
            else:
                dp[i][total] = dp[i + 1][total]

    result = dp[0][0]
    return int(result) if not math.isinf(result) else -1

# Testing the solution
assert coinChangeTabulation([1,2,5], 11) == 3
assert coinChangeTabulation([2], 3) == -1
```

</div>

<div id="ddd554c7" class="cell code" execution_count="48"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:36.511149Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:36.510619Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:36.515704Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:36.515150Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.8451e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.516910&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.498459&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def coinChangeSpaceOptimized(coins: list[int], amount: int) -> int:
    N = len(coins)
    dp: list[float] = [math.inf if j < amount else 0 for j in range(amount + 1)]
    for i in range(N - 1, -1, -1):
        for total in range(amount, -1, -1):
            if total + coins[i] <= amount:
                dp[total] = min(dp[total], 1 + dp[total + coins[i]])

    result = dp[0]
    return int(result) if not math.isinf(result) else -1

# Testing the solution
assert coinChangeSpaceOptimized([1,2,5], 11) == 3
assert coinChangeSpaceOptimized([2], 3) == -1
```

</div>

<div id="3e5fb6cb" class="cell markdown"
papermill="{&quot;duration&quot;:1.1005e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.539574&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.528569&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video Link: <https://youtu.be/b3GD8263-PQ?si=CNz-raf3oynQQsPJ> Target
Sum: <https://leetcode.com/problems/target-sum/>

</div>

<div id="18960ee2" class="cell code" execution_count="49"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:36.563568Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:36.563037Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:36.567828Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:36.567356Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.8001e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.568964&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.550963&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/target-sum/submissions/1255976702
def findTargetSumWaysMemo(nums: list[int], target: int) -> int:
    @functools.cache
    def backtrack(i: int, total: int) -> int:
        if i == N:
            return int(total == target)
        else:
            return backtrack(i + 1, total - nums[i]) + backtrack(i + 1, total + nums[i])

    N = len(nums)
    return backtrack(0, 0)

# Testing the solution
assert findTargetSumWaysMemo([1,1,1,1,1], 3) == 5
assert findTargetSumWaysMemo([1], 2) == 0
```

</div>

<div id="8420cf7b" class="cell code" execution_count="50"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:36.592205Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:36.591776Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:36.597658Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:36.597163Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.8761e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.598778&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.580017&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def findTargetSumWaysTab(nums: list[int], target: int) -> int:
    N: int = len(nums)
    boundary: int = sum(nums)
    dp: list[list[int]] = [[0 if i < N or j != target else 1 for j in range(-boundary, boundary + 1)] for i in range(N + 1)]

    for i in range(N - 1, -1, -1):
        for total in range(-boundary, boundary + 1):
            if total - nums[i] + boundary >= 0:
                dp[i][total + boundary] += dp[i + 1][total - nums[i] + boundary]
            if total + nums[i] + boundary <= 2 * boundary:
                dp[i][total + boundary] += dp[i + 1][total + nums[i] + boundary]

    return dp[0][boundary]

# Testing the solution
assert findTargetSumWaysTab([1,1,1,1,1], 3) == 5
assert findTargetSumWaysTab([1], 2) == 0
```

</div>

<div id="7c66396e" class="cell code" execution_count="51"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:36.622869Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:36.622413Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:36.627666Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:36.627146Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.8487e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.628766&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.610279&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/target-sum/submissions/1255976333/
def findTargetSumWays(nums: list[int], target: int) -> int:
    N = len(nums)
    boundary: int = sum(nums)
    dp: list[int] = [0 if j != target else 1 for j in range(-boundary, boundary + 1)]

    for i in range(N - 1, -1, -1):
        next_dp: list[int] = []
        for total in range(-boundary, boundary + 1):
            next_dp.append(0)
            if total + nums[i] + boundary <= 2 * boundary:
                next_dp[-1] += dp[total + nums[i] + boundary]
            if total - nums[i] + boundary >= 0:
                next_dp[-1] += dp[total - nums[i] + boundary]

        dp = next_dp

    return dp[boundary]

# Testing the solution
assert findTargetSumWays([1,1,1,1,1], 3) == 5
assert findTargetSumWays([1], 2) == 0
```

</div>

<div id="8f0e96f1" class="cell code" execution_count="52"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:36.652538Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:36.652206Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:36.658293Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:36.657758Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.9408e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.659325&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.639917&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Striver's approach: Use logic from 'Count Paritions with given difference'
# https://leetcode.com/problems/target-sum/submissions/1255993345/
def findTargetSumWaysStriver(nums: list[int], target: int) -> int:
    """
    We need to count the number of subsets s1, s2 such that s1 - s2 = target.
    s1 = (S + d) / 2
    """

    S = sum(nums)
    s1 = (S + target) / 2
    s2 = S - s1

    # Edge case - target is negative.
    if s1 < 0:
        s1 = s2

    count = 0
    if int(s1) == s1:
        s1 = int(s1)
        zero_count = nums.count(0)
        nums = list(filter(lambda x: x != 0, nums))
        N = len(nums)
        dp: list[int] = [0 if j < s1 else 1 for j in range(s1 + 1)]
        for i in range(N - 1, -1, -1):
            for total in range(s1 + 1):
                if total + nums[i] <= s1:
                    dp[total] += dp[total + nums[i]]

        count = dp[0] * (2 ** zero_count)

    return count

# Testing the solution
assert findTargetSumWaysStriver([1,1,1,1,1], 3) == 5
assert findTargetSumWaysStriver([1,0,0], 1) == 4
assert findTargetSumWaysStriver([100], -200) == 0
assert findTargetSumWaysStriver([100], -100) == 1
```

</div>

<div id="54ee6894" class="cell markdown"
papermill="{&quot;duration&quot;:1.1536e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.682446&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.670910&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video link: <https://youtu.be/HgyouUi11zk?si=tgZcsIOYwWogacGr> Coin
Change II: <https://leetcode.com/problems/coin-change-ii/description/>

</div>

<div id="a21ca5a5" class="cell code" execution_count="53"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:36.706030Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:36.705619Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:36.710212Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:36.709701Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.7585e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.711273&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.693688&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def coinChangeMemo(amount: int, coins: list[int]):
    """
    Time: ~O(N x amount), Space: O(N x amount) + O(amount)
    """

    @functools.cache
    def backtrack(i: int, total: int) -> int:
        if total == amount:
            return 1
        elif total > amount or i == N:
            return 0
        else:
            return backtrack(i, total + coins[i]) + backtrack(i + 1, total)

    N = len(coins)
    return backtrack(0, 0)

# Testing the solution
assert coinChangeMemo(5, [1,2,5]) == 4
assert coinChangeMemo(3, [2]) == 0
```

</div>

<div id="b74d7fa9" class="cell code" execution_count="54"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:36.735295Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:36.734791Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:36.739327Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:36.738851Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.7805e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.740439&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.722634&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/coin-change-ii/submissions/1256028931
def coinChangeTab(amount: int, coins: list[int]):
    N = len(coins)
    dp: list[int] = [0 if j != amount else 1 for j in range(amount + 1)]
    for i in range(N - 1, -1, -1):
        for total in range(amount, -1, -1):
            if total + coins[i] <= amount:
                dp[total] += dp[total + coins[i]]

    return dp[0]

# Testing the solution
assert coinChangeTab(5, [1,2,5]) == 4
assert coinChangeTab(3, [2]) == 0
```

</div>

<div id="b0b593c4" class="cell markdown"
papermill="{&quot;duration&quot;:1.1212e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.763104&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.751892&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video Link: <https://youtu.be/OgvOZ6OrJoY?si=rcbpx6IrU_SvQ4v1> Unbounded
Knapsack

</div>

<div id="5fc22211" class="cell code" execution_count="55"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:36.786720Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:36.786220Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:36.791015Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:36.790584Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.7865e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.792076&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.774211&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def unboundedKnapSackMemo(N: int, max_weight: int, values: list[int], weights: list[int]) -> int:
     @functools.cache
     def backtrack(i: int, total_weight: int) -> float:
         if total_weight > max_weight:
             return -math.inf
         elif i == N:
             return 0
         else:
             return max(values[i] + backtrack(i, total_weight + weights[i]), backtrack(i + 1, total_weight))

     return int(backtrack(0, 0))

# Testing the solution
assert unboundedKnapSackMemo(2, 3, [1, 1], [2, 1]) == 3
assert unboundedKnapSackMemo(4, 8, [6, 1, 7, 7], [1, 3, 4, 5]) == 48
```

</div>

<div id="3377312f" class="cell code" execution_count="56"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:36.816165Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:36.815645Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:36.820363Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:36.819902Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.7778e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.821477&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.803699&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def unboundedKnapSackTab(N: int, max_weight: int, values: list[int], weights: list[int]) -> int:
    dp: list[int] = [0 for j in range(max_weight + 1)]
    for i in range(N - 1, -1, -1):
        for total in range(max_weight, -1, -1):
            if total + weights[i] <= max_weight:
                dp[total] = max(dp[total], values[i] + dp[total + weights[i]])

    return dp[0]

# Testing the solution
assert unboundedKnapSackTab(2, 3, [1, 1], [2, 1]) == 3
assert unboundedKnapSackTab(4, 8, [6, 1, 7, 7], [1, 3, 4, 5]) == 48
```

</div>

<div id="2d0c40ff" class="cell markdown"
papermill="{&quot;duration&quot;:1.1275e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.844480&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.833205&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video Link: <https://youtu.be/mO8XpGoJwuo?si=uzBPZ8auw70L9WCm> Rod
cutting Problem

</div>

<div id="aee57cd8" class="cell code" execution_count="57"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:36.868237Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:36.867645Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:36.872659Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:36.872215Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.8134e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.873727&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.855593&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def cutRodMemo(price: list[int], N: int) -> int:
    @functools.cache
    def backtrack(i: int, length: int) -> float:
        if length == 0:
            return 0
        elif i == N or length < 0:
            return -math.inf
        else:
            return max(price[i] + backtrack(i, length - i - 1), backtrack(i + 1, length))

    result = backtrack(0, N)
    return int(result)

# Testing the solution
assert cutRodMemo([1, 5, 8, 9, 10, 17, 17, 20], 8) == 22
assert cutRodMemo([3, 5, 8, 9, 10, 17, 17, 20], 8) == 24
```

</div>

<div id="bcdf21dd" class="cell code" execution_count="58"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:36.897473Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:36.897003Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:36.901915Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:36.901454Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.8032e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.902965&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.884933&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def cutRodTab(price: list[int], N: int) -> int:
    dp: list[float] = [-math.inf if j > 0 else 0 for j in range(N + 1)]
    for i in range(N - 1, -1, -1):
        for length in range(N + 1):
            if length - i - 1 >= 0:
                dp[length] = max(dp[length], price[i] + dp[length - i - 1])

    return int(dp[N])

# Testing the solution
assert cutRodTab([1, 5, 8, 9, 10, 17, 17, 20], 8) == 22
assert cutRodTab([3, 5, 8, 9, 10, 17, 17, 20], 8) == 24
```

</div>

<div id="8e8177cc" class="cell markdown"
papermill="{&quot;duration&quot;:1.1093e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.925583&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.914490&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video link: <https://youtu.be/NPZn9jBrX8U?si=RNey3xHjlEm1LXyr> Longest
common subsequences:
<https://leetcode.com/problems/longest-common-subsequence> Naive
approach: Generate all subsequences O((2 \*\* N) x (2 \*\* M)) and
compare common subsequences in both

</div>

<div id="917d5e52" class="cell code" execution_count="59"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:36.949543Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:36.949149Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:36.954379Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:36.953865Z&quot;}"
papermill="{&quot;duration&quot;:1.9125e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.955946&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.936821&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def longestCommonSubsequenceMemo(text1: str, text2: str) -> int:
    # Time: O(N x M), Space: O(N x M) + O(M + N)
    @functools.cache
    def backtrack(i: int, j: int) -> int:
        if i == N1 or j == N2:
            return 0
        elif text1[i] == text2[j]:
            return 1 + backtrack(i + 1, j + 1)
        else:
            return max(backtrack(i + 1, j), backtrack(i, j + 1))

    N1, N2 = len(text1), len(text2)
    return backtrack(0, 0)

# Testing the solution
assert longestCommonSubsequenceMemo("abcde", "ace") == 3
assert longestCommonSubsequenceMemo("bsbininm", "jmjkbkjkv") == 1
assert longestCommonSubsequenceMemo("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa") == 35
assert longestCommonSubsequenceMemo("bl", "yby") == 1
```

</div>

<div id="30813726" class="cell code" execution_count="60"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:36.986668Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:36.986340Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:36.992665Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:36.992140Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.9775e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:36.993820&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:36.974045&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def longestCommonSubsequenceTab(text1: str, text2: str) -> int:
    # Time: O(M x N), Space: O(N x M)
    N1, N2 = len(text1), len(text2)
    dp: list[list[int]] = [[0 for j in range(N2 + 1)] for i in range(N1 + 1)]
    for i in range(N1 - 1, -1, -1):
        for j in range(N2 - 1, -1, -1):
            if text1[i] == text2[j]:
                dp[i][j] = 1 + dp[i + 1][j + 1]
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j + 1])

    return dp[0][0]

# Testing the solution
assert longestCommonSubsequenceTab("abcde", "ace") == 3
assert longestCommonSubsequenceTab("bsbininm", "jmjkbkjkv") == 1
assert longestCommonSubsequenceTab("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa") == 35
assert longestCommonSubsequenceTab("bl", "yby") == 1
```

</div>

<div id="e099ef3b" class="cell code" execution_count="61"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:37.017945Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:37.017607Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:37.022820Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:37.022363Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.8304e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:37.023855&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:37.005551&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/longest-common-subsequence/submissions/1256127917
def longestCommonSubsequence(text1: str, text2: str) -> int:
    # Time: O(M x N), Space: O(N2 + N2)
    N1, N2 = len(text1), len(text2)
    dp: list[int] = [0 for j in range(N2 + 1)]
    for i in range(N1 - 1, -1, -1):
        next_dp: list[int] = list(dp)
        for j in range(N2 - 1, -1, -1):
            if text1[i] == text2[j]:
                next_dp[j] = 1 + dp[j + 1]
            else:
                next_dp[j] = max(dp[j], next_dp[j + 1])

        dp = next_dp

    return dp[0]

# Testing the solution
assert longestCommonSubsequence("abcde", "ace") == 3
assert longestCommonSubsequence("bsbininm", "jmjkbkjkv") == 1
assert longestCommonSubsequence("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa") == 35
assert longestCommonSubsequence("bl", "yby") == 1
```

</div>

<div id="e01786f1" class="cell markdown"
papermill="{&quot;duration&quot;:1.1138e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:37.046253&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:37.035115&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video Link: <https://youtu.be/-zI4mrF2Pb4?si=8kICsv0E7jYx6sWn> Print
longest common subsequece

</div>

<div id="1c0d3fe8" class="cell code" execution_count="62"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:37.071136Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:37.070683Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:37.078023Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:37.077467Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:2.176e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:37.079217&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:37.057457&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def all_longest_common_subsequences(text1: str, text2: str) -> list[str]:
    """
    DP grid computes the longest common subseq length given starting pos of text1, text2
    We start at -1, -1 on the grid.
    If text1[i] == text2[j], we know that the line: 1 + dp[i + 1][j + 1] was executed, there we increment both i, j by 1
    If text1[i] != text2[j], either the max came from text1 or text2. If only one max exists, recurse into that else recurse through both

    Time: DP grid compute: O(M x N) + Backtracking to find longest common subsequence: O(M + N)
    Space: O(M x N)
    """

    N1, N2 = len(text1), len(text2)
    dp: list[list[int]] = [[0 for j in range(N2 + 1)] for i in range(N1 + 1)]
    for i in range(N1 - 1, -1, -1):
        for j in range(N2 - 1, -1, -1):
            if text1[i] == text2[j]:
                dp[i][j] = 1 + dp[i + 1][j + 1]
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j + 1])

    def backtrack(i: int, j: int):
        if dp[i][j] == 0:
            result.add(''.join(stack))
            return
        elif text1[i] == text2[j]:
            stack.append(text1[i])
            backtrack(i + 1, j + 1)
            stack.pop()
        else:
            max_ = max(dp[i + 1][j], dp[i][j + 1])
            if dp[i + 1][j] == max_:
                backtrack(i + 1, j)
            if dp[i][j + 1] == max_:
                backtrack(i, j + 1)

    result: set[str] = set()
    stack: list[str] = []
    backtrack(i, j)
    return sorted(result)

# Tesitng the solution
assert all_longest_common_subsequences("abcde", "ace") == ['ace']
assert all_longest_common_subsequences("abaaa", "baabaca") == ['aaaa', 'abaa', 'baaa']
```

</div>

<div id="1b3c52ec" class="cell markdown"
papermill="{&quot;duration&quot;:1.1276e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:37.101859&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:37.090583&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video Link: <https://youtu.be/_wP9mWNPL5w?si=UHRuFgDl6a5g8OlH> Longest
common Substring

</div>

<div id="95b817c0" class="cell code" execution_count="63"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:37.125466Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:37.124963Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:37.129977Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:37.129537Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.8119e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:37.131054&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:37.112935&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def longestCommonSubstrTab(text1: str, text2: str) -> int:
    """
    Same code as longest common subsequence but with a slight modification.
    Here we reset the dp table value to 0 if text1[i] != text2[j] instead of getting the max of dp[i + 1][j] or dp[i][j + 1] since we are not allowed non consequetive values.

    Time: O(N1 x N2), Space: O(N1 x N2)
    """
    N1, N2 = len(text1), len(text2)
    dp: list[list[int]] = [[0 for j in range(N2 + 1)] for i in range(N1 + 1)]
    max_length = 0
    for i in range(N1 - 1, -1, -1):
        for j in range(N2 - 1, -1, -1):
            if text1[i] == text2[j]:
                dp[i][j] = dp[i + 1][j + 1] + 1
                max_length = max(max_length, dp[i][j])

    return max_length

# Testing the solution
assert longestCommonSubstrTab("ABCDGH", "ACDGHR") == 4
assert longestCommonSubstrTab("ABC", "ACB") == 1
```

</div>

<div id="f32221a7" class="cell code" execution_count="64"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:37.155380Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:37.154883Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:37.159987Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:37.159443Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.8717e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:37.161179&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:37.142462&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def longestCommonSubstr(text1: str, text2: str) -> int:
    """Time: O(N1 x N2), Space: O(N2)"""
    N1, N2 = len(text1), len(text2)
    dp: list[int] = [0 for j in range(N2 + 1)]
    max_length = 0
    for i in range(N1 - 1, -1, -1):
        next_dp: list[int] = [0]
        for j in range(N2 - 1, -1, -1):
            if text1[i] == text2[j]:
                next_dp.append(1 + dp[j + 1])
                max_length = max(max_length, next_dp[-1])
            else:
                next_dp.append(0)

        dp = list(reversed(next_dp))

    return max_length

# Testing the solution
assert longestCommonSubstr("ABCDGH", "ACDGHR") == 4
assert longestCommonSubstr("ABC", "ACB") == 1
```

</div>

<div id="32bd7ea7" class="cell markdown"
papermill="{&quot;duration&quot;:1.1336e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:37.184251&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:37.172915&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video Link: <https://youtu.be/6i_T5kkfv4A?si=3pJmCMahWgxxnGRq> Longest
Palindromic Subsequence

</div>

<div id="d0a53967" class="cell code" execution_count="65"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:37.208306Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:37.207842Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:37.212427Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:37.211896Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.8047e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:37.213516&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:37.195469&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/longest-palindromic-subsequence/submissions/1256744931
def longestPalindromeSubseqMemo(text: str) -> int:
    @functools.cache
    def backtrack(i: int, j: int) -> int:
        if i >= j:
            return int(i == j)
        elif text[i] == text[j]:
            return 2 + backtrack(i + 1, j - 1)
        else:
            return max(backtrack(i + 1, j), backtrack(i, j - 1))

    N = len(text)
    result = backtrack(0, N - 1)
    return result

# Testing the solution
assert longestPalindromeSubseqMemo("bbbab") == 4
assert longestPalindromeSubseqMemo("cbbd") == 2
```

</div>

<div id="c5612366" class="cell code" execution_count="66"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:37.237711Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:37.237215Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:37.242315Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:37.241881Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.8438e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:37.243424&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:37.224986&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def longestPalindromeSubseqTab(text: str) -> int:
    N = len(text)
    dp: list[list[int]] = [[0 if j != (N - 1) / 2 else 1 for j in range(N + 1)] for i in range(N + 1)]
    for i in range(N - 1, -1, -1):
        for j in range(N):
            if i >= j:
                dp[i][j] = int(i == j)
            elif text[i] == text[j]:
                dp[i][j] = 2 + dp[i + 1][j - 1]
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])

    return dp[0][N - 1]

# Testing the solution
assert longestPalindromeSubseqTab("bbbab") == 4
assert longestPalindromeSubseqTab("cbbd") == 2
```

</div>

<div id="a74fa1d5" class="cell code" execution_count="67"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:37.267485Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:37.267062Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:37.272089Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:37.271620Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.826e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:37.273184&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:37.254924&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/longest-palindromic-subsequence/submissions/1256759252
def longestPalindromeSubseq(text: str) -> int:
    N = len(text)
    dp: list[int] = [0 if j != (N - 1) / 2 else 1 for j in range(N + 1)]
    for i in range(N - 1, -1, -1):
        next_dp: list[int] = []
        for j in range(N):
            if i >= j:
                next_dp.append(int(i == j))
            elif text[i] == text[j]:
                next_dp.append(2 + dp[j - 1])
            else:
                next_dp.append(max(dp[j], next_dp[-1]))

        # We run the inner loop for N iterations, dp however has a length of N + 1
        # Hence we add 0 in the end to make sure that the values are consistent of DP compute
        # We could make this simpler by initializing next_dp as list(dp), but that would
        # be wasted O(N) runtime.
        next_dp.append(0)
        dp = next_dp

    return dp[N - 1]

# Testing the solution
assert longestPalindromeSubseq("bbbab") == 4
assert longestPalindromeSubseq("cbbd") == 2
```

</div>

<div id="e94ba584" class="cell code" execution_count="68"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:37.297776Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:37.297326Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:37.302469Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:37.301938Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.8594e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:37.303604&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:37.285010&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def longestPalindromeSubseqStriver(text: str) -> int:
    """
    1. We reverse text.
    2. Whatever value is the LCS of both the texts, that is our desired answer
    """
    def LCS(text1: str, text2: str) -> int:
        N = len(text1)
        dp: list[int] = [0 for j in range(N + 1)]
        for i in range(N - 1, -1, -1):
            next_dp: list[int] = list(dp)
            for j in range(N - 1, -1, -1):
                if text1[i] == text2[j]:
                    next_dp[j] = 1 + dp[j + 1]
                else:
                    next_dp[j] = max(dp[j], next_dp[j + 1])
            dp = next_dp

        return dp[0]

    return LCS(text, text[::-1])

# Testing the solution
assert longestPalindromeSubseqStriver("bbbab") == 4
assert longestPalindromeSubseqStriver("cbbd") == 2
```

</div>

<div id="5a62593a" class="cell code" execution_count="69"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:37.327661Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:37.327257Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:37.329924Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:37.329475Z&quot;}"
papermill="{&quot;duration&quot;:1.5944e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:37.331042&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:37.315098&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# Video link: https://youtu.be/xPBLEj41rFU?si=TkaEwZIQqY7WkasB
# Minimum insertions to make a string palindromic
```

</div>

<div id="a73343a1" class="cell code" execution_count="70"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:37.355471Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:37.354916Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:37.359831Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:37.359363Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.8502e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:37.360999&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:37.342497&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/submissions/1256992480/
def minInsertions(text: str) -> int:
    """
    1. Find the longest palindromic substring
    2. Minimum insertions required would be length of the N - longest palindromic substr
    """

    @functools.cache
    def longestPalindromicSubstrLength(i: int, j: int) -> int:
        if i >= j:
            return int(i == j)
        elif text[i] == text[j]:
            return 2 + longestPalindromicSubstrLength(i + 1, j - 1)
        else:
            return max(longestPalindromicSubstrLength(i + 1, j), longestPalindromicSubstrLength(i, j - 1))

    N = len(text)
    return N - longestPalindromicSubstrLength(0, N - 1)

# Testing the solution
assert minInsertions("mbadm") == 2
assert minInsertions("leetcode") == 5
```

</div>

<div id="76604d02" class="cell markdown"
papermill="{&quot;duration&quot;:1.1144e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:37.383774&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:37.372630&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Minimum ops to convert s1 to s2 Video Link:
<https://youtu.be/yMnH0jrir0Q?si=WNsLNkqd3rhHqzDX>

</div>

<div id="07d4a7a1" class="cell code" execution_count="71"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-13T16:03:37.408646Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-13T16:03:37.408047Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-13T16:03:37.415226Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-13T16:03:37.414735Z&quot;}"
papermill="{&quot;duration&quot;:2.1004e-2,&quot;end_time&quot;:&quot;2024-05-13T16:03:37.416466&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-13T16:03:37.395462&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/delete-operation-for-two-strings/submissions/1257015539
def minDistance(word1: str, word2: str) -> int:
    """
    The idea is to think about what characters we should leave untouched. In this
    case, we can leave out characters that are subsequences also present in word2.o

    Hence logic: Find length of longest common subsequence -> (N1 - S) + (N2 - S)
    """
    N1, N2 = len(word1), len(word2)
    dp: list[int] = [0 for j in range(N2 + 1)]
    for i in range(N1 - 1, -1, -1):
        next_dp: list[int] = [0]
        for j in range(N2 - 1, -1, -1):
            if word1[i] == word2[j]:
                next_dp.append(1 + dp[j + 1])
            else:
                next_dp.append(max(dp[j], next_dp[-1]))

        next_dp.reverse()
        dp = next_dp

    substr_length = dp[0]
    return (N1 - substr_length) + (N2 - substr_length)

# Testing the solution
assert minDistance("leetcode", "etco") == 4
assert minDistance("sea", "eat") == 2
```

</div>
