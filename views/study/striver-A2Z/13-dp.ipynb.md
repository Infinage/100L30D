---
jupyter:
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
  language_info:
    codemirror_mode:
      name: ipython
      version: 3
    file_extension: .py
    mimetype: text/x-python
    name: python
    nbconvert_exporter: python
    pygments_lexer: ipython3
    version: 3.11.9
  nbformat: 4
  nbformat_minor: 5
  papermill:
    default_parameters: {}
    duration: 1.866125
    end_time: "2024-05-09T07:01:30.030534"
    environment_variables: {}
    input_path: study/striver-A2Z/13-dp.ipynb
    output_path: study/striver-A2Z/13-dp.ipynb
    parameters: {}
    start_time: "2024-05-09T07:01:28.164409"
    version: 2.6.0
---

<div id="457ab51f" class="cell markdown"
papermill="{&quot;duration&quot;:5.964e-3,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.188633&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.182669&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

### Some important imports

</div>

<div id="164d751b" class="cell code" execution_count="1"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-09T07:01:29.200194Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-09T07:01:29.199717Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-09T07:01:29.204865Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-09T07:01:29.204366Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.2139e-2,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.206038&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.193899&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
import functools
import itertools
import collections
import math
import heapq
```

</div>

<div id="48648354" class="cell markdown"
papermill="{&quot;duration&quot;:5.223e-3,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.217306&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.212083&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Introduction to DP: <https://youtu.be/tyB0ztf0DNY?si=SgpBwGNqPXzdPSRA>

1.  Tabulation: Bottom up DP: Ans -\> Base case -\> Ans
2.  Memoization: Top down DP: Base case -\> Ans

</div>

<div id="41c46591" class="cell code" execution_count="2"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-09T07:01:29.228558Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-09T07:01:29.228390Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-09T07:01:29.234189Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-09T07:01:29.233760Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.2675e-2,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.235192&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.222517&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def fiboBrute(n: int) -> int:
    """
    Vanilla recursion
    Time: O(2 ^ N), Space: O(2 ^ N)
    """
    if n <= 1:
        return n
    else:
        return fiboBrute(n - 1) + fiboBrute(n - 2)

fiboBrute(10)
```

<div class="output execute_result" execution_count="2">

    55

</div>

</div>

<div id="83ba7cd5" class="cell code" execution_count="3"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-09T07:01:29.246904Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-09T07:01:29.246456Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-09T07:01:29.251667Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-09T07:01:29.251160Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.2155e-2,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.252742&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.240587&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def fiboBetter1(n: int) -> int:
    """
    Memoization Approach: Top down approach
    Time: O(N), Space: O(N) + O(N)
    """
    dp: list[int] = [-1 for i in range(n + 1)]
    def backtrack(curr: int) -> int:
        if curr <= 1:
            return curr
        elif dp[curr] != -1:
            return dp[curr]
        else:
            dp[curr] = backtrack(curr - 1) + backtrack(curr - 2)
            return dp[curr]

    return backtrack(n)

fiboBetter1(10)
```

<div class="output execute_result" execution_count="3">

    55

</div>

</div>

<div id="80fded7e" class="cell code" execution_count="4"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-09T07:01:29.264435Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-09T07:01:29.264083Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-09T07:01:29.268739Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-09T07:01:29.268232Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.1672e-2,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.269809&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.258137&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def fiboBetter2(n: int) -> int:
    """
    Tabulation: Bottom up approach
    Time: O(N), Space: O(N)
    """
    dp: list[int] = [-1 if i > 1 else i for i in range(n + 1)]
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]

    return dp[n]

fiboBetter2(10)
```

<div class="output execute_result" execution_count="4">

    55

</div>

</div>

<div id="8f7d86e2" class="cell code" execution_count="5"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-09T07:01:29.281646Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-09T07:01:29.281273Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-09T07:01:29.285578Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-09T07:01:29.285066Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.139e-2,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.286580&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.275190&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def fiboOptimal(n: int) -> int:
    """
    Bottom up approach
    Time: O(N), Space: O(1)
    """
    prev2, prev1 = 0, 1
    for i in range(2, n + 1):
        prev2, prev1 = prev1, prev1 + prev2
        n -= 1

    return prev1

fiboOptimal(10)
```

<div class="output execute_result" execution_count="5">

    55

</div>

</div>

<div id="855c35fb" class="cell markdown"
papermill="{&quot;duration&quot;:5.386e-3,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.297430&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.292044&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Climbing Stairs: <https://leetcode.com/problems/climbing-stairs/> Video
Link: <https://youtu.be/mLfjzJsN8us?si=C7W-jiYvql0mEnbh>

</div>

<div id="87993489" class="cell code" execution_count="6"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-09T07:01:29.309351Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-09T07:01:29.309070Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-09T07:01:29.312884Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-09T07:01:29.312338Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.097e-2,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.313898&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.302928&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def climbStairsBetter(n: int) -> int:
    """Time: O(N), Space: O(N)"""

    dp: list[int] = [-1 for i in range(n + 1)]
    def backtrack(curr: int) -> int:
        if curr <= 1:
            return 1
        elif dp[curr] != -1:
            return dp[curr]
        else:
            dp[curr] = backtrack(curr - 1) + backtrack(curr - 2)
            return dp[curr]

    return backtrack(n)

assert climbStairsBetter(45) == 1836311903
```

</div>

<div id="2dc15ac3" class="cell code" execution_count="7"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-09T07:01:29.325811Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-09T07:01:29.325420Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-09T07:01:29.328631Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-09T07:01:29.328060Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.0174e-2,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.329637&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.319463&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def climbStairs(n: int) -> int:
    """Time: O(N), Space: O(1)"""
    prev2, prev1 = 1, 1
    while n > 0:
        prev2, prev1 = prev1, prev1 + prev2
        n -= 1

    return prev2

assert climbStairs(45) == 1836311903
```

</div>

<div id="3cd4d88c" class="cell markdown"
papermill="{&quot;duration&quot;:5.37e-3,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.340530&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.335160&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video link: <https://youtu.be/EgG3jsGoPvQ?si=Cm5AVvq_zCnr-w6q> Frog
Jump: 1

</div>

<div id="59c27b1e" class="cell code" execution_count="8"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-09T07:01:29.352302Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-09T07:01:29.351814Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-09T07:01:29.356730Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-09T07:01:29.356165Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.1881e-2,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.357806&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.345925&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def frogJumpBetter(N: int, heights: list[int]) -> int:
    """
    Time: O(N), Space: O(N) + O(N)
    """

    @functools.cache
    def backtrack(curr: int) -> int:
        if curr == N - 1:
            return 0
        elif curr == N - 2:
            return abs(heights[N - 1] - heights[N - 2])
        else:
            jump1 = abs(heights[curr] - heights[curr + 1]) + backtrack(curr + 1)
            jump2 = abs(heights[curr] - heights[curr + 2]) + backtrack(curr + 2)
            return min(jump1, jump2)

    return backtrack(0)

# Testing the solution
assert frogJumpBetter(4, [10,20,30,10]) == 20
assert frogJumpBetter(3, [10,50,10]) == 0
```

</div>

<div id="2bc52e04" class="cell code" execution_count="9"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-09T07:01:29.369476Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-09T07:01:29.369306Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-09T07:01:29.373318Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-09T07:01:29.372892Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.1038e-2,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.374333&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.363295&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def frogJumpOptimal(N: int, heights: list[int]) -> int:
    "Time: O(N), Space: O(1)"
    jump1, jump2 = abs(heights[-2] - heights[-1]), 0
    for i in range(N - 3, -1, -1):
        curr = min(abs(heights[i] - heights[i + 1]) + jump1, abs(heights[i] - heights[i + 2]) + jump2)
        jump1, jump2 = curr, jump1

    return jump1

assert frogJumpOptimal(4, [10,20,30,10]) == 20
assert frogJumpOptimal(3, [10,50,10]) == 0
```

</div>

<div id="4fa38d19" class="cell markdown"
papermill="{&quot;duration&quot;:5.389e-3,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.385200&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.379811&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video Link: <https://youtu.be/Kmh3rhyEtB8?si=rqZ5-pJcjIzWU5i8> Frog Jump
with K distance

</div>

<div id="f21ca119" class="cell code" execution_count="10"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-09T07:01:29.396936Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-09T07:01:29.396739Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-09T07:01:29.401191Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-09T07:01:29.400780Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.1735e-2,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.402408&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.390673&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def frogJumpAtKDistBetter1(N: int, K: int, heights: list[int]) -> int:
    """
    Memoization Approach: Top Down Approach
    Time: O(N x K), Space: O(N) + O(N)
    """

    @functools.cache
    def backtrack(curr: int) -> int:
        if curr >= N - 1:
            return 0
        else:
            minCost = math.inf
            for next_ in range(curr + 1, min(N, curr + K + 1)):
                cost = abs(heights[curr] - heights[next_]) + backtrack(next_)
                minCost = min(minCost, cost)

            return int(minCost)

    return backtrack(0)

# Testing the solution
assert frogJumpAtKDistBetter1(5, 3, [10,30,40,50,20]) == 30
assert frogJumpAtKDistBetter1(3, 1, [10,20,10]) == 20
```

</div>

<div id="1b9a86c0" class="cell code" execution_count="11"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-09T07:01:29.414409Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-09T07:01:29.414003Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-09T07:01:29.418610Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-09T07:01:29.418168Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.1611e-2,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.419598&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.407987&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def frogJumpAtKDistBetter2(N: int, K: int, heights: list[int]) -> int:
    """
    Tabulation: Bottom up approach
    Time: O(N x K), Space: O(N)
    """

    dp: list[int] = [-1 for i in range(N)]
    dp[-1] = 0

    for curr in range(N - 2, -1, -1):
        minCost = math.inf
        for next_ in range(curr + 1, min(N, curr + K + 1)):
            cost = abs(heights[curr] - heights[next_]) + dp[next_]
            minCost = min(minCost, cost)
        dp[curr] = int(minCost)

    return dp[0]

# Testing the solution
assert frogJumpAtKDistBetter2(5, 3, [10,30,40,50,20]) == 30
assert frogJumpAtKDistBetter2(3, 1, [10,20,10]) == 20
```

</div>

<div id="09ca5d18" class="cell code" execution_count="12"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-09T07:01:29.431662Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-09T07:01:29.431156Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-09T07:01:29.435881Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-09T07:01:29.435443Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.1739e-2,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.436893&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.425154&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def frogJumpAtKDist(N: int, K: int, heights: list[int]) -> int:
    """
    Tabulation: Bottom up approach
    Time: O(N x K), Space: O(K)
    """

    dp: collections.deque[int] = collections.deque([0])
    for curr in range(N - 2, -1, -1):
        minCost = math.inf
        for jump in range(1, min(N - curr, K + 1)):
            next_ = curr + jump
            cost = abs(heights[curr] - heights[next_]) + dp[jump - 1]
            minCost = min(minCost, cost)

        dp.appendleft(int(minCost))
        if len(dp) > K:
            dp.pop()

    return dp[0]

# Testing the solution
assert frogJumpAtKDist(5, 3, [10,30,40,50,20]) == 30
assert frogJumpAtKDist(3, 1, [10,20,10]) == 20
```

</div>

<div id="259d53f8" class="cell markdown"
papermill="{&quot;duration&quot;:5.484e-3,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.447943&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.442459&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Maximum sum of Non Adjacent Elements: House Robber Video Link:
<https://youtu.be/GrMBfJNk_NY?si=IPuGJglc0axETveU>

</div>

<div id="89d8dea7" class="cell code" execution_count="13"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-09T07:01:29.459770Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-09T07:01:29.459455Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-09T07:01:29.463179Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-09T07:01:29.462685Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.0728e-2,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.464196&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.453468&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def robMemo(nums: list[int]) -> int:
    """
    Memoization: Top down approach
    Time: O(N), Space: O(N)
    """

    @functools.cache
    def backtrack(curr: int) -> int:
        if curr >= N:
            return 0
        else:
            return max(backtrack(curr + 1), nums[curr] + backtrack(curr + 2))

    N = len(nums)
    return backtrack(0)

# Testing the solution
assert robMemo([2,7,9,3,1]) == 12
```

</div>

<div id="e69063ac" class="cell code" execution_count="14"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-09T07:01:29.475974Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-09T07:01:29.475556Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-09T07:01:29.479335Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-09T07:01:29.478917Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.0804e-2,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.480425&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.469621&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def robTab(nums: list[int]) -> int:
    """
    Tabulation: Bottom up approach
    Time: O(N), Space: O(N)
    """
    N = len(nums)
    dp: list[int] = [-1 for i in range(N + 1)]
    dp[-1], dp[-2] = 0, nums[-1]
    for curr in range(N - 2, -1, -1):
        dp[curr] = max(nums[curr] + dp[curr + 2], dp[curr + 1])

    return dp[0]

# Testing the solution
assert robTab([2,7,9,3,1]) == 12
```

</div>

<div id="d3ac1b1c" class="cell code" execution_count="15"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-09T07:01:29.492452Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-09T07:01:29.492240Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-09T07:01:29.495442Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-09T07:01:29.495050Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.0599e-2,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.496514&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.485915&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/house-robber/submissions/1249841355/
def robSpaceOptimized(nums: list[int]) -> int:
    "Time: O(N), Space: O(1)"
    next1 = next2 = 0
    for curr in range(len(nums) - 1, -1, -1):
        next1, next2 = max(nums[curr] + next2, next1), next1

    return next1

assert robSpaceOptimized([2,7,9,3,1]) == 12
```

</div>

<div id="630eec21" class="cell markdown"
papermill="{&quot;duration&quot;:5.421e-3,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.507446&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.502025&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

House Robber 2: <https://youtu.be/3WaxQMELSkw?si=i9oGKnDJGJxvUjbu>
<https://leetcode.com/problems/house-robber-ii/submissions/1249888930>

</div>

<div id="3ee7a5cf" class="cell code" execution_count="16"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-09T07:01:29.519668Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-09T07:01:29.519211Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-09T07:01:29.523263Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-09T07:01:29.522864Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.1247e-2,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.524335&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.513088&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def rob2(nums: list[int]) -> int:
    """
    Ans cannot contain both the first and the last house.
    It can contain either the first or the last house.
    """
    def rob(arr: list[int]) -> int:
        next1 = next2 = 0
        for curr in range(len(arr) - 1, -1, -1):
            next1, next2 = max(arr[curr] + next2, next1), next1

        return next1

    return max(rob(nums[1:]), rob(nums[:-1])) if len(nums) > 1 else sum(nums)

# Testing the solution
assert rob2([1,2,3,1]) == 4
assert rob2([]) == 0
```

</div>

<div id="52745498" class="cell markdown"
papermill="{&quot;duration&quot;:5.428e-3,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.535274&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.529846&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Ninja's Training: <https://youtu.be/AE39gJYuRog?si=n4BhCotno-9chP5j>

</div>

<div id="c814dc79" class="cell code" execution_count="17"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-09T07:01:29.547168Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-09T07:01:29.546814Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-09T07:01:29.551857Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-09T07:01:29.551455Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.2143e-2,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.552939&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.540796&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def ninjaTrainingBetter(N: int, points: list[list[int]]) -> int:
    """
    Memoization: Top down approach

    Time: O(N), Space: O(N) + O(N)
    """

    @functools.cache
    def backtrack(i: int, j: int) -> int:
        if i == N:
            return 0
        else:
            max_ = -math.inf
            for k in range(3):
                if k != j:
                    max_ = max(max_, points[i][k] + backtrack(i + 1, k))

            return int(max_)

    return backtrack(0, -1)

# Testing the solution
assert ninjaTrainingBetter(3, [[10,40,70], [20,50,80], [30,60,90]]) == 210
assert ninjaTrainingBetter(3, [[1,2,5], [3,1,1], [3,3,3]]) == 11
assert ninjaTrainingBetter(2, [[10,50,1], [5,100,11]]) == 110
```

</div>

<div id="015e9458" class="cell code" execution_count="18"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-09T07:01:29.564820Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-09T07:01:29.564530Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-09T07:01:29.569644Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-09T07:01:29.569236Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.2232e-2,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.570710&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.558478&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def ninjaTraining(N: int, points: list[list[int]]) -> int:
    """
    Space optimized Tabulation DP: Bottom up

    Start at the last day.
    At each day we sum up corresponding values with the values in DP and assign them to DP.
    Before moving the prev day, to the DP perform this op -> dp[i] = max(dp[j]) where j != i

    At the end of the iteration simply return max of DP.

    Time: O(N), Space: O(1)
    """

    dp: list[int] = [0, 0, 0]
    for i in range(N - 1, -1, -1):
        for j in range(3):
            dp[j] += points[i][j]

        next_dp: list[int] = []
        for j in range(3):
            next_dp.append(max(dp[k] for k in range(3) if k != j))

        dp = next_dp

    return max(dp)

# Testing the solution
assert ninjaTraining(3, [[10,40,70], [20,50,80], [30,60,90]]) == 210
assert ninjaTraining(3, [[1,2,5], [3,1,1], [3,3,3]]) == 11
assert ninjaTraining(2, [[10,50,1], [5,100,11]]) == 110
```

</div>

<div id="d132fa58" class="cell markdown"
papermill="{&quot;duration&quot;:5.411e-3,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.581696&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.576285&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Unique 2D paths: <https://youtu.be/sdE0A2Oxofw?si=g1FpuSIYx0x95G-7>
<https://leetcode.com/problems/unique-paths/>

</div>

<div id="d035c9d7" class="cell code" execution_count="19"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-09T07:01:29.593556Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-09T07:01:29.593131Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-09T07:01:29.597198Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-09T07:01:29.596756Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.1057e-2,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.598219&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.587162&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def uniquePathsMemo(m: int, n: int) -> int:
    """
    Memoization Solution: Top Down
    Time: O(m x n), Space: O(m x n) + O(m x n)
    """
    @functools.cache
    def backtrack(i: int, j: int) -> int:
        if i == m - 1 and j == n - 1:
            return 1
        elif i >= m or j >= n:
            return 0
        else:
            return backtrack(i + 1, j) + backtrack(i, j + 1)

    return backtrack(0, 0)

# Testing the solution
assert uniquePathsMemo(3, 7) == 28
assert uniquePathsMemo(3, 2) == 3
```

</div>

<div id="c3fb756d" class="cell code" execution_count="20"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-09T07:01:29.610110Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-09T07:01:29.609664Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-09T07:01:29.613488Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-09T07:01:29.612991Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.089e-2,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.614600&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.603710&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/unique-paths/submissions/1250526713
def uniquePathsTab(m: int, n: int) -> int:
    "Time: O(m x n), Space: O(min(m, n))"
    M, N = min(m, n), max(m, n)
    dp: list[int] = [1 for i in range(M)]

    for i in range(N - 1):
        for j in range(M - 2, -1, -1):
            dp[j] += dp[j + 1]

    return dp[0]

# Testing the solution
assert uniquePathsTab(3, 7) == 28
assert uniquePathsTab(3, 2) == 3
```

</div>

<div id="bb22f54a" class="cell markdown"
papermill="{&quot;duration&quot;:5.431e-3,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.625721&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.620290&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video link: <https://youtu.be/TmhpgXScLyY?si=M_FfFKRqRTXid4Jj> Unique
Paths - ii:
<https://leetcode.com/problems/unique-paths-ii/submissions/1250615914>

</div>

<div id="f59a530c" class="cell code" execution_count="21"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-09T07:01:29.637611Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-09T07:01:29.637190Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-09T07:01:29.642049Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-09T07:01:29.641556Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.1931e-2,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.643129&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.631198&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def uniquePathsWithObstacles(obstacleGrid: list[list[int]]) -> int:
    "Time: O(M x N), Space: O(N)"
    M, N = len(obstacleGrid), len(obstacleGrid[0])

    dp: list[int] = [0 for j in range(N)]
    dp[-1] = 1

    for i in range(M - 1, -1, -1):
        for j in range(N - 1, -1, -1):
            if obstacleGrid[i][j] == 0:
                dp[j] = dp[j] + dp[j + 1] if j < N - 1 else dp[j]
            else:
                dp[j] = 0

    return dp[0]

# Testing the solution
assert uniquePathsWithObstacles([[0,0,0],[0,1,0],[0,0,0]]) == 2
assert uniquePathsWithObstacles([[0,1],[0,0]]) == 1
assert uniquePathsWithObstacles([[1]]) == 0
```

</div>

<div id="93e28e9b" class="cell markdown"
papermill="{&quot;duration&quot;:5.46e-3,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.654128&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.648668&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Minimum Path Sum: <https://youtu.be/_rgTlyky1uQ?si=3xJY7MmVg5tTEW5Q>
<https://leetcode.com/problems/minimum-path-sum/submissions/1250633614>

</div>

<div id="c97f7ce9" class="cell code" execution_count="22"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-09T07:01:29.665925Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-09T07:01:29.665554Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-09T07:01:29.670126Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-09T07:01:29.669634Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.1598e-2,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.671182&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.659584&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def minPathSum(grid: list[list[int]]) -> int:
    "Time: O(M x N), Space: O(N)"
    M, N = len(grid), len(grid[0])

    # Initialize DP
    dp: list[float] = [math.inf for j in range(N)]
    dp[-1] = 0

    # DP Solution
    for i in range(M - 1, -1, -1):
        for j in range(N - 1, -1, -1):
            dp[j] = grid[i][j] + (min(dp[j + 1], dp[j]) if j < N - 1 else dp[j])

    return int(dp[0])

# Testing the solution
assert minPathSum([[1,3,1],[1,5,1],[4,2,1]]) == 7
assert minPathSum([[1,2,3],[4,5,6]]) == 12
```

</div>

<div id="107526ff" class="cell markdown"
papermill="{&quot;duration&quot;:5.376e-3,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.682080&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.676704&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video Link: <https://youtu.be/0bHoB32fuj0?si=5UHeArKmLvTVpbrk> Triangle:
<https://leetcode.com/problems/triangle/submissions/1251774955/>

</div>

<div id="62387041" class="cell code" execution_count="23"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-09T07:01:29.693892Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-09T07:01:29.693579Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-09T07:01:29.697792Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-09T07:01:29.697374Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.1195e-2,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.698749&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.687554&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def minimumTotal(triangle: list[list[int]]) -> int:
    """Time: O(N x N), Space: O(N)"""
    N = len(triangle)
    dp: list[int] = [0 for i in range(N + 1)]

    while N > 0:
        next_: list[int] = []
        for i in range(N):
            next_.append(min(dp[i], dp[i + 1]) + triangle[N - 1][i])
        dp = next_
        N -= 1

    return dp[0]

# Testing the solution
assert minimumTotal([[2],[3,4],[6,5,7],[4,1,8,3]]) == 11
assert minimumTotal([[-10]]) == -10
```

</div>

<div id="51332104" class="cell markdown"
papermill="{&quot;duration&quot;:5.482e-3,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.709786&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.704304&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Video Link: <https://youtu.be/N_aJ5qQbYA0?si=LTME1YI3hqtU8u8_> Maximum
Falling path sum We cannot apply greedy algorithms here because there is
no uniformity mentioned. Uniformity implies how the numbers are
distributed. For eg:

    1   2  3    4
    10  1  100  1
    1   2  5    0

In the above example from (0, 0), if we greedily chose (1, 0) - we would
miss out on 100 at (1, 2). If suppose we were told that the numbers were
arranged in ascending or descending order we can greedily pick a path

</div>

<div id="4f9fb3eb" class="cell code" execution_count="24"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-09T07:01:29.721654Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-09T07:01:29.721341Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-09T07:01:29.726489Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-09T07:01:29.725971Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.2303e-2,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.727588&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.715285&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def getMaxPathSumBetter(matrix: list[list[int]]):
    """
    With memoization:
    Time complexity: O(3 ^ N)

    Memoization Approach: Top Down
    Time: O(N x M), Space: O(N x M) + O(N x M)
    """
    M, N = len(matrix), len(matrix[0])

    @functools.cache
    def backtrack(i: int = 0, j: int = 0) -> float:
        if i >= M:
            return 0
        elif j < 0 or j >= N:
            return -math.inf
        else:
            return matrix[i][j] + max(backtrack(i + 1, j - 1), backtrack(i + 1, j), backtrack(i + 1, j + 1))

    maxPathSum = -math.inf
    for j in range(N):
        maxPathSum = max(maxPathSum, backtrack(0, j))

    return int(maxPathSum)

# Testing the solution
assert getMaxPathSumBetter([[1,2,10,4],[100,3,2,1],[1,1,20,2],[1,2,2,1]]) == 105
assert getMaxPathSumBetter([[10,2,3],[3,7,2],[8,1,5]]) == 25
```

</div>

<div id="b3cf95be" class="cell code" execution_count="25"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-09T07:01:29.739841Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-09T07:01:29.739455Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-09T07:01:29.744388Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-09T07:01:29.743865Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.2121e-2,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.745379&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.733258&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def getMaxPathSum(matrix: list[list[int]]):
    """
    Space optimized DP: Bottom up
    Time: O(M x N), Space: O(N)
    """
    M, N = len(matrix), len(matrix[0])

    dp: list[float] = [0 for i in range(N)]
    i = M - 1
    while i >= 0:
        next_: list[float] = []
        for j in range(N):
            next_.append(matrix[i][j] + max(dp[j - 1] if j - 1 >= 0 else -math.inf, dp[j], dp[j + 1] if j + 1 < N else -math.inf))

        dp = next_
        i -= 1

    return max(dp)

# Testing the solution
assert getMaxPathSum([[1,2,10,4],[100,3,2,1],[1,1,20,2],[1,2,2,1]]) == 105
assert getMaxPathSum([[10,2,3],[3,7,2],[8,1,5]]) == 25
```

</div>

<div id="703cdb9d" class="cell markdown"
papermill="{&quot;duration&quot;:5.491e-3,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.756373&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.750882&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Cherry Pickup: 2: <https://leetcode.com/problems/cherry-pickup-ii/>
Video Link: <https://youtu.be/QGfn7JeXK54?si=2K0Lz9iKN_IxLUDN>

</div>

<div id="d82f0e5d" class="cell code" execution_count="26"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-09T07:01:29.768156Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-09T07:01:29.767833Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-09T07:01:29.774480Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-09T07:01:29.773976Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.3647e-2,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.775484&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.761837&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def cherryPickupMemo(grid: list[list[int]]) -> int:
    """
    Without memoization, time complexity: O(3 ^ M * 3 ^ M)

    Space complexity is definitely improved with using @functools.cache, using list here to illustrate.
    Time: O (M x N x N), Space: O (M x N x N)

    To figure out the dp size, simply check how many parameters are chaning. Here we have an i, j1, j2 and hence dp is a 3D Matrix.
    """
    M, N = len(grid), len(grid[0])
    dp: list[list[list[float]]] = [[[-1 for k in range(N)] for j in range(N)] for i in range(M)]

    def backtrack(i: int, j1: int, j2: int) -> float:
        if j1 < 0 or j2 < 0 or j1 >= N or j2 >= N or j1 == j2:
            return -math.inf
        elif i > M - 1:
            return 0
        elif dp[i][j1][j2] != -1:
            return dp[i][j1][j2]
        else:
            next_picked = -math.inf
            for j1_offset in range(-1, 2):
                for j2_offset in range(-1, 2):
                    next_picked = max(next_picked, backtrack(i + 1, j1 + j1_offset, j2 + j2_offset))

            dp[i][j1][j2] = grid[i][j1] + grid[i][j2] + next_picked
            return dp[i][j1][j2]

    result = int(backtrack(0, 0, N - 1))
    return result

# Testing the solution
assert cherryPickupMemo([[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]) == 28
```

</div>

<div id="85c88b05" class="cell code" execution_count="27"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-09T07:01:29.787408Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-09T07:01:29.787059Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-09T07:01:29.794142Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-09T07:01:29.793637Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.4132e-2,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.795155&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.781023&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def cherryPickupTab(grid: list[list[int]]) -> int:
    """
    Simply start with the base case. Move bottom up.
    """
    M, N = len(grid), len(grid[0])

    # Initialize DP with the base case
    dp: list[list[list[float]]] = [[[0 for k in range(N)] for j in range(N)] for i in range(M)]
    for j1 in range(N):
        for j2 in range(N):
            dp[-1][j1][j2] = grid[-1][j1] + grid[-1][j2] if j1 != j2 else grid[-1][j1]

    # i, j1, j2: (0 - M), (0 - N), (0 - N)
    for i in range(M - 2, -1, -1):
        for j1 in range(N):
            for j2 in range(N):
                max_: float = -math.inf
                curr = grid[i][j1] + grid[i][j2] if j1 != j2 else grid[i][j1]
                for j1_offset in range(-1, 2):
                    for j2_offset in range(-1, 2):
                        if 0 <= j1 + j1_offset < N and 0 <= j2 + j2_offset < N:
                            max_ = max(max_, dp[i + 1][j1 + j1_offset][j2 + j2_offset])

                dp[i][j1][j2] = max(-1, max_ + curr)

    return int(dp[0][0][-1])

# Testing the solution
assert cherryPickupTab([[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]) == 28
```

</div>

<div id="e2fdb650" class="cell code" execution_count="28"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-09T07:01:29.806962Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-09T07:01:29.806658Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-09T07:01:29.813242Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-09T07:01:29.812749Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.3653e-2,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.814311&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.800658&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def cherryPickupSpaceOptimized(grid: list[list[int]]) -> int:
    M, N = len(grid), len(grid[0])
    dp: list[list[float]] = [[grid[-1][j1] + grid[-1][j2] if j1 != j2 else grid[-1][j1] for j1 in range(N)] for j2 in range(N)]

    for i in range(M - 2, -1, -1):
        dp_next: list[list[float]] = []
        for j1 in range(N):
            dp_next.append([])
            for j2 in range(N):
                max_: float = -math.inf
                curr = grid[i][j1] + grid[i][j2] if j1 != j2 else grid[i][j1]
                for j1_offset in range(-1, 2):
                    for j2_offset in range(-1, 2):
                        if 0 <= j1 + j1_offset < N and 0 <= j2 + j2_offset < N:
                            max_ = max(max_, dp[j1 + j1_offset][j2 + j2_offset])

                dp_next[j1].append(curr + max_)
        dp = dp_next

    return int(dp[0][-1])

# Testing the solution
assert cherryPickupSpaceOptimized([[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]) == 28
```

</div>

<div id="17816765" class="cell markdown"
papermill="{&quot;duration&quot;:5.502e-3,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.825397&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.819895&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Subset sum equals target Video Link:
<https://youtu.be/fWX9xDmIzRI?si=jb2Tgvw_E0Tyk1Pj>

</div>

<div id="4f37d7b7" class="cell code" execution_count="29"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-09T07:01:29.837484Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-09T07:01:29.837048Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-09T07:01:29.842170Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-09T07:01:29.841743Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.2222e-2,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.843176&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.830954&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def isSubsetSumMemo(N: int, arr: list[int], target: int) -> int:
    """
    For cases where subset exists, the recursion would stop early. For the negative cases, we would get overlapping subproblems and
    hence memoization would help decrease the time complexity.

    Time without memoization: O(2 ^ N), Space: O(N)
    With memoization: O(N x target), Space: O(N x target) + O(N)
    """

    dp: list[list[int]] = [[-1 for j in range(target + 1)] for i in range(N)]
    def backtrack(i: int, total: int) -> bool:
        if total == 0:
            return True
        elif total < 0 or i > N - 1:
            return False
        elif dp[i][total] != -1:
            return bool(dp[i][total])
        else:
            result = backtrack(i + 1, total - arr[i]) or backtrack(i + 1, total)
            dp[i][total] = int(result)
            return result

    return backtrack(0, target)

# Testing the solution
assert isSubsetSumMemo(6, [3, 34, 4, 12, 5, 2], 9) == True
assert isSubsetSumMemo(6, [3, 34, 4, 12, 5, 2], 30) == False
```

</div>

<div id="5551c36b" class="cell code" execution_count="30"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-09T07:01:29.855529Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-09T07:01:29.855094Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-09T07:01:29.860867Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-09T07:01:29.860383Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.3056e-2,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.861956&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.848900&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def isSubsetSumTab(N: int, arr: list[int], target: int) -> bool:
    """
    Each cell in the dp represents -> If total - arr[i] is true down the line.
    Note that dp[i][0] is always true, since if the target is to be 0 regardless of arr[i] tehn subsetSumTarget is possible.
    """
    dp: list[list[int]] = [[1 if j == 0 else -1 if i < N else 0 for j in range(target + 1)] for i in range(N + 1)]

    for i in range(N - 1, -1, -1):
        for total in range(1, target + 1):
            if dp[i + 1][total] == 1 or (total - arr[i] >= 0 and dp[i + 1][total - arr[i]] == 1):
                dp[i][total] = 1
            else:
                dp[i][total] = 0

    print(dp)
    return bool(dp[0][target])

# Testing the solution
assert isSubsetSumTab(6, [3, 34, 4, 12, 5, 2], 9) == True
assert isSubsetSumTab(6, [3, 34, 4, 12, 5, 2], 30) == False
```

<div class="output stream stdout">

    [[1, 0, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1], [1, 0, 1, 0, 0, 1, 0, 1, 0, 0], [1, 0, 1, 0, 0, 1, 0, 1, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
    [[1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

</div>

</div>

<div id="ca80b369" class="cell code" execution_count="31"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-09T07:01:29.874156Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-09T07:01:29.873777Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-09T07:01:29.878386Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-09T07:01:29.877981Z&quot;}"
lines_to_next_cell="1"
papermill="{&quot;duration&quot;:1.1808e-2,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.879460&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.867652&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
def isSubsetSumSpaceOptimized(N: int, arr: list[int], target: int) -> bool:
    "Time: O(N x target), Space: O(target)"
    dp: list[int] = [0 if j > 0 else 1 for j in range(target + 1)]

    for i in range(N - 1, -1, -1):
        next_: list[int] = []
        for total in range(target + 1):
            if total == 0 or dp[total] == 1 or (total - arr[i] >= 0 and dp[total - arr[i]] == 1):
                next_.append(1)
            else:
                next_.append(0)

        dp = next_

    return bool(dp[target])

# Testing the solution
assert isSubsetSumSpaceOptimized(6, [3, 34, 4, 12, 5, 2], 9) == True
assert isSubsetSumSpaceOptimized(6, [3, 34, 4, 12, 5, 2], 30) == False
```

</div>

<div id="7a10f4ca" class="cell markdown"
papermill="{&quot;duration&quot;:5.583e-3,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.890756&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.885173&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

Partition equal subset sum:
<https://leetcode.com/problems/partition-equal-subset-sum/> Video Link:
<https://youtu.be/7win3dcgo3k?si=LJO4Ot4EZzQ2fRc0>

</div>

<div id="373088cf" class="cell code" execution_count="32"
execution="{&quot;iopub.execute_input&quot;:&quot;2024-05-09T07:01:29.903109Z&quot;,&quot;iopub.status.busy&quot;:&quot;2024-05-09T07:01:29.902591Z&quot;,&quot;iopub.status.idle&quot;:&quot;2024-05-09T07:01:29.907898Z&quot;,&quot;shell.execute_reply&quot;:&quot;2024-05-09T07:01:29.907364Z&quot;}"
papermill="{&quot;duration&quot;:1.2722e-2,&quot;end_time&quot;:&quot;2024-05-09T07:01:29.909174&quot;,&quot;exception&quot;:false,&quot;start_time&quot;:&quot;2024-05-09T07:01:29.896452&quot;,&quot;status&quot;:&quot;completed&quot;}"
tags="[]">

``` python
# https://leetcode.com/problems/partition-equal-subset-sum/submissions/1253314239
def canPartition(nums: list[int]) -> bool:
    def subsetSumEqualsTarget(target: int) -> bool:
        "Time: O(N x target), Space: O(target)"
        dp: list[bool] = [False if i > 0 else True for i in range(target + 1)]
        for i in range(N - 1, -1, -1):
            next_: list[bool] = []
            for total in range(target + 1):
                if total == 0 or dp[total] or (total - nums[i] >= 0 and dp[total - nums[i]]):
                    next_.append(True)
                else:
                    next_.append(False)

            dp = next_

        return dp[target]

    N = len(nums)
    total = sum(nums)
    return total % 2 == 0 and subsetSumEqualsTarget(total // 2)

# Testing the solution
assert canPartition([1,5,11,5]) == True
assert canPartition([1,2,3,5]) == False
assert canPartition([3,3,3,4,5]) == True
```

</div>
